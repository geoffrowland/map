{"version":3,"sources":["webpack:///./node_modules/terriajs-cesium/Source/Core/CornerType.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CompositeProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CompositePositionProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/ReferenceProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/ScaledPositionProperty.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/OrderedGroundPrimitiveCollection.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/BillboardVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceVS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceFS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceVS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceFS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceVS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceFS.js","webpack:///./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/TerrainOffsetProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/heightReferenceOnEntityPropertyChanged.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/BoxGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CorridorGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CorridorGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CorridorOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/GroundGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CorridorGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CylinderGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CylinderGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CylinderOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CylinderGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryBatch.js","webpack:///./node_modules/terriajs-cesium/Source/Core/EllipseGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/EllipseGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/EllipseOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/EllipseGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/EllipsoidGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PlaneGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PlaneOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PlaneGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolygonGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolygonOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolygonGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineVolumeOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineVolumeGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/RectangleGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/RectangleGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryColorBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryPerMaterialBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryColorBatch.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/quickselect.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/rbush.js","webpack:///./node_modules/terriajs-cesium/Source/Core/RectangleCollisionChecker.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryPerMaterialBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticOutlineGeometryBatch.js","webpack:///./node_modules/terriajs-cesium/Source/Core/WallGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/WallGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/WallOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/WallGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/GeometryVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/LabelVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/ModelVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PathVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PointVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGroundPolylinePerMaterialBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/DataSourceDisplay.js"],"names":["_freezeObject_js__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","__webpack_exports__","Object","ROUNDED","MITERED","BEVELED","_Core_defined_js__WEBPACK_IMPORTED_MODULE_0__","_Core_defineProperties_js__WEBPACK_IMPORTED_MODULE_1__","_Core_Event_js__WEBPACK_IMPORTED_MODULE_3__","_Core_EventHelper_js__WEBPACK_IMPORTED_MODULE_4__","_Core_TimeIntervalCollection_js__WEBPACK_IMPORTED_MODULE_5__","_Property_js__WEBPACK_IMPORTED_MODULE_6__","CompositeProperty","this","_eventHelper","_definitionChanged","_intervals","changedEvent","addEventListener","prototype","_intervalsChanged","isConstant","get","isEmpty","definitionChanged","intervals","getValue","time","result","innerProperty","findDataForIntervalContainingDate","equals","other","property","eventHelper","callback","raiseEvent","items","removeAll","length","i","interval","data","indexOf","add","subscribeAll","_Core_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__","_Core_defined_js__WEBPACK_IMPORTED_MODULE_1__","_Core_defineProperties_js__WEBPACK_IMPORTED_MODULE_2__","_Core_Event_js__WEBPACK_IMPORTED_MODULE_4__","_Core_ReferenceFrame_js__WEBPACK_IMPORTED_MODULE_5__","_CompositeProperty_js__WEBPACK_IMPORTED_MODULE_6__","_Property_js__WEBPACK_IMPORTED_MODULE_7__","CompositePositionProperty","referenceFrame","_referenceFrame","FIXED","_composite","_raiseDefinitionChanged","set","value","getValueInReferenceFrame","_Core_RuntimeError_js__WEBPACK_IMPORTED_MODULE_4__","_Property_js__WEBPACK_IMPORTED_MODULE_5__","resolve","that","targetProperty","_targetProperty","_resolveProperty","entityIsResolved","_resolveEntity","targetEntity","_targetCollection","getById","_targetId","ReferenceProperty","_onTargetEntityDefinitionChanged","_targetEntity","resolveEntity","names","_targetPropertyNames","join","targetCollection","targetId","targetPropertyNames","undefined","collectionChanged","_onCollectionChanged","resolvedProperty","fromString","referenceString","identifier","values","inIdentifier","isEscaped","token","c","charAt","push","getType","otherNames","name","oldValue","collection","added","removed","removeEventListener","_Core_Ellipsoid_js__WEBPACK_IMPORTED_MODULE_3__","ScaledPositionProperty","_value","_removeSubscription","setValue","WGS84","scaleToGeodeticSurface","OrderedGroundPrimitiveCollection","_length","_collections","_collectionsArray","show","defineProperties","primitive","zIndex","defaultValue","defined","PrimitiveCollection","destroyPrimitives","_zIndex","array","splice","remove","doNotDestroy","contains","index","removeAndDestroy","destroy","collections","update","frameState","isDestroyed","destroyObject","Scene_OrderedGroundPrimitiveCollection","defaultColor","Color","WHITE","defaultEyeOffset","Cartesian3","ZERO","defaultHeightReference","HeightReference","NONE","defaultPixelOffset","Cartesian2","defaultAlignedAxis","defaultHorizontalOrigin","HorizontalOrigin","CENTER","defaultVerticalOrigin","VerticalOrigin","positionScratch","colorScratch","eyeOffsetScratch","pixelOffsetScratch","scaleByDistanceScratch","NearFarScalar","translucencyByDistanceScratch","pixelOffsetScaleByDistanceScratch","boundingRectangleScratch","BoundingRectangle","distanceDisplayConditionScratch","DistanceDisplayCondition","EntityData","entity","billboard","textureValue","BillboardVisualizer","entityCluster","entityCollection","_cluster","_entityCollection","_items","AssociativeArray","returnPrimitive","item","cluster","removeBillboard","len","position","billboardGraphics","_billboard","isShowing","isAvailable","Property","getValueOrDefault","_show","getValueOrUndefined","_position","_image","_clusterDirty","getBillboard","id","image","color","_color","eyeOffset","_eyeOffset","heightReference","_heightReference","pixelOffset","_pixelOffset","scale","_scale","rotation","_rotation","alignedAxis","_alignedAxis","horizontalOrigin","_horizontalOrigin","verticalOrigin","_verticalOrigin","width","_width","height","_height","scaleByDistance","_scaleByDistance","translucencyByDistance","_translucencyByDistance","pixelOffsetScaleByDistance","_pixelOffsetScaleByDistance","sizeInMeters","_sizeInMeters","distanceDisplayCondition","_distanceDisplayCondition","disableDepthTestDistance","_disableDepthTestDistance","subRegion","_imageSubRegion","setImageSubRegion","_imageId","getBoundingSphere","BoundingSphereState","FAILED","center","clone","_clampedPosition","PENDING","radius","DONE","entities","changed","DataSources_BillboardVisualizer","MaterialAppearance","options","EMPTY_OBJECT","translucent","closed","materialSupport","MaterialSupport","TEXTURED","material","Material","fromType","ColorType","_vertexShaderSource","vertexShaderSource","_fragmentShaderSource","fragmentShaderSource","_renderState","Appearance","getDefaultRenderState","renderState","_closed","_materialSupport","_vertexFormat","vertexFormat","_flat","flat","_faceForward","faceForward","getFragmentShaderSource","isTranslucent","getRenderState","BASIC","freezeObject","VertexFormat","POSITION_AND_NORMAL","POSITION_NORMAL_AND_ST","ALL","Scene_MaterialAppearance","DistanceDisplayConditionGeometryInstanceAttribute","near","far","Number","MAX_VALUE","Float32Array","componentDatatype","ComponentDatatype","FLOAT","componentsPerAttribute","normalize","fromDistanceDisplayCondition","toValue","Core_DistanceDisplayConditionGeometryInstanceAttribute","MaterialProperty","DeveloperError","throwInstantiationError","materialProperty","type","uniforms","DataSources_MaterialProperty","DynamicGeometryUpdater","geometryUpdater","primitives","orderedGroundPrimitives","_primitives","_orderedGroundPrimitives","_primitive","_outlinePrimitive","_geometryUpdater","_options","_entity","_material","_isHidden","geometry","_setOptions","onTerrain","_onTerrain","_geometryPropertyName","shadows","shadowsProperty","fill","appearance","fillMaterialProperty","isColorAppearance","ColorMaterialProperty","_getIsClosed","PerInstanceColorAppearance","_supportsMaterialsforEntitiesOnTerrain","VERTEX_FORMAT","GroundPrimitive","geometryInstances","createFillGeometryInstance","asynchronous","classificationType","classificationTypeProperty","fillInstance","attributes","Primitive","outline","outlineInstance","createOutlineGeometryInstance","outlineWidth","lineWidth","_scene","clampLineWidth","outlinePrimitive","ready","getGeometryInstanceAttributes","boundingSphere","BoundingSphere","DataSources_DynamicGeometryUpdater","defaultMaterial","defaultShow","ConstantProperty","defaultFill","defaultOutline","defaultOutlineColor","BLACK","defaultShadows","ShadowMode","DISABLED","defaultDistanceDisplayCondition","defaultClassificationType","ClassificationType","BOTH","GeometryUpdater","geometryPropertyName","scene","_fillEnabled","_isClosed","_dynamic","_outlineEnabled","_geometryChanged","Event","_showProperty","_materialProperty","_showOutlineProperty","_outlineColorProperty","_outlineWidth","_shadowsProperty","_distanceDisplayConditionProperty","_classificationTypeProperty","geometryOptions","_id","_observedPropertyNames","observedPropertyNames","Entity","supportsMaterialsforEntitiesOnTerrain","fillEnabled","hasConstantFill","availability","_fillProperty","outlineEnabled","hasConstantOutline","outlineColorProperty","distanceDisplayConditionProperty","isDynamic","isClosed","geometryChanged","isOutlineVisible","visible","isFilled","Iso8601","MINIMUM_VALUE","_isOnTerrain","_isDynamic","_setStaticOptions","_onEntityPropertyChanged","propertyName","newValue","fillProperty","outlineProperty","outlineColor","oneTimeWarning","geometryOutlines","createDynamicUpdater","groundPrimitives","constructor","DataSources_GeometryUpdater","scratchPosition","scratchCarto","Cartographic","TerrainOffsetProperty","positionProperty","heightReferenceProperty","extrudedHeightReferenceProperty","_extrudedHeightReference","_positionProperty","_cartographicPosition","_normal","_terrainHeight","_removeCallbackFunc","_removeEventListener","_removeModeListener","globe","terrainProviderChanged","_updateClamping","morphComplete","ellipsoid","geodeticSurfaceNormal","surface","_surface","cartographicPosition","cartesianToCartographic","getHeight","updateHeight","clampedPosition","mode","SceneMode","SCENE3D","carto","x","extrudedHeightReference","RELATIVE_TO_GROUND","multiplyByScalar","equalsEpsilon","Core_Math","EPSILON10","normal","DataSources_TerrainOffsetProperty","DataSources_heightReferenceOnEntityPropertyChanged","call","_terrainOffsetProperty","centerPosition","CallbackProperty","_computeCenter","bind","defaultOffset","offsetScratch","BoxGeometryUpdater_positionScratch","scratchColor","BoxGeometryOptions","dimensions","offsetAttribute","BoxGeometryUpdater","box","DynamicBoxGeometryUpdater","create","terrainOffsetProperty","currentColor","ShowGeometryInstanceAttribute","offset","ColorGeometryInstanceAttribute","fromColor","OffsetGeometryInstanceAttribute","fromCartesian3","GeometryInstance","BoxGeometry","fromDimensions","modelMatrix","computeModelMatrixForHeightReference","z","mapProjection","BoxOutlineGeometry","orientation","GeometryOffsetAttribute","DataSources_BoxGeometryUpdater","scratch2Array","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCartesian7","scratchCartesian8","scratchCartesian9","scratch1","scratch2","PolylineVolumeGeometryLibrary","cartographic","subdivideHeights","points","h0","h1","granularity","p0","p1","angleBetween","numPoints","Math","ceil","heights","Array","heightPerVertex","h","nextScratch","prevScratch","negativeX","PolylineVolumeGeometryLibrary_transform","Matrix4","PolylineVolumeGeometryLibrary_translation","rotationZ","Matrix3","scaleMatrix","IDENTITY","westScratch","finalPosScratch","Cartesian4","heightCartesian","addPosition","left","shape","finalPositions","xScalar","repeat","west","finalPosition","Transforms","eastNorthUpToFixedFrame","multiplyByPointAsVector","angle","start","end","tangentPlane","EllipsoidTangentPlane","next","projectPointOntoPlane","prev","y","computeRotationAngle","fromRotationZ","multiplyTransformation","fromRotationTranslation","j","fromArray","multiplyByVector","multiplyByPoint","centerScratch","addPositions","centers","convertShapeTo3D","shape2D","boundingRectangle","xOffset","yOffset","quaterion","Quaternion","startPointScratch","rotMatrix","computeRoundCorner","pivot","startPoint","endPoint","cornerType","leftIsOutside","duplicatePoints","m","subtract","CornerType","toRadians","fromQuaternion","fromAxisAngle","negate","removeDuplicatesFromShape","shapePositions","cleanedPositions","i0","i1","v0","v1","angleIsGreaterThanPi","forward","backward","scratchForwardProjection","scratchBackwardProjection","computePositions","positions","_ellipsoid","pos","scaleToSurface","_granularity","_cornerType","shapeForSides","point","convertShapeTo3DDuplicate","shapeForEnds","heightOffset","ends","cornerDirection","surfaceNormal","previousPosition","nextPosition","cross","subdividedHeights","forwardProjection","dot","backwardProjection","abs","EPSILON7","scalar","max","magnitude","PolylinePipeline","generateArc","posLength","combinedPositions","Float64Array","Core_PolylineVolumeGeometryLibrary","CorridorGeometryLibrary","CorridorGeometryLibrary_scratch1","CorridorGeometryLibrary_scratch2","scratch3","scratch4","scaleArray2","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","cartesian7","cartesian8","cartesian9","cartesian10","CorridorGeometryLibrary_quaterion","CorridorGeometryLibrary_rotMatrix","CorridorGeometryLibrary_computeRoundCorner","cornerPoint","size","computeMiteredCorner","leftCornerDirection","lastPoint","addShiftedPositions","calculatedPositions","rightPositions","leftPositions","scaledLeft","scaledRight","rightIndex","leftIndex","rightPos","leftPos","addAttribute","attribute","front","back","CorridorGeometryLibrary_scratchForwardProjection","CorridorGeometryLibrary_scratchBackwardProjection","params","saveAttributes","previousPos","calculatedLefts","calculatedNormals","endPositions","corners","leftEdge","firstEndCap","midpoint","rightEdge","addEndCaps","lefts","normals","Core_CorridorGeometryLibrary","CorridorGeometry_cartesian1","CorridorGeometry_cartesian2","CorridorGeometry_cartesian3","CorridorGeometry_cartesian4","CorridorGeometry_cartesian5","CorridorGeometry_cartesian6","CorridorGeometry_scratch1","CorridorGeometry_scratch2","CorridorGeometry_scaleToSurface","addNormals","attr","tangents","bitangents","tangent","bitangent","combine","computedPositions","corner","computedLefts","computedNormals","GeometryAttributes","leftCount","rightCount","indicesLength","leftSide","endPositionLength","addEndPositions","UL","LL","UR","LR","halfLength","indices","IndexDatatype","createTypedArray","firstEndPositions","rightNormal","leftNormal","posIndex","compIndex","l","r","outsidePoint","previousPoint","nextPoint","lastEndPositions","GeometryAttribute","DOUBLE","st","rightSt","leftSt","stIndex","a","theta","PI","halfEndPos","PI_OVER_TWO","cos","sin","addWallPositions","wallPositions","computePositionsExtruded","topVertexFormat","shadowVolume","extrudedHeight","newPositions","extrudedPositions","PolygonPipeline","scaleToGeodeticHeight","topNormals","topBitangents","threeSize","twoSize","sixSize","topPosition","bottomPosition","attrIndex","attrIndexOffset","topTangents","topSt","s","t","extrudedAttributes","extrudeNormals","extrudeDirection","applyOffset","Uint8Array","TOP","arrayFill","applyOffsetValue","UNSIGNED_BYTE","iLength","newIndices","v2","CorridorGeometry_scratchCartesian1","CorridorGeometry_scratchCartesian2","scratchCartographic","computeOffsetPoints","position1","position2","halfWidth","min","direction","offsetDirection","minLat","latitude","minLon","longitude","maxLat","maxLon","lat","lon","scratchCartesianOffset","scratchCartesianEnds","scratchCartographicMin","scratchCartographicMax","computeRectangle","cleanPositions","arrayRemoveDuplicates","Rectangle","POSITIVE_INFINITY","NEGATIVE_INFINITY","first","last","rectangle","north","south","east","CorridorGeometry","_positions","Ellipsoid","DEFAULT","_extrudedHeight","RADIANS_PER_DEGREE","_shadowVolume","_workerName","_offsetAttribute","_rectangle","packedLength","pack","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","createGeometry","corridorGeometry","extrude","EPSILON2","fromVertices","Geometry","primitiveType","PrimitiveType","TRIANGLES","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","textureCoordinateRotationPoints","Core_CorridorGeometry","CorridorOutlineGeometry_cartesian1","CorridorOutlineGeometry_cartesian2","CorridorOutlineGeometry_cartesian3","CorridorOutlineGeometry_combine","wallIndices","floor","CorridorOutlineGeometry","CorridorOutlineGeometry_scratchEllipsoid","CorridorOutlineGeometry_scratchOptions","corridorOutlineGeometry","CorridorOutlineGeometry_scaleToSurface","CorridorOutlineGeometry_computePositionsExtruded","offsetValue","LINES","Core_CorridorOutlineGeometry","defaultZIndex","GroundGeometryUpdater","isSupported","geometryZIndex","getGeometryHeight","CLAMP_TO_GROUND","geometryHeightReference","getGeometryExtrudedHeight","geometryExtrudedHeightReference","computeGeometryOffsetAttribute","n","DataSources_GroundGeometryUpdater","CorridorGeometryUpdater_scratchColor","CorridorGeometryUpdater_defaultOffset","CorridorGeometryUpdater_offsetScratch","scratchRectangle","CorridorGeometryOptions","CorridorGeometryUpdater","corridor","DynamicCorridorGeometryUpdater","heightValue","heightReferenceValue","extrudedHeightValue","extrudedHeightReferenceValue","ApproximateTerrainHeights","getMinimumMaximumHeights","minimumTerrainHeight","DataSources_CorridorGeometryUpdater","CylinderGeometryLibrary","topRadius","bottomRadius","slices","topZ","bottomZ","twoSlice","tbIndex","bottomOffset","topOffset","TWO_PI","bottomX","bottomY","topX","topY","Core_CylinderGeometryLibrary","radiusScratch","normalScratch","bitangentScratch","tangentScratch","CylinderGeometry_positionScratch","CylinderGeometry","_topRadius","_bottomRadius","_slices","unitCylinderGeometry","CylinderGeometry_scratchVertexFormat","CylinderGeometry_scratchOptions","cylinderGeometry","twoSlices","threeSlices","numVertices","computeNormal","computeTangent","normalIndex","tangentIndex","bitangentIndex","atan2","normalScale","UNIT_Z","numIndices","textureCoordIndex","rad","getUnitCylinder","Core_CylinderGeometry","CylinderOutlineGeometry_radiusScratch","CylinderOutlineGeometry","numberOfVerticalLines","_numberOfVerticalLines","CylinderOutlineGeometry_scratchOptions","numSide","numSideLines","round","Core_CylinderOutlineGeometry","CylinderGeometryUpdater_defaultOffset","CylinderGeometryUpdater_offsetScratch","CylinderGeometryUpdater_positionScratch","CylinderGeometryUpdater_scratchColor","CylinderGeometryOptions","CylinderGeometryUpdater","cylinder","DynamicCylinderGeometryUpdater","DataSources_CylinderGeometryUpdater","DynamicGeometryBatch","_dynamicUpdaters","updater","dynamicUpdater","geometries","removeAllPrimitives","DataSources_DynamicGeometryBatch","EllipseGeometryLibrary","rotAxis","tempVec","unitQuat","rotMtx","pointOnEllipsoid","northVec","eastVec","aSqr","ab","bSqr","mag","unitPos","azimuth","cosThetaSquared","sinThetaSquared","sqrt","EllipseGeometryLibrary_scratchCartesian1","EllipseGeometryLibrary_scratchCartesian2","EllipseGeometryLibrary_scratchCartesian3","scratchNormal","raisePositionsToHeight","i2","extrudedPosition","scaledNormal","unitPosScratch","eastVecScratch","northVecScratch","computeEllipsePositions","addFillPositions","addEdgePositions","semiMinorAxis","semiMajorAxis","numPts","deltaTheta","numInterior","interiorPosition","positionIndex","reflectedPosition","outerPositionsLength","outerRightIndex","outerLeftIndex","outerPositions","lerp","Core_EllipseGeometryLibrary","EllipseGeometry_scratchCartesian1","EllipseGeometry_scratchCartesian2","EllipseGeometry_scratchCartesian3","EllipseGeometry_scratchCartesian4","texCoordScratch","textureMatrixScratch","tangentMatrixScratch","quaternionScratch","EllipseGeometry_scratchNormal","scratchTangent","scratchBitangent","EllipseGeometry_scratchCartographic","projectedCenterScratch","scratchMinTexCoord","scratchMaxTexCoord","computeTopBottomAttributes","stRotation","textureCoordinates","projection","GeographicProjection","projectedCenter","project","geodeticNormal","textureMatrix","tangentMatrix","minTexCoord","fromElements","maxTexCoord","stOffset","rotatedPoint","projectedPoint","k","topIndices","prevIndex","indicesIndex","boundingSphereCenter","topBoundingSphere","bottomBoundingSphere","computeExtrudedEllipse","cep","union","topBottomAttributes","topBottomIndices","topBottomGeo","wallAttributes","bottom","computeWallAttributes","computeWallIndices","wallGeo","geo","GeometryPipeline","combineInstances","EllipseGeometry_computeRectangle","positionsFlat","positionsCount","fromCartesianArray","EllipseGeometry","_center","_semiMajorAxis","_semiMinorAxis","_stRotation","_textureCoordinateRotationPoints","scratchCenter","EllipseGeometry_scratchEllipsoid","EllipseGeometry_scratchVertexFormat","EllipseGeometry_scratchOptions","ellipseGeometry","computeEllipse","Core_EllipseGeometry","EllipseOutlineGeometry_scratchCartesian1","EllipseOutlineGeometry_boundingSphereCenter","EllipseOutlineGeometry_topBoundingSphere","EllipseOutlineGeometry_bottomBoundingSphere","EllipseOutlineGeometry","EllipseOutlineGeometry_scratchCenter","EllipseOutlineGeometry_scratchEllipsoid","EllipseOutlineGeometry_scratchOptions","clamp","maxI","EllipseOutlineGeometry_computeExtrudedEllipse","EllipseOutlineGeometry_computeEllipse","Core_EllipseOutlineGeometry","EllipseGeometryUpdater_scratchColor","EllipseGeometryUpdater_defaultOffset","EllipseGeometryUpdater_offsetScratch","EllipseGeometryUpdater_scratchRectangle","EllipseGeometryOptions","EllipseGeometryUpdater","ellipse","DynamicEllipseGeometryUpdater","DataSources_EllipseGeometryUpdater","EllipsoidGeometryUpdater_defaultMaterial","EllipsoidGeometryUpdater_defaultOffset","EllipsoidGeometryUpdater_offsetScratch","radiiScratch","innerRadiiScratch","EllipsoidGeometryUpdater_scratchColor","unitSphere","EllipsoidGeometryOptions","radii","innerRadii","minimumClock","maximumClock","minimumCone","maximumCone","stackPartitions","slicePartitions","subdivisions","EllipsoidGeometryUpdater","DynamicEllipsoidGeometryUpdater","_modelMatrix","_attributes","_outlineAttributes","_lastSceneMode","_lastShow","_lastOutlineShow","_lastOutlineWidth","_lastOutlineColor","_lastOffset","skipModelMatrix","modelMatrixResult","EllipsoidGeometry","EllipsoidOutlineGeometry","showFill","showOutline","getValueOrClonedDefault","sceneMode","in3D","_lastDistanceDisplayCondition","outlineAttributes","multiplyByScale","DataSources_EllipsoidGeometryUpdater","PlaneGeometry","PlaneGeometry_scratchVertexFormat","PlaneGeometry_scratchOptions","PlaneGeometry_min","PlaneGeometry_max","planeGeometry","texCoords","Uint16Array","Core_PlaneGeometry","PlaneOutlineGeometry","PlaneOutlineGeometry_min","PlaneOutlineGeometry_max","Core_PlaneOutlineGeometry","PlaneGeometryUpdater_positionScratch","PlaneGeometryUpdater_scratchColor","PlaneGeometryOptions","plane","PlaneGeometryUpdater","DynamicPlaneGeometryUpdater","distanceDisplayConditionAttribute","planeGraphics","computeModelMatrix","createPrimitiveMatrix","isColorMaterial","scratchAxis","scratchAxis2","scratchTranslation","PlaneGeometryUpdater_scratchNormal","scratchScale","scratchQuaternion","scratchMatrix3","transform","distance","translation","transformedNormal","up","EPSILON8","rotationMatrix","setColumn","fromRotationMatrix","fromTranslationQuaternionRotationScale","DataSources_PlaneGeometryUpdater","CoplanarPolygonGeometryLibrary","scratchIntersectionPoint","scratchXAxis","scratchYAxis","scratchZAxis","obbScratch","OrientedBoundingBox","projectTo2D","axis1","axis2","v","validOutline","halfAxes","fromPoints","xAxis","getColumn","yAxis","zAxis","xMag","yMag","zMag","computeProjectTo2DArguments","centerResult","planeAxis1Result","planeAxis2Result","planeAxis1","planeAxis2","orientedBoundingBox","createProjectPointsTo2DFunction","positionResults","createProjectPointTo2DFunction","Core_CoplanarPolygonGeometryLibrary","CoplanarPolygonGeometry_scratchPosition","scratchBR","stScratch","textureCoordinatesOrigin","CoplanarPolygonGeometry_scratchNormal","CoplanarPolygonGeometry_scratchTangent","CoplanarPolygonGeometry_scratchBitangent","CoplanarPolygonGeometry_centerScratch","axis1Scratch","axis2Scratch","CoplanarPolygonGeometry_quaternionScratch","CoplanarPolygonGeometry_textureMatrixScratch","tangentRotationScratch","surfaceNormalScratch","createGeometryFromPolygon","polygon","projectPointTo2D","triangulate","positions2D","holes","tangentRotation","stOrigin","flatPositions","stx","sty","CoplanarPolygonGeometry","polygonHierarchy","_polygonHierarchy","PolygonGeometryLibrary","computeHierarchyPackedLength","fromPositions","packPolygonHierarchy","CoplanarPolygonGeometry_scratchEllipsoid","CoplanarPolygonGeometry_scratchVertexFormat","CoplanarPolygonGeometry_scratchOptions","unpackPolygonHierarchy","polygonGeometry","EPSILON6","projectPoints","projectPoint","results","polygonsFromHierarchy","hierarchy","polygons","outerRing","computeBoundingRectangle","geometryInstance","Core_CoplanarPolygonGeometry","createGeometryFromPositions","CoplanarPolygonOutlineGeometry","CoplanarPolygonOutlineGeometry_scratchOptions","polygonOutlinesFromHierarchy","Core_CoplanarPolygonOutlineGeometry","scratchCarto1","scratchCarto2","adjustPosHeightsForNormal","p2","p1Carto","cartographicToCartesian","p2Carto","scratchBoundingRectangle","PolygonGeometry_scratchPosition","PolygonGeometry_scratchNormal","PolygonGeometry_scratchTangent","PolygonGeometry_scratchBitangent","p1Scratch","p2Scratch","scratchPerPosNormal","scratchPerPosTangent","scratchPerPosBitangent","appendTextureCoordinatesOrigin","appendTextureCoordinatesCartesian2","appendTextureCoordinatesCartesian3","appendTextureCoordinatesQuaternion","appendTextureCoordinatesMatrix3","PolygonGeometry_tangentMatrixScratch","computeAttributes","wall","top","perPositionHeight","origin","recomputeNormal","tangentRotationMatrix","_plane","bottomOffset2","p","attrIndex1","attrIndex2","startCartographicScratch","endCartographicScratch","PolygonGeometry_idlCross","westOverIDL","eastOverIDL","PolygonGeometry_ellipsoidGeodesic","EllipsoidGeodesic","PolygonGeometry_computeRectangle","arcType","ArcType","RHUMB","swap","inverseChordLength","chordLength","maximumRadius","positionsLength","endCartographic","startCartographic","setEndPoints","interpolateAndGrowRectangle","interpolatedCartographicScratch","ellipsoidGeodesic","idlCross","segmentLength","surfaceDistance","subsegmentDistance","interpolationDistance","interpolatedCartographic","interpolateUsingSurfaceDistance","lonAdjusted","createGeometryFromPositionsExtrudedPositions","createGeometryFromPositionsExtruded","closeTop","closeBottom","geos","walls","numPositions","topGeo","edgePoints","topBottomPositions","concat","ilength","topAndBottom","projectPointsOntoPlane","windingOrder","computeWindingOrder2D","WindingOrder","CLOCKWISE","slice","reverse","computeWallGeometry","hole","COUNTER_CLOCKWISE","PolygonGeometry","perPositionHeightExtrude","_closeTop","_closeBottom","_perPositionHeight","_perPositionHeightExtrude","_arcType","GEODESIC","PolygonGeometry_scratchEllipsoid","PolygonGeometry_scratchVertexFormat","dummyOptions","splitGeometry","scaleToGeodeticHeightExtruded","PolygonGeometry_textureCoordinateRotationPoints","Core_PolygonGeometry","createGeometryFromPositionsPositions","createGeometryFromPositionsSubdivided","PolygonOutlineGeometry_createGeometryFromPositions","minDistance","subdividedPositions","subdivideLineCount","subdivideRhumbLineCount","tempPositions","subdivideLine","subdivideRhumbLine","tempPositionsLength","indicesSize","PolygonOutlineGeometry_createGeometryFromPositionsExtruded","cornersLength","PolygonOutlineGeometry","PolygonOutlineGeometry_scratchEllipsoid","PolygonOutlineGeometry_dummyOptions","Core_PolygonOutlineGeometry","PolygonGeometryUpdater_scratchColor","PolygonGeometryUpdater_defaultOffset","PolygonGeometryUpdater_offsetScratch","PolygonGeometryUpdater_scratchRectangle","scratch2DPositions","cart2Scratch","PolygonGeometryOptions","PolygonGeometryUpdater","DyanmicPolygonGeometryUpdater","area","centroid2D","f","sum","projectPointOntoEllipsoid","perPositionHeightProperty","perPositionHeightEnabled","hierarchyValue","perPositionHeightValue","isExtruded","DataSources_PolygonGeometryUpdater","PolylineVolumeGeometry","polylinePositions","_shape","numComponents","PolylineVolumeGeometry_scratchEllipsoid","PolylineVolumeGeometry_scratchVertexFormat","PolylineVolumeGeometry_scratchOptions","brScratch","polylineVolumeGeometry","ll","ul","ur","lr","shapeLength","vertexCount","firstEndIndices","indicesCount","lengthSt","heightSt","stindex","endOffset","computeTangentAndBitangent","e","PolylineVolumeGeometry_computeAttributes","Core_PolylineVolumeGeometry","PolylineVolumeOutlineGeometry","PolylineVolumeOutlineGeometry_scratchEllipsoid","PolylineVolumeOutlineGeometry_scratchOptions","PolylineVolumeOutlineGeometry_brScratch","polylineVolumeOutlineGeometry","shapeCount","firstOffset","secondOffset","PolylineVolumeOutlineGeometry_computeAttributes","Core_PolylineVolumeOutlineGeometry","PolylineVolumeGeometryUpdater_scratchColor","PolylineVolumeGeometryOptions","PolylineVolumeGeometryUpdater","polylineVolume","DynamicPolylineVolumeGeometryUpdater","DataSources_PolylineVolumeGeometryUpdater","RectangleGeometry_positionScratch","RectangleGeometry_normalScratch","RectangleGeometry_tangentScratch","RectangleGeometry_bitangentScratch","rectangleScratch","RectangleGeometry_stScratch","RectangleGeometry_bottomBoundingSphere","RectangleGeometry_topBoundingSphere","createAttributes","v1Scratch","v2Scratch","constructRectangle","rectangleGeometry","computedOptions","northCap","southCap","rowStart","rowEnd","rowHeight","minX","minY","maxX","maxY","row","col","RectangleGeometryLibrary","computePosition","calculateAttributes","upperLeft","lowerLeft","lowerRight","upperRight","northIndex","southIndex","RectangleGeometry_addWallPositions","topPositions","bottomPositions","addWallTextureCoordinates","wallTextures","RectangleGeometry_scratchVertexFormat","constructExtrudedRectangle","offsetAttributeValue","_surfaceHeight","newVertexFormat","newLength","textures","hasOffsets","widthMultiplier","perimeterPositions","dupliateCorners","wallCount","wallExtrudeNormals","wallOffsetAttribute","computeTopOffsets","threeI","extrudeNormalIndex","wallOffsetIndex","calculateAttributesWall","scratchRectanglePoints","nwScratch","stNwScratch","RectangleGeometry_computeRectangle","computeOptions","RectangleGeometry","_rotatedRectangle","RectangleGeometry_scratchRectangle","RectangleGeometry_scratchEllipsoid","RectangleGeometry_scratchOptions","surfaceHeight","tangentRotationMatrixScratch","RectangleGeometry_quaternionScratch","RectangleGeometry_centerScratch","axis","geodeticSurfaceNormalCartographic","lonScalar","latScalar","topBS","fromRectangle3D","bottomBS","unrotatedTextureRectangleScratch","points2DScratch","rotation2DScratch","Matrix2","rectangleCenterScratch","unrotatedTextureRectangle","points2D","toDesiredInComputed","fromRotation","boundingRectangleCenter","point2D","minXYCorner","maxYCorner","maxXCorner","RectangleGeometry_textureCoordinateRotationPoints","Core_RectangleGeometry","RectangleGeometryUpdater_scratchColor","RectangleGeometryUpdater_defaultOffset","RectangleGeometryUpdater_offsetScratch","RectangleGeometryUpdater_scratchRectangle","scratchCenterRect","RectangleGeometryUpdater_scratchCarto","RectangleGeometryOptions","RectangleGeometryUpdater","DynamicRectangleGeometryUpdater","RectangleOutlineGeometry","rect","coordinates","toCartesian","DataSources_RectangleGeometryUpdater","StaticGeometryColorBatch_colorScratch","StaticGeometryColorBatch_distanceDisplayConditionScratch","StaticGeometryColorBatch_defaultDistanceDisplayCondition","StaticGeometryColorBatch_defaultOffset","StaticGeometryColorBatch_offsetScratch","Batch","appearanceType","depthFailAppearanceType","depthFailMaterialProperty","removeMaterialSubscription","depthFailMaterial","createPrimitive","waitingOnCreate","oldPrimitive","updaters","updatersWithAttributes","subscriptions","showsUpdated","itemsToRemove","invalidated","onMaterialChanged","StaticGeometryColorBatch","_solidItems","_translucentItems","_appearanceType","_depthFailAppearanceType","_shadows","removeItem","moveItems","batch","itemsMoved","itemsToMoveLength","updateItems","isUpdated","updatersLength","isMaterial","updaterMaterial","instance","unsubscribe","removedCount","depthFailAppearance","colorProperty","resultColor","_lastColor","depthFailColorProperty","depthColor","_lastDepthFailColor","depthFailColor","offsetProperty","updateShows","solidsMoved","translucentsMoved","DataSources_StaticGeometryColorBatch","StaticGeometryPerMaterialBatch_distanceDisplayConditionScratch","StaticGeometryPerMaterialBatch_defaultDistanceDisplayCondition","StaticGeometryPerMaterialBatch_defaultOffset","StaticGeometryPerMaterialBatch_offsetScratch","StaticGeometryPerMaterialBatch_Batch","updaterDepthFailMaterial","StaticGeometryPerMaterialBatch_colorScratch","StaticGeometryPerMaterialBatch","DataSources_StaticGeometryPerMaterialBatch","StaticGroundGeometryColorBatch_colorScratch","StaticGroundGeometryColorBatch_distanceDisplayConditionScratch","StaticGroundGeometryColorBatch_defaultDistanceDisplayCondition","StaticGroundGeometryColorBatch_Batch","key","isDirty","scratchArray","StaticGroundGeometryColorBatch","_batches","_classificationType","fillColor","newColor","toBytes","bs","batches","batchKey","Uint32Array","buffer","batchesArray","count","batchCount","oldBatch","newBatch","batchesArrayCopy","batchesCopyCount","DataSources_StaticGroundGeometryColorBatch","quickselect_swap","arr","tmp","defaultCompare","b","ThirdParty_quickselect","right","compare","quickselectStep","log","exp","sd","newLeft","newRight","rbush","maxEntries","format","_maxEntries","_minEntries","_initFormat","clear","findItem","equalsFn","calcBBox","node","toBBox","distBBox","children","destNode","createNode","Infinity","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","intersects","multiSelect","mid","stack","pop","all","_all","search","bbox","childBBox","nodesToSearch","collides","load","insert","_build","_splitRoot","tmpNode","_insert","parent","goingUp","path","indexes","_condense","compareMinX","compareMinY","toJSON","fromJSON","apply","N","M","pow","right2","right3","N2","N1","_chooseSubtree","level","targetNode","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","compareArr","Function","ThirdParty_rbush","RectangleCollisionChecker","_tree","RectangleWithId","idCompare","fromRectangleAndId","withId","removalScratch","collisionScratch","Core_RectangleCollisionChecker","StaticGroundGeometryPerMaterialBatch_distanceDisplayConditionScratch","StaticGroundGeometryPerMaterialBatch_defaultDistanceDisplayCondition","StaticGroundGeometryPerMaterialBatch_Batch","usingSphericalTextureCoordinates","rectangleCollisionCheck","StaticGroundGeometryPerMaterialBatch","overlapping","ShadowVolumeAppearance","shouldUseSphericalCoordinates","DataSources_StaticGroundGeometryPerMaterialBatch","StaticOutlineGeometryBatch_colorScratch","StaticOutlineGeometryBatch_distanceDisplayConditionScratch","StaticOutlineGeometryBatch_defaultDistanceDisplayCondition","StaticOutlineGeometryBatch_defaultOffset","StaticOutlineGeometryBatch_offsetScratch","StaticOutlineGeometryBatch_Batch","StaticOutlineGeometryBatch","_solidBatches","_translucentBatches","solidBatches","solidBatchesLength","translucentBatches","translucentBatchesLength","needUpdate","solidsToMoveLength","translucentToMoveLength","solidBatch","translucentBatch","DataSources_StaticOutlineGeometryBatch","WallGeometryLibrary","latLonEquals","c0","c1","EPSILON14","scratchCartographic1","scratchCartographic2","positionsArrayScratch","heightsArrayScratch","generateArcOptionsScratch","maximumHeights","minimumHeights","duplicateCorners","o","topHeights","bottomHeights","hasBottomHeights","hasTopHeights","hasAllZeroHeights","cleanedTopHeights","cleanedBottomHeights","removeDuplicates","numCorners","generateArcOptions","numberOfPoints","generateArcPositions","generateArcHeights","Core_WallGeometryLibrary","scratchCartesian3Position1","scratchCartesian3Position2","scratchCartesian3Position3","scratchCartesian3Position4","scratchCartesian3Position5","WallGeometry_scratchBitangent","WallGeometry_scratchTangent","WallGeometry_scratchNormal","WallGeometry","_minimumHeights","_maximumHeights","WallGeometry_scratchEllipsoid","WallGeometry_scratchVertexFormat","WallGeometry_scratchOptions","fromConstantHeights","minHeights","maxHeights","minimumHeight","maximumHeight","doMin","doMax","wallGeometry","ds","i3","nextTop","groundPosition","scalednextPosition","scaledGroundPosition","edgeIndex","pl","pr","Core_WallGeometry","WallOutlineGeometry_scratchCartesian3Position1","WallOutlineGeometry_scratchCartesian3Position2","WallOutlineGeometry","WallOutlineGeometry_scratchEllipsoid","WallOutlineGeometry_scratchOptions","Core_WallOutlineGeometry","WallGeometryUpdater_scratchColor","WallGeometryOptions","WallGeometryUpdater","DynamicWallGeometryUpdater","emptyArray","geometryUpdaters","GeometryUpdaterSet","EventHelper","_removeEntitySubscription","GeometryVisualizer","_groundPrimitives","_addedObjects","_removedObjects","_changedObjects","numberOfShadowModes","NUMBER_OF_SHADOW_MODES","_outlineBatches","_closedColorBatches","_closedMaterialBatches","_openColorBatches","_openMaterialBatches","numberOfClassificationTypes","NUMBER_OF_CLASSIFICATION_TYPES","groundColorBatches","groundMaterialBatches","_groundColorBatches","_groundMaterialBatches","_dynamicBatch","_subscriptions","_updaterSets","forEach","updaterSet","addedObjects","removedObjects","changedObjects","_removeUpdater","_insertUpdaterIntoBatch","_onGeometryChanged","getBoundingSphereArrayScratch","getBoundingSphereBoundingSphereScratch","boundingSpheres","state","batchesLength","fromBoundingSpheres","updaterSets","DataSources_GeometryVisualizer","defaultStyle","LabelStyle","FILL","defaultFillColor","LabelVisualizer_defaultOutlineColor","defaultBackgroundColor","defaultBackgroundPadding","LabelVisualizer_defaultPixelOffset","LabelVisualizer_defaultEyeOffset","LabelVisualizer_defaultHeightReference","LabelVisualizer_defaultHorizontalOrigin","LabelVisualizer_defaultVerticalOrigin","LabelVisualizer_positionScratch","fillColorScratch","outlineColorScratch","backgroundColorScratch","backgroundPaddingScratch","LabelVisualizer_eyeOffsetScratch","LabelVisualizer_pixelOffsetScratch","LabelVisualizer_translucencyByDistanceScratch","LabelVisualizer_pixelOffsetScaleByDistanceScratch","LabelVisualizer_scaleByDistanceScratch","LabelVisualizer_distanceDisplayConditionScratch","LabelVisualizer_EntityData","label","LabelVisualizer","LabelVisualizer_returnPrimitive","removeLabel","text","labelGraphics","_label","_text","updateClamping","getLabel","font","_font","style","_style","_fillColor","_outlineColor","showBackground","_showBackground","backgroundColor","_backgroundColor","backgroundPadding","_backgroundPadding","DataSources_LabelVisualizer","ModelVisualizer_defaultShadows","ENABLED","ModelVisualizer_defaultHeightReference","defaultSilhouetteColor","RED","ModelVisualizer_defaultColor","defaultColorBlendMode","ColorBlendMode","HIGHLIGHT","defaultImageBasedLightingFactor","defaultUpAxis","Axis","Y","modelMatrixScratch","nodeMatrixScratch","ModelVisualizer","_modelHash","_entitiesToVisualize","removeModel","visualizer","modelHash","modelData","modelPrimitive","clearNodeTransformationsArticulationsScratch","nodeTransformationsScratch","articulationsScratch","checkModelLoad","model","readyPromise","otherwise","error","console","loadFail","resource","modelGraphics","_model","Resource","createIfNeeded","_uri","url","Model","fromGltf","incrementallyLoadTextures","_incrementallyLoadTextures","animationsRunning","minimumPixelSize","_minimumPixelSize","maximumScale","_maximumScale","silhouetteColor","_silhouetteColor","silhouetteSize","_silhouetteSize","colorBlendMode","_colorBlendMode","colorBlendAmount","_colorBlendAmount","clippingPlanes","_clippingPlanes","clampAnimations","_clampAnimations","imageBasedLightingFactor","_imageBasedLightingFactor","lightColor","_lightColor","_upAxis","_forwardAxis","runAnimations","_runAnimations","activeAnimations","addAll","loop","ModelAnimationLoop","REPEAT","nodeTransformations","_nodeTransformations","nodeNames","keys","nodeIndex","nodeLength","nodeName","nodeTransformation","modelNode","getNode","transformationMatrix","fromTranslationRotationScale","matrix","multiply","originalMatrix","anyArticulationUpdated","articulations","_articulations","articulationStageKeys","numKeys","articulationStageValue","setArticulationStage","applyArticulations","_clampedModelMatrix","_heightChanged","DataSources_ModelVisualizer","scratchTimeInterval","TimeInterval","subSampleCompositePropertyScratch","subSampleIntervalPropertyScratch","PathVisualizer_EntityData","polyline","reallySubSample","stop","updateTime","maximumStep","SampledPositionProperty","times","sampleStepsToTake","sampleStepsTaken","sampleStepSize","steppedOnNow","JulianDate","lessThanOrEquals","greaterThanOrEquals","current","loopStop","sampling","greaterThan","lessThan","secondsUntilNext","secondsDifference","addSeconds","subSampleSampledProperty","_property","_times","intersect","intervalStart","intervalStop","sampleStart","sampleStop","subSampleCompositeProperty","TimeIntervalCollectionPositionProperty","isStartIncluded","isStopIncluded","subSampleIntervalProperty","ConstantPositionProperty","subSampleConstantProperty","stepSize","subSampleGenericProperty","subSample","toFixedScratch","PolylineUpdater","_unusedIndexes","_polylineCollection","PolylineCollection","PathVisualizer","_updaters","ReferenceFrame","INERTIAL","toFixed","computeIcrfToFixedMatrix","computeTemeToPseudoFixedMatrix","updateObject","pathGraphics","_path","showProperty","leadTime","_leadTime","trailTime","_trailTime","_availability","hasAvailability","hasLeadTime","hasTrailTime","unusedIndexes","resolution","_resolution","removeObject","hasOwnProperty","u","lastUpdater","frameToVisualize","currentUpdater","_subSample","DataSources_PathVisualizer","PointVisualizer_defaultColor","PointVisualizer_defaultOutlineColor","PointVisualizer_colorScratch","PointVisualizer_positionScratch","PointVisualizer_outlineColorScratch","PointVisualizer_scaleByDistanceScratch","PointVisualizer_translucencyByDistanceScratch","PointVisualizer_distanceDisplayConditionScratch","PointVisualizer_EntityData","pointPrimitive","pixelSize","PointVisualizer","PointVisualizer_returnPrimitive","removePoint","pointGraphics","_point","needsRedraw","getPoint","_pixelSize","newOutlineColor","newOutlineWidth","newPixelSize","centerAlpha","alpha","cssColor","toCssColorString","cssOutlineColor","textureId","JSON","stringify","setImage","createBillboardPointCallback","DataSources_PointVisualizer","scratchInterpolateColorsArray","interpolateColors","color0","color1","colors","r0","red","g0","green","b0","blue","a0","r1","g1","b1","a1","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","PolylineGeometry","colorsPerVertex","_colors","_colorsPerVertex","PolylineGeometry_scratchEllipsoid","PolylineGeometry_scratchVertexFormat","PolylineGeometry_scratchOptions","PolylineGeometry_scratchCartesian3","PolylineGeometry_scratchPosition","scratchPrevPosition","scratchNextPosition","polylineGeometry","subdivisionSize","numberOfPointsFunction","numberOfPointsRhumbLine","extractHeights","colorLength","newColors","newColorIndex","numColors","interpolatedColors","interpolatedColorsLength","generateCartesianArc","generateCartesianRhumbArc","prevPositions","nextPositions","expandAndWidth","finalColors","expandAndWidthIndex","colorIndex","endK","floatToByte","prevPosition","geometryType","GeometryType","POLYLINES","Core_PolylineGeometry","PolylineGeometryUpdater_defaultZIndex","polylineCollections","PolylineGeometryUpdater_scratchColor","PolylineGeometryUpdater_defaultMaterial","PolylineGeometryUpdater_defaultShow","PolylineGeometryUpdater_defaultShadows","PolylineGeometryUpdater_defaultDistanceDisplayCondition","PolylineGeometryUpdater_defaultClassificationType","GeometryOptions","GroundGeometryOptions","PolylineGeometryUpdater","_entitySubscription","_depthFailMaterialProperty","_geometryOptions","_groundGeometryOptions","_clampToGround","_supportsPolylinesOnTerrain","supportsPolylinesOnTerrain","clampToGround","GroundPolylineGeometry","positionsProperty","PolylineColorAppearance","PolylineMaterialAppearance","groundGeometryOptions","PolylineGeometryUpdater_DynamicGeometryUpdater","generateCartesianArcOptions","_line","_groundPolylinePrimitive","getLine","dynamicGeometryUpdater","sceneId","polylineCollection","line","GroundPolylinePrimitive","groundPolylinePrimitive","DataSources_PolylineGeometryUpdater","StaticGroundPolylinePerMaterialBatch_scratchColor","StaticGroundPolylinePerMaterialBatch_distanceDisplayConditionScratch","StaticGroundPolylinePerMaterialBatch_defaultDistanceDisplayCondition","StaticGroundPolylinePerMaterialBatch_Batch","_asynchronous","StaticGroundPolylinePerMaterialBatch","DataSources_StaticGroundPolylinePerMaterialBatch","PolylineVisualizer_emptyArray","removeUpdater","insertUpdaterIntoBatch","_groundBatches","multiplier","_colorBatches","_materialBatches","PolylineVisualizer","PolylineVisualizer_getBoundingSphereArrayScratch","PolylineVisualizer_getBoundingSphereBoundingSphereScratch","DataSources_PolylineVisualizer","DataSourceDisplay","_displayID","createGuid","initializeTerrainHeights","dataSourceCollection","dataSourceAdded","_onDataSourceAdded","dataSourceRemoved","_onDataSourceRemoved","dataSourceMoved","_onDataSourceMoved","postRender","_postRender","_dataSourceCollection","_visualizersCallback","visualizersCallback","defaultVisualizersCallback","primitivesAdded","removeDefaultDataSourceListener","removeDataSourceCollectionListener","defaultDataSource","CustomDataSource","_defaultDataSource","addPrimitives","_removeDefaultDataSourceListener","_removeDataSourceCollectionListener","_ready","dataSource","dataSources","initialized","visualizers","vLength","_visualizersByDisplayID","credit","creditDisplay","addCredit","credits","_resourceCredits","creditCount","DataSourceDisplay_getBoundingSphereArrayScratch","DataSourceDisplay_getBoundingSphereBoundingSphereScratch","allowPartial","d","_visualizers","visualizersLength","displayPrimitives","displayGroundPrimitives","clustering","_initialize","newIndex","oldIndex","raise","lower","lowerToBottom","raiseToTop"],"mappings":"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","file":"1.TerriaJS-specs.js","sourcesContent":["import freezeObject from './freezeObject.js';\n\n    /**\n     * Style options for corners.\n     *\n     * @demo The {@link https://sandcastle.cesium.com/index.html?src=Corridor.html&label=Geometries|Corridor Demo}\n     * demonstrates the three corner types, as used by {@link CorridorGraphics}.\n     *\n     * @exports CornerType\n     */\n    var CornerType = {\n        /**\n         * <img src=\"Images/CornerTypeRounded.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n         *\n         * Corner has a smooth edge.\n         * @type {Number}\n         * @constant\n         */\n        ROUNDED : 0,\n\n        /**\n         * <img src=\"Images/CornerTypeMitered.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n         *\n         * Corner point is the intersection of adjacent edges.\n         * @type {Number}\n         * @constant\n         */\n        MITERED : 1,\n\n        /**\n         * <img src=\"Images/CornerTypeBeveled.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n         *\n         * Corner is clipped.\n         * @type {Number}\n         * @constant\n         */\n        BEVELED : 2\n    };\nexport default freezeObject(CornerType);\n","import defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Event from '../Core/Event.js';\nimport EventHelper from '../Core/EventHelper.js';\nimport TimeIntervalCollection from '../Core/TimeIntervalCollection.js';\nimport Property from './Property.js';\n\n    function subscribeAll(property, eventHelper, definitionChanged, intervals) {\n        function callback() {\n            definitionChanged.raiseEvent(property);\n        }\n        var items = [];\n        eventHelper.removeAll();\n        var length = intervals.length;\n        for (var i = 0; i < length; i++) {\n            var interval = intervals.get(i);\n            if (defined(interval.data) && items.indexOf(interval.data) === -1) {\n                eventHelper.add(interval.data.definitionChanged, callback);\n            }\n        }\n    }\n\n    /**\n     * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the\n     * data property of each {@link TimeInterval} is another Property instance which is\n     * evaluated at the provided time.\n     *\n     * @alias CompositeProperty\n     * @constructor\n     *\n     *\n     * @example\n     * var constantProperty = ...;\n     * var sampledProperty = ...;\n     *\n     * //Create a composite property from two previously defined properties\n     * //where the property is valid on August 1st, 2012 and uses a constant\n     * //property for the first half of the day and a sampled property for the\n     * //remaining half.\n     * var composite = new Cesium.CompositeProperty();\n     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n     *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T12:00:00.00Z',\n     *     data : constantProperty\n     * }));\n     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n     *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-02T00:00:00.00Z',\n     *     isStartIncluded : false,\n     *     isStopIncluded : false,\n     *     data : sampledProperty\n     * }));\n     *\n     * @see CompositeMaterialProperty\n     * @see CompositePositionProperty\n     */\n    function CompositeProperty() {\n        this._eventHelper = new EventHelper();\n        this._definitionChanged = new Event();\n        this._intervals = new TimeIntervalCollection();\n        this._intervals.changedEvent.addEventListener(CompositeProperty.prototype._intervalsChanged, this);\n    }\n\n    defineProperties(CompositeProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof CompositeProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return this._intervals.isEmpty;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever setValue is called with data different\n         * than the current value.\n         * @memberof CompositeProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the interval collection.\n         * @memberof CompositeProperty.prototype\n         *\n         * @type {TimeIntervalCollection}\n         */\n        intervals : {\n            get : function() {\n                return this._intervals;\n            }\n        }\n    });\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CompositeProperty.prototype.getValue = function(time, result) {\n        \n\n        var innerProperty = this._intervals.findDataForIntervalContainingDate(time);\n        if (defined(innerProperty)) {\n            return innerProperty.getValue(time, result);\n        }\n        return undefined;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    CompositeProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof CompositeProperty && //\n                this._intervals.equals(other._intervals, Property.equals));\n    };\n\n    /**\n     * @private\n     */\n    CompositeProperty.prototype._intervalsChanged = function() {\n        subscribeAll(this, this._eventHelper, this._definitionChanged, this._intervals);\n        this._definitionChanged.raiseEvent(this);\n    };\nexport default CompositeProperty;\n","import defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Event from '../Core/Event.js';\nimport ReferenceFrame from '../Core/ReferenceFrame.js';\nimport CompositeProperty from './CompositeProperty.js';\nimport Property from './Property.js';\n\n    /**\n     * A {@link CompositeProperty} which is also a {@link PositionProperty}.\n     *\n     * @alias CompositePositionProperty\n     * @constructor\n     *\n     * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.\n     */\n    function CompositePositionProperty(referenceFrame) {\n        this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);\n        this._definitionChanged = new Event();\n        this._composite = new CompositeProperty();\n        this._composite.definitionChanged.addEventListener(CompositePositionProperty.prototype._raiseDefinitionChanged, this);\n    }\n\n    defineProperties(CompositePositionProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return this._composite.isConstant;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever setValue is called with data different\n         * than the current value.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the interval collection.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {TimeIntervalCollection}\n         */\n        intervals : {\n            get : function() {\n                return this._composite.intervals;\n            }\n        },\n        /**\n         * Gets or sets the reference frame which this position presents itself as.\n         * Each PositionProperty making up this object has it's own reference frame,\n         * so this property merely exposes a \"preferred\" reference frame for clients\n         * to use.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {ReferenceFrame}\n         */\n        referenceFrame : {\n            get : function() {\n                return this._referenceFrame;\n            },\n            set : function(value) {\n                this._referenceFrame = value;\n            }\n        }\n    });\n\n    /**\n     * Gets the value of the property at the provided time in the fixed frame.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CompositePositionProperty.prototype.getValue = function(time, result) {\n        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);\n    };\n\n    /**\n     * Gets the value of the property at the provided time and in the provided reference frame.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.\n     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CompositePositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {\n        \n\n        var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);\n        if (defined(innerProperty)) {\n            return innerProperty.getValueInReferenceFrame(time, referenceFrame, result);\n        }\n        return undefined;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    CompositePositionProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof CompositePositionProperty && //\n                this._referenceFrame === other._referenceFrame && //\n                this._composite.equals(other._composite, Property.equals));\n    };\n\n    /**\n     * @private\n     */\n    CompositePositionProperty.prototype._raiseDefinitionChanged = function() {\n        this._definitionChanged.raiseEvent(this);\n    };\nexport default CompositePositionProperty;\n","import defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Event from '../Core/Event.js';\nimport RuntimeError from '../Core/RuntimeError.js';\nimport Property from './Property.js';\n\n    function resolveEntity(that) {\n        var entityIsResolved = true;\n        if (that._resolveEntity) {\n            var targetEntity = that._targetCollection.getById(that._targetId);\n\n            if (defined(targetEntity)) {\n                targetEntity.definitionChanged.addEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, that);\n                that._targetEntity = targetEntity;\n                that._resolveEntity = false;\n            } else {\n                //The property has become detached.  It has a valid value but is not currently resolved to an entity in the collection\n                targetEntity = that._targetEntity;\n                entityIsResolved = false;\n            }\n\n            if (!defined(targetEntity)) {\n                throw new RuntimeError('target entity \"' + that._targetId + '\" could not be resolved.');\n            }\n        }\n        return entityIsResolved;\n    }\n\n    function resolve(that) {\n        var targetProperty = that._targetProperty;\n\n        if (that._resolveProperty) {\n            var entityIsResolved = resolveEntity(that);\n\n            var names = that._targetPropertyNames;\n            targetProperty = that._targetEntity;\n            var length = names.length;\n            for (var i = 0; i < length && defined(targetProperty); i++) {\n                targetProperty = targetProperty[names[i]];\n            }\n\n            if (defined(targetProperty)) {\n                that._targetProperty = targetProperty;\n                that._resolveProperty = !entityIsResolved;\n            } else if (!defined(that._targetProperty)) {\n                throw new RuntimeError('targetProperty \"' + that._targetId + '.' + names.join('.') + '\" could not be resolved.');\n            }\n        }\n\n        return targetProperty;\n    }\n\n    /**\n     * A {@link Property} which transparently links to another property on a provided object.\n     *\n     * @alias ReferenceProperty\n     * @constructor\n     *\n     * @param {EntityCollection} targetCollection The entity collection which will be used to resolve the reference.\n     * @param {String} targetId The id of the entity which is being referenced.\n     * @param {String[]} targetPropertyNames The names of the property on the target entity which we will use.\n     *\n     * @example\n     * var collection = new Cesium.EntityCollection();\n     *\n     * //Create a new entity and assign a billboard scale.\n     * var object1 = new Cesium.Entity({id:'object1'});\n     * object1.billboard = new Cesium.BillboardGraphics();\n     * object1.billboard.scale = new Cesium.ConstantProperty(2.0);\n     * collection.add(object1);\n     *\n     * //Create a second entity and reference the scale from the first one.\n     * var object2 = new Cesium.Entity({id:'object2'});\n     * object2.model = new Cesium.ModelGraphics();\n     * object2.model.scale = new Cesium.ReferenceProperty(collection, 'object1', ['billboard', 'scale']);\n     * collection.add(object2);\n     *\n     * //Create a third object, but use the fromString helper function.\n     * var object3 = new Cesium.Entity({id:'object3'});\n     * object3.billboard = new Cesium.BillboardGraphics();\n     * object3.billboard.scale = Cesium.ReferenceProperty.fromString(collection, 'object1#billboard.scale');\n     * collection.add(object3);\n     *\n     * //You can refer to an entity with a # or . in id and property names by escaping them.\n     * var object4 = new Cesium.Entity({id:'#object.4'});\n     * object4.billboard = new Cesium.BillboardGraphics();\n     * object4.billboard.scale = new Cesium.ConstantProperty(2.0);\n     * collection.add(object4);\n     *\n     * var object5 = new Cesium.Entity({id:'object5'});\n     * object5.billboard = new Cesium.BillboardGraphics();\n     * object5.billboard.scale = Cesium.ReferenceProperty.fromString(collection, '\\\\#object\\\\.4#billboard.scale');\n     * collection.add(object5);\n     */\n    function ReferenceProperty(targetCollection, targetId, targetPropertyNames) {\n        \n\n        this._targetCollection = targetCollection;\n        this._targetId = targetId;\n        this._targetPropertyNames = targetPropertyNames;\n        this._targetProperty = undefined;\n        this._targetEntity = undefined;\n        this._definitionChanged = new Event();\n        this._resolveEntity = true;\n        this._resolveProperty = true;\n\n        targetCollection.collectionChanged.addEventListener(ReferenceProperty.prototype._onCollectionChanged, this);\n    }\n\n    defineProperties(ReferenceProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.\n         * @memberof ReferenceProperty.prototype\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return Property.isConstant(resolve(this));\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever the referenced property's definition is changed.\n         * @memberof ReferenceProperty.prototype\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the reference frame that the position is defined in.\n         * This property is only valid if the referenced property is a {@link PositionProperty}.\n         * @memberof ReferenceProperty.prototype\n         * @type {ReferenceFrame}\n         * @readonly\n         */\n        referenceFrame : {\n            get : function() {\n                return resolve(this).referenceFrame;\n            }\n        },\n        /**\n         * Gets the id of the entity being referenced.\n         * @memberof ReferenceProperty.prototype\n         * @type {String}\n         * @readonly\n         */\n        targetId : {\n            get : function() {\n                return this._targetId;\n            }\n        },\n        /**\n         * Gets the collection containing the entity being referenced.\n         * @memberof ReferenceProperty.prototype\n         * @type {EntityCollection}\n         * @readonly\n         */\n        targetCollection : {\n            get : function() {\n                return this._targetCollection;\n            }\n        },\n        /**\n         * Gets the array of property names used to retrieve the referenced property.\n         * @memberof ReferenceProperty.prototype\n         * @type {String[]}\n         * @readonly\n         */\n        targetPropertyNames : {\n            get : function() {\n                return this._targetPropertyNames;\n            }\n        },\n        /**\n         * Gets the resolved instance of the underlying referenced property.\n         * @memberof ReferenceProperty.prototype\n         * @type {Property}\n         * @readonly\n         */\n        resolvedProperty : {\n            get : function() {\n                return resolve(this);\n            }\n        }\n    });\n\n    /**\n     * Creates a new instance given the entity collection that will\n     * be used to resolve it and a string indicating the target entity id and property.\n     * The format of the string is \"objectId#foo.bar\", where # separates the id from\n     * property path and . separates sub-properties.  If the reference identifier or\n     * or any sub-properties contains a # . or \\ they must be escaped.\n     *\n     * @param {EntityCollection} targetCollection\n     * @param {String} referenceString\n     * @returns {ReferenceProperty} A new instance of ReferenceProperty.\n     *\n     * @exception {DeveloperError} invalid referenceString.\n     */\n    ReferenceProperty.fromString = function(targetCollection, referenceString) {\n        \n\n        var identifier;\n        var values = [];\n\n        var inIdentifier = true;\n        var isEscaped = false;\n        var token = '';\n        for (var i = 0; i < referenceString.length; ++i) {\n            var c = referenceString.charAt(i);\n\n            if (isEscaped) {\n                token += c;\n                isEscaped = false;\n            } else if (c === '\\\\') {\n                isEscaped = true;\n            } else if (inIdentifier && c === '#') {\n                identifier = token;\n                inIdentifier = false;\n                token = '';\n            } else if (!inIdentifier && c === '.') {\n                values.push(token);\n                token = '';\n            } else {\n                token += c;\n            }\n        }\n        values.push(token);\n\n        return new ReferenceProperty(targetCollection, identifier, values);\n    };\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    ReferenceProperty.prototype.getValue = function(time, result) {\n        return resolve(this).getValue(time, result);\n    };\n\n    /**\n     * Gets the value of the property at the provided time and in the provided reference frame.\n     * This method is only valid if the property being referenced is a {@link PositionProperty}.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.\n     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    ReferenceProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {\n        return resolve(this).getValueInReferenceFrame(time, referenceFrame, result);\n    };\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     * This method is only valid if the property being referenced is a {@link MaterialProperty}.\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    ReferenceProperty.prototype.getType = function(time) {\n        return resolve(this).getType(time);\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    ReferenceProperty.prototype.equals = function(other) {\n        if (this === other) {\n            return true;\n        }\n\n        var names = this._targetPropertyNames;\n        var otherNames = other._targetPropertyNames;\n\n        if (this._targetCollection !== other._targetCollection || //\n            this._targetId !== other._targetId || //\n            names.length !== otherNames.length) {\n            return false;\n        }\n\n        var length = this._targetPropertyNames.length;\n        for (var i = 0; i < length; i++) {\n            if (names[i] !== otherNames[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    };\n\n    ReferenceProperty.prototype._onTargetEntityDefinitionChanged = function(targetEntity, name, value, oldValue) {\n        if (this._targetPropertyNames[0] === name) {\n            this._resolveProperty = true;\n            this._definitionChanged.raiseEvent(this);\n        }\n    };\n\n    ReferenceProperty.prototype._onCollectionChanged = function(collection, added, removed) {\n        var targetEntity = this._targetEntity;\n        if (defined(targetEntity)) {\n            if (removed.indexOf(targetEntity) !== -1) {\n                targetEntity.definitionChanged.removeEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, this);\n                this._resolveEntity = true;\n                this._resolveProperty = true;\n            } else if (this._resolveEntity) {\n                //If targetEntity is defined but resolveEntity is true, then the entity is detached\n                //and any change to the collection needs to incur an attempt to resolve in order to re-attach.\n                //without this if block, a reference that becomes re-attached will not signal definitionChanged\n                resolve(this);\n                if (!this._resolveEntity) {\n                    this._definitionChanged.raiseEvent(this);\n                }\n            }\n        }\n    };\nexport default ReferenceProperty;\n","import defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Ellipsoid from '../Core/Ellipsoid.js';\nimport Event from '../Core/Event.js';\nimport ReferenceFrame from '../Core/ReferenceFrame.js';\nimport Property from './Property.js';\n\n    /**\n     * This is a temporary class for scaling position properties to the WGS84 surface.\n     * It will go away or be refactored to support data with arbitrary height references.\n     * @private\n     */\n    function ScaledPositionProperty(value) {\n        this._definitionChanged = new Event();\n        this._value = undefined;\n        this._removeSubscription = undefined;\n        this.setValue(value);\n    }\n\n    defineProperties(ScaledPositionProperty.prototype, {\n        isConstant : {\n            get : function() {\n                return Property.isConstant(this._value);\n            }\n        },\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        referenceFrame : {\n            get : function() {\n                return defined(this._value) ? this._value.referenceFrame : ReferenceFrame.FIXED;\n            }\n        }\n    });\n\n    ScaledPositionProperty.prototype.getValue = function(time, result) {\n        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);\n    };\n\n    ScaledPositionProperty.prototype.setValue = function(value) {\n        if (this._value !== value) {\n            this._value = value;\n\n            if (defined(this._removeSubscription)) {\n                this._removeSubscription();\n                this._removeSubscription = undefined;\n            }\n\n            if (defined(value)) {\n                this._removeSubscription = value.definitionChanged.addEventListener(this._raiseDefinitionChanged, this);\n            }\n            this._definitionChanged.raiseEvent(this);\n        }\n    };\n\n    ScaledPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {\n        \n\n        if (!defined(this._value)) {\n            return undefined;\n        }\n\n        result = this._value.getValueInReferenceFrame(time, referenceFrame, result);\n        return defined(result) ? Ellipsoid.WGS84.scaleToGeodeticSurface(result, result) : undefined;\n    };\n\n    ScaledPositionProperty.prototype.equals = function(other) {\n        return this === other || (other instanceof ScaledPositionProperty && this._value === other._value);\n    };\n\n    ScaledPositionProperty.prototype._raiseDefinitionChanged = function() {\n        this._definitionChanged.raiseEvent(this);\n    };\nexport default ScaledPositionProperty;\n","import Check from '../Core/Check.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport PrimitiveCollection from './PrimitiveCollection.js';\n\n    /**\n     * A primitive collection for helping maintain the order or ground primitives based on a z-index\n     *\n     * @private\n     */\n    function OrderedGroundPrimitiveCollection() {\n        this._length = 0;\n        this._collections = {};\n        this._collectionsArray = [];\n\n        this.show = true;\n    }\n\n    defineProperties(OrderedGroundPrimitiveCollection.prototype, {\n        /**\n         * Gets the number of primitives in the collection.\n         *\n         * @memberof OrderedGroundPrimitiveCollection.prototype\n         *\n         * @type {Number}\n         * @readonly\n         */\n        length : {\n            get : function() {\n                return this._length;\n            }\n        }\n    });\n\n    /**\n     * Adds a primitive to the collection.\n     *\n     * @param {GroundPrimitive} primitive The primitive to add.\n     * @param {Number} [zIndex = 0] The index of the primitive\n     * @returns {GroundPrimitive} The primitive added to the collection.\n     */\n    OrderedGroundPrimitiveCollection.prototype.add = function(primitive, zIndex) {\n        \n\n        zIndex = defaultValue(zIndex, 0);\n        var collection = this._collections[zIndex];\n        if (!defined(collection)) {\n            collection = new PrimitiveCollection({ destroyPrimitives: false });\n            collection._zIndex = zIndex;\n            this._collections[zIndex] = collection;\n            var array = this._collectionsArray;\n            var i = 0;\n            while (i < array.length && array[i]._zIndex < zIndex) {\n                i++;\n            }\n            array.splice(i, 0, collection);\n        }\n\n        collection.add(primitive);\n        this._length++;\n        primitive._zIndex = zIndex;\n\n        return primitive;\n    };\n\n    /**\n     * Adjusts the z-index\n     * @param {GroundPrimitive} primitive\n     * @param {Number} zIndex\n     */\n    OrderedGroundPrimitiveCollection.prototype.set = function(primitive, zIndex) {\n        \n\n        if (zIndex === primitive._zIndex) {\n            return primitive;\n        }\n\n        this.remove(primitive, true);\n        this.add(primitive, zIndex);\n\n        return primitive;\n    };\n\n    /**\n     * Removes a primitive from the collection.\n     *\n     * @param {Object} primitive The primitive to remove.\n     * @param {Boolean} [doNotDestroy = false]\n     * @returns {Boolean} <code>true</code> if the primitive was removed; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.\n     */\n    OrderedGroundPrimitiveCollection.prototype.remove = function(primitive, doNotDestroy) {\n        if (this.contains(primitive)) {\n            var index = primitive._zIndex;\n            var collection = this._collections[index];\n            var result;\n            if (doNotDestroy) {\n                result = collection.remove(primitive);\n            } else {\n                result = collection.removeAndDestroy(primitive);\n            }\n\n            if (result) {\n                this._length--;\n            }\n\n            if (collection.length === 0) {\n                this._collectionsArray.splice(this._collectionsArray.indexOf(collection), 1);\n                this._collections[index] = undefined;\n                collection.destroy();\n            }\n\n            return result;\n        }\n\n        return false;\n    };\n\n    /**\n     * Removes all primitives in the collection.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     * @see OrderedGroundPrimitiveCollection#destroyPrimitives\n     */\n    OrderedGroundPrimitiveCollection.prototype.removeAll = function() {\n        var collections = this._collectionsArray;\n        for (var i = 0; i < collections.length; i++) {\n            var collection = collections[i];\n            collection.destroyPrimitives = true;\n            collection.destroy();\n        }\n\n        this._collections = {};\n        this._collectionsArray = [];\n        this._length = 0;\n    };\n\n    /**\n     * Determines if this collection contains a primitive.\n     *\n     * @param {Object} primitive The primitive to check for.\n     * @returns {Boolean} <code>true</code> if the primitive is in the collection; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.\n     */\n    OrderedGroundPrimitiveCollection.prototype.contains = function(primitive) {\n        if (!defined(primitive)) {\n            return false;\n        }\n        var collection = this._collections[primitive._zIndex];\n        return defined(collection) && collection.contains(primitive);\n    };\n\n    /**\n     * @private\n     */\n    OrderedGroundPrimitiveCollection.prototype.update = function(frameState) {\n        if (!this.show) {\n            return;\n        }\n\n        var collections = this._collectionsArray;\n        for (var i = 0 ; i < collections.length; i++) {\n            collections[i].update(frameState);\n        }\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * <br /><br />\n     * If this object was destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     *\n     * @see OrderedGroundPrimitiveCollection#destroy\n     */\n    OrderedGroundPrimitiveCollection.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this\n     * collection allows for deterministic release of WebGL resources, instead of relying on the garbage\n     * collector to destroy this collection.\n     * <br /><br />\n     * Since destroying a collection destroys all the contained primitives, only destroy a collection\n     * when you are sure no other code is still using any of the contained primitives.\n     * <br /><br />\n     * Once this collection is destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n     * assign the return value (<code>undefined</code>) to the object as done in the example.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * primitives = primitives && primitives.destroy();\n     *\n     * @see OrderedGroundPrimitiveCollection#isDestroyed\n     */\n    OrderedGroundPrimitiveCollection.prototype.destroy = function() {\n        this.removeAll();\n        return destroyObject(this);\n    };\nexport default OrderedGroundPrimitiveCollection;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport BoundingRectangle from '../Core/BoundingRectangle.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport NearFarScalar from '../Core/NearFarScalar.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport HorizontalOrigin from '../Scene/HorizontalOrigin.js';\nimport VerticalOrigin from '../Scene/VerticalOrigin.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var defaultColor = Color.WHITE;\n    var defaultEyeOffset = Cartesian3.ZERO;\n    var defaultHeightReference = HeightReference.NONE;\n    var defaultPixelOffset = Cartesian2.ZERO;\n    var defaultScale = 1.0;\n    var defaultRotation = 0.0;\n    var defaultAlignedAxis = Cartesian3.ZERO;\n    var defaultHorizontalOrigin = HorizontalOrigin.CENTER;\n    var defaultVerticalOrigin = VerticalOrigin.CENTER;\n    var defaultSizeInMeters = false;\n\n    var positionScratch = new Cartesian3();\n    var colorScratch = new Color();\n    var eyeOffsetScratch = new Cartesian3();\n    var pixelOffsetScratch = new Cartesian2();\n    var scaleByDistanceScratch = new NearFarScalar();\n    var translucencyByDistanceScratch = new NearFarScalar();\n    var pixelOffsetScaleByDistanceScratch = new NearFarScalar();\n    var boundingRectangleScratch = new BoundingRectangle();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.billboard = undefined;\n        this.textureValue = undefined;\n    }\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#billboard} to a {@link Billboard}.\n     * @alias BillboardVisualizer\n     * @constructor\n     *\n     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function BillboardVisualizer(entityCluster, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(BillboardVisualizer.prototype._onCollectionChanged, this);\n\n        this._cluster = entityCluster;\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    BillboardVisualizer.prototype.update = function(time) {\n        \n\n        var items = this._items.values;\n        var cluster = this._cluster;\n\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var billboardGraphics = entity._billboard;\n            var textureValue;\n            var billboard = item.billboard;\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(billboardGraphics._show, time, true);\n            var position;\n            if (show) {\n                position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n                textureValue = Property.getValueOrUndefined(billboardGraphics._image, time);\n                show = defined(position) && defined(textureValue);\n            }\n\n            if (!show) {\n                //don't bother creating or updating anything else\n                returnPrimitive(item, entity, cluster);\n                continue;\n            }\n\n            if (!Property.isConstant(entity._position)) {\n                cluster._clusterDirty = true;\n            }\n\n            if (!defined(billboard)) {\n                billboard = cluster.getBillboard(entity);\n                billboard.id = entity;\n                billboard.image = undefined;\n                item.billboard = billboard;\n            }\n\n            billboard.show = show;\n            if (!defined(billboard.image) || item.textureValue !== textureValue) {\n                billboard.image = textureValue;\n                item.textureValue = textureValue;\n            }\n            billboard.position = position;\n            billboard.color = Property.getValueOrDefault(billboardGraphics._color, time, defaultColor, colorScratch);\n            billboard.eyeOffset = Property.getValueOrDefault(billboardGraphics._eyeOffset, time, defaultEyeOffset, eyeOffsetScratch);\n            billboard.heightReference = Property.getValueOrDefault(billboardGraphics._heightReference, time, defaultHeightReference);\n            billboard.pixelOffset = Property.getValueOrDefault(billboardGraphics._pixelOffset, time, defaultPixelOffset, pixelOffsetScratch);\n            billboard.scale = Property.getValueOrDefault(billboardGraphics._scale, time, defaultScale);\n            billboard.rotation = Property.getValueOrDefault(billboardGraphics._rotation, time, defaultRotation);\n            billboard.alignedAxis = Property.getValueOrDefault(billboardGraphics._alignedAxis, time, defaultAlignedAxis);\n            billboard.horizontalOrigin = Property.getValueOrDefault(billboardGraphics._horizontalOrigin, time, defaultHorizontalOrigin);\n            billboard.verticalOrigin = Property.getValueOrDefault(billboardGraphics._verticalOrigin, time, defaultVerticalOrigin);\n            billboard.width = Property.getValueOrUndefined(billboardGraphics._width, time);\n            billboard.height = Property.getValueOrUndefined(billboardGraphics._height, time);\n            billboard.scaleByDistance = Property.getValueOrUndefined(billboardGraphics._scaleByDistance, time, scaleByDistanceScratch);\n            billboard.translucencyByDistance = Property.getValueOrUndefined(billboardGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n            billboard.pixelOffsetScaleByDistance = Property.getValueOrUndefined(billboardGraphics._pixelOffsetScaleByDistance, time, pixelOffsetScaleByDistanceScratch);\n            billboard.sizeInMeters = Property.getValueOrDefault(billboardGraphics._sizeInMeters, time, defaultSizeInMeters);\n            billboard.distanceDisplayCondition = Property.getValueOrUndefined(billboardGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n            billboard.disableDepthTestDistance = Property.getValueOrUndefined(billboardGraphics._disableDepthTestDistance, time);\n\n            var subRegion = Property.getValueOrUndefined(billboardGraphics._imageSubRegion, time, boundingRectangleScratch);\n            if (defined(subRegion)) {\n                billboard.setImageSubRegion(billboard._imageId, subRegion);\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    BillboardVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var item = this._items.get(entity.id);\n        if (!defined(item) || !defined(item.billboard)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var billboard = item.billboard;\n        if (billboard.heightReference === HeightReference.NONE) {\n            result.center = Cartesian3.clone(billboard.position, result.center);\n        } else {\n            if (!defined(billboard._clampedPosition)) {\n                return BoundingSphereState.PENDING;\n            }\n            result.center = Cartesian3.clone(billboard._clampedPosition, result.center);\n        }\n        result.radius = 0;\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    BillboardVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    BillboardVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(BillboardVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entityCollection.values;\n        for (var i = 0; i < entities.length; i++) {\n            this._cluster.removeBillboard(entities[i]);\n        }\n        return destroyObject(this);\n    };\n\n    BillboardVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var items = this._items;\n        var cluster = this._cluster;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._billboard) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._billboard) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                returnPrimitive(items.get(entity.id), entity, cluster);\n                items.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            returnPrimitive(items.get(entity.id), entity, cluster);\n            items.remove(entity.id);\n        }\n    };\n\n    function returnPrimitive(item, entity, cluster) {\n        if (defined(item)) {\n            item.billboard = undefined;\n            cluster.removeBillboard(entity);\n        }\n    }\nexport default BillboardVisualizer;\n","import defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport freezeObject from '../Core/freezeObject.js';\nimport VertexFormat from '../Core/VertexFormat.js';\nimport AllMaterialAppearanceFS from '../Shaders/Appearances/AllMaterialAppearanceFS.js';\nimport AllMaterialAppearanceVS from '../Shaders/Appearances/AllMaterialAppearanceVS.js';\nimport BasicMaterialAppearanceFS from '../Shaders/Appearances/BasicMaterialAppearanceFS.js';\nimport BasicMaterialAppearanceVS from '../Shaders/Appearances/BasicMaterialAppearanceVS.js';\nimport TexturedMaterialAppearanceFS from '../Shaders/Appearances/TexturedMaterialAppearanceFS.js';\nimport TexturedMaterialAppearanceVS from '../Shaders/Appearances/TexturedMaterialAppearanceVS.js';\nimport Appearance from './Appearance.js';\nimport Material from './Material.js';\n\n    /**\n     * An appearance for arbitrary geometry (as opposed to {@link EllipsoidSurfaceAppearance}, for example)\n     * that supports shading with materials.\n     *\n     * @alias MaterialAppearance\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Boolean} [options.flat=false] When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.\n     * @param {Boolean} [options.faceForward=!options.closed] When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.\n     * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link MaterialAppearance#renderState} has alpha blending enabled.\n     * @param {Boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link MaterialAppearance#renderState} has backface culling enabled.\n     * @param {MaterialAppearance.MaterialSupport} [options.materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] The type of materials that will be supported.\n     * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.\n     * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n     * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n     * @param {RenderState} [options.renderState] Optional render state to override the default render state.\n     *\n     * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Materials.html|Cesium Sandcastle Material Appearance Demo}\n     *\n     * @example\n     * var primitive = new Cesium.Primitive({\n     *   geometryInstances : new Cesium.GeometryInstance({\n     *     geometry : new Cesium.WallGeometry({\n            materialSupport :  Cesium.MaterialAppearance.MaterialSupport.BASIC.vertexFormat,\n     *       // ...\n     *     })\n     *   }),\n     *   appearance : new Cesium.MaterialAppearance({\n     *     material : Cesium.Material.fromType('Color'),\n     *     faceForward : true\n     *   })\n     *\n     * });\n     */\n    function MaterialAppearance(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var translucent = defaultValue(options.translucent, true);\n        var closed = defaultValue(options.closed, false);\n        var materialSupport = defaultValue(options.materialSupport, MaterialAppearance.MaterialSupport.TEXTURED);\n\n        /**\n         * The material used to determine the fragment color.  Unlike other {@link MaterialAppearance}\n         * properties, this is not read-only, so an appearance's material can change on the fly.\n         *\n         * @type Material\n         *\n         * @default {@link Material.ColorType}\n         *\n         * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}\n         */\n        this.material = (defined(options.material)) ? options.material : Material.fromType(Material.ColorType);\n\n        /**\n         * When <code>true</code>, the geometry is expected to appear translucent.\n         *\n         * @type {Boolean}\n         *\n         * @default true\n         */\n        this.translucent = translucent;\n\n        this._vertexShaderSource = defaultValue(options.vertexShaderSource, materialSupport.vertexShaderSource);\n        this._fragmentShaderSource = defaultValue(options.fragmentShaderSource, materialSupport.fragmentShaderSource);\n        this._renderState = Appearance.getDefaultRenderState(translucent, closed, options.renderState);\n        this._closed = closed;\n\n        // Non-derived members\n\n        this._materialSupport = materialSupport;\n        this._vertexFormat = materialSupport.vertexFormat;\n        this._flat = defaultValue(options.flat, false);\n        this._faceForward = defaultValue(options.faceForward, !closed);\n    }\n\n    defineProperties(MaterialAppearance.prototype, {\n        /**\n         * The GLSL source code for the vertex shader.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        vertexShaderSource : {\n            get : function() {\n                return this._vertexShaderSource;\n            }\n        },\n\n        /**\n         * The GLSL source code for the fragment shader.  The full fragment shader\n         * source is built procedurally taking into account {@link MaterialAppearance#material},\n         * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.\n         * Use {@link MaterialAppearance#getFragmentShaderSource} to get the full source.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        fragmentShaderSource : {\n            get : function() {\n                return this._fragmentShaderSource;\n            }\n        },\n\n        /**\n         * The WebGL fixed-function state to use when rendering the geometry.\n         * <p>\n         * The render state can be explicitly defined when constructing a {@link MaterialAppearance}\n         * instance, or it is set implicitly via {@link MaterialAppearance#translucent}\n         * and {@link MaterialAppearance#closed}.\n         * </p>\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Object}\n         * @readonly\n         */\n        renderState : {\n            get : function() {\n                return this._renderState;\n            }\n        },\n\n        /**\n         * When <code>true</code>, the geometry is expected to be closed so\n         * {@link MaterialAppearance#renderState} has backface culling enabled.\n         * If the viewer enters the geometry, it will not be visible.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        closed : {\n            get : function() {\n                return this._closed;\n            }\n        },\n\n        /**\n         * The type of materials supported by this instance.  This impacts the required\n         * {@link VertexFormat} and the complexity of the vertex and fragment shaders.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {MaterialAppearance.MaterialSupport}\n         * @readonly\n         *\n         * @default {@link MaterialAppearance.MaterialSupport.TEXTURED}\n         */\n        materialSupport : {\n            get : function() {\n                return this._materialSupport;\n            }\n        },\n\n        /**\n         * The {@link VertexFormat} that this appearance instance is compatible with.\n         * A geometry can have more vertex attributes and still be compatible - at a\n         * potential performance cost - but it can't have less.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type VertexFormat\n         * @readonly\n         *\n         * @default {@link MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat}\n         */\n        vertexFormat : {\n            get : function() {\n                return this._vertexFormat;\n            }\n        },\n\n        /**\n         * When <code>true</code>, flat shading is used in the fragment shader,\n         * which means lighting is not taking into account.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        flat : {\n            get : function() {\n                return this._flat;\n            }\n        },\n\n        /**\n         * When <code>true</code>, the fragment shader flips the surface normal\n         * as needed to ensure that the normal faces the viewer to avoid\n         * dark spots.  This is useful when both sides of a geometry should be\n         * shaded like {@link WallGeometry}.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default true\n         */\n        faceForward : {\n            get : function() {\n                return this._faceForward;\n            }\n        }\n    });\n\n    /**\n     * Procedurally creates the full GLSL fragment shader source.  For {@link MaterialAppearance},\n     * this is derived from {@link MaterialAppearance#fragmentShaderSource}, {@link MaterialAppearance#material},\n     * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.\n     *\n     * @function\n     *\n     * @returns {String} The full GLSL fragment shader source.\n     */\n    MaterialAppearance.prototype.getFragmentShaderSource = Appearance.prototype.getFragmentShaderSource;\n\n    /**\n     * Determines if the geometry is translucent based on {@link MaterialAppearance#translucent} and {@link Material#isTranslucent}.\n     *\n     * @function\n     *\n     * @returns {Boolean} <code>true</code> if the appearance is translucent.\n     */\n    MaterialAppearance.prototype.isTranslucent = Appearance.prototype.isTranslucent;\n\n    /**\n     * Creates a render state.  This is not the final render state instance; instead,\n     * it can contain a subset of render state properties identical to the render state\n     * created in the context.\n     *\n     * @function\n     *\n     * @returns {Object} The render state.\n     */\n    MaterialAppearance.prototype.getRenderState = Appearance.prototype.getRenderState;\n\n    /**\n     * Determines the type of {@link Material} that is supported by a\n     * {@link MaterialAppearance} instance.  This is a trade-off between\n     * flexibility (a wide array of materials) and memory/performance\n     * (required vertex format and GLSL shader complexity.\n     * @exports MaterialAppearance.MaterialSupport\n     */\n    MaterialAppearance.MaterialSupport = {\n        /**\n         * Only basic materials, which require just <code>position</code> and\n         * <code>normal</code> vertex attributes, are supported.\n         *\n         * @constant\n         */\n        BASIC : freezeObject({\n            vertexFormat : VertexFormat.POSITION_AND_NORMAL,\n            vertexShaderSource : BasicMaterialAppearanceVS,\n            fragmentShaderSource : BasicMaterialAppearanceFS\n        }),\n        /**\n         * Materials with textures, which require <code>position</code>,\n         * <code>normal</code>, and <code>st</code> vertex attributes,\n         * are supported.  The vast majority of materials fall into this category.\n         *\n         * @constant\n         */\n        TEXTURED : freezeObject({\n            vertexFormat : VertexFormat.POSITION_NORMAL_AND_ST,\n            vertexShaderSource : TexturedMaterialAppearanceVS,\n            fragmentShaderSource : TexturedMaterialAppearanceFS\n        }),\n        /**\n         * All materials, including those that work in tangent space, are supported.\n         * This requires <code>position</code>, <code>normal</code>, <code>st</code>,\n         * <code>tangent</code>, and <code>bitangent</code> vertex attributes.\n         *\n         * @constant\n         */\n        ALL : freezeObject({\n            vertexFormat : VertexFormat.ALL,\n            vertexShaderSource : AllMaterialAppearanceVS,\n            fragmentShaderSource : AllMaterialAppearanceFS\n        })\n    };\nexport default MaterialAppearance;\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute vec2 st;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n    v_st = st;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    materialInput.st = v_st;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute vec3 tangent;\\n\\\nattribute vec3 bitangent;\\n\\\nattribute vec2 st;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec3 v_tangentEC;\\n\\\nvarying vec3 v_bitangentEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n    v_tangentEC = czm_normal * tangent;                       // tangent in eye coordinates\\n\\\n    v_bitangentEC = czm_normal * bitangent;                   // bitangent in eye coordinates\\n\\\n    v_st = st;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec3 v_tangentEC;\\n\\\nvarying vec3 v_bitangentEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n    mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_bitangentEC);\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.tangentToEyeMatrix = tangentToEyeMatrix;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    materialInput.st = v_st;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n","import ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\n\n    /**\n     * Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.\n     *\n     * @alias DistanceDisplayConditionGeometryInstanceAttribute\n     * @constructor\n     *\n     * @param {Number} [near=0.0] The near distance.\n     * @param {Number} [far=Number.MAX_VALUE] The far distance.\n     *\n     * @exception {DeveloperError} far must be greater than near.\n     *\n     * @example\n     * var instance = new Cesium.GeometryInstance({\n     *   geometry : new Cesium.BoxGeometry({\n     *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n     *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),\n     *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)\n     *   }),\n     *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n     *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n     *   id : 'box',\n     *   attributes : {\n     *     distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(100.0, 10000.0)\n     *   }\n     * });\n     *\n     * @see GeometryInstance\n     * @see GeometryInstanceAttribute\n     */\n    function DistanceDisplayConditionGeometryInstanceAttribute(near, far) {\n        near = defaultValue(near, 0.0);\n        far = defaultValue(far, Number.MAX_VALUE);\n\n        \n\n        /**\n         * The values for the attributes stored in a typed array.\n         *\n         * @type Float32Array\n         *\n         * @default [0.0, 0.0, Number.MAX_VALUE]\n         */\n        this.value = new Float32Array([near, far]);\n    }\n\n    defineProperties(DistanceDisplayConditionGeometryInstanceAttribute.prototype, {\n        /**\n         * The datatype of each component in the attribute, e.g., individual elements in\n         * {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.\n         *\n         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n         *\n         * @type {ComponentDatatype}\n         * @readonly\n         *\n         * @default {@link ComponentDatatype.FLOAT}\n         */\n        componentDatatype : {\n            get : function() {\n                return ComponentDatatype.FLOAT;\n            }\n        },\n\n        /**\n         * The number of components in the attributes, i.e., {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.\n         *\n         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n         *\n         * @type {Number}\n         * @readonly\n         *\n         * @default 3\n         */\n        componentsPerAttribute : {\n            get : function() {\n                return 2;\n            }\n        },\n\n        /**\n         * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n         * indicate that the components should be mapped to the range [0, 1] (unsigned)\n         * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n         *\n         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        normalize : {\n            get : function() {\n                return false;\n            }\n        }\n    });\n\n    /**\n     * Creates a new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.\n     *\n     * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition.\n     * @returns {DistanceDisplayConditionGeometryInstanceAttribute} The new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance.\n     *\n     * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near\n     *\n     * @example\n     * var distanceDisplayCondition = new Cesium.DistanceDisplayCondition(100.0, 10000.0);\n     * var instance = new Cesium.GeometryInstance({\n     *   geometry : geometry,\n     *   attributes : {\n     *     distanceDisplayCondition : Cesium.DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n     *   }\n     * });\n     */\n    DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition = function(distanceDisplayCondition) {\n        \n\n        return new DistanceDisplayConditionGeometryInstanceAttribute(distanceDisplayCondition.near, distanceDisplayCondition.far);\n    };\n\n    /**\n     * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.\n     *\n     * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition value.\n     * @param {Float32Array} [result] The array to store the result in, if undefined a new instance will be created.\n     * @returns {Float32Array} The modified result parameter or a new instance if result was undefined.\n     *\n     * @example\n     * var attributes = primitive.getGeometryInstanceAttributes('an id');\n     * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n     */\n    DistanceDisplayConditionGeometryInstanceAttribute.toValue = function(distanceDisplayCondition, result) {\n        \n\n        if (!defined(result)) {\n            return new Float32Array([distanceDisplayCondition.near, distanceDisplayCondition.far]);\n        }\n        result[0] = distanceDisplayCondition.near;\n        result[1] = distanceDisplayCondition.far;\n        return result;\n    };\nexport default DistanceDisplayConditionGeometryInstanceAttribute;\n","import Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Material from '../Scene/Material.js';\n\n    /**\n     * The interface for all {@link Property} objects that represent {@link Material} uniforms.\n     * This type defines an interface and cannot be instantiated directly.\n     *\n     * @alias MaterialProperty\n     * @constructor\n     * @abstract\n     *\n     * @see ColorMaterialProperty\n     * @see CompositeMaterialProperty\n     * @see GridMaterialProperty\n     * @see ImageMaterialProperty\n     * @see PolylineGlowMaterialProperty\n     * @see PolylineOutlineMaterialProperty\n     * @see StripeMaterialProperty\n     */\n    function MaterialProperty() {\n        DeveloperError.throwInstantiationError();\n    }\n\n    defineProperties(MaterialProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof MaterialProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : DeveloperError.throwInstantiationError\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is considered to have changed if a call to getValue would return\n         * a different result for the same time.\n         * @memberof MaterialProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : DeveloperError.throwInstantiationError\n        }\n    });\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     * @function\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    MaterialProperty.prototype.getType = DeveloperError.throwInstantiationError;\n\n    /**\n     * Gets the value of the property at the provided time.\n     * @function\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    MaterialProperty.prototype.getValue = DeveloperError.throwInstantiationError;\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     * @function\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    MaterialProperty.prototype.equals = DeveloperError.throwInstantiationError;\n\n    /**\n     * @private\n     */\n    MaterialProperty.getValue = function(time, materialProperty, material) {\n        var type;\n\n        if (defined(materialProperty)) {\n            type = materialProperty.getType(time);\n            if (defined(type)) {\n                if (!defined(material) || (material.type !== type)) {\n                    material = Material.fromType(type);\n                }\n                materialProperty.getValue(time, material.uniforms);\n                return material;\n            }\n        }\n\n        if (!defined(material) || (material.type !== Material.ColorType)) {\n            material = Material.fromType(Material.ColorType);\n        }\n        Color.clone(Color.WHITE, material.uniforms.color);\n\n        return material;\n    };\nexport default MaterialProperty;\n","import BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport Primitive from '../Scene/Primitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    /**\n     * Defines the interface for a dynamic geometry updater.  A DynamicGeometryUpdater\n     * is responsible for handling visualization of a specific type of geometry\n     * that needs to be recomputed based on simulation time.\n     * This object is never used directly by client code, but is instead created by\n     * {@link GeometryUpdater} implementations which contain dynamic geometry.\n     *\n     * This type defines an interface and cannot be instantiated directly.\n     *\n     * @alias DynamicGeometryUpdater\n     * @constructor\n     * @private\n     * @abstract\n     */\n    function DynamicGeometryUpdater(geometryUpdater, primitives, orderedGroundPrimitives) {\n        \n\n        this._primitives = primitives;\n        this._orderedGroundPrimitives = orderedGroundPrimitives;\n        this._primitive = undefined;\n        this._outlinePrimitive = undefined;\n        this._geometryUpdater = geometryUpdater;\n        this._options = geometryUpdater._options;\n        this._entity = geometryUpdater._entity;\n        this._material = undefined;\n    }\n\n    DynamicGeometryUpdater.prototype._isHidden = function(entity, geometry, time) {\n        return !entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(geometry.show, time, true);\n    };\n\n    DynamicGeometryUpdater.prototype._setOptions = DeveloperError.throwInstantiationError;\n\n    /**\n     * Updates the geometry to the specified time.\n     * @memberof DynamicGeometryUpdater\n     * @function\n     *\n     * @param {JulianDate} time The current time.\n     */\n    DynamicGeometryUpdater.prototype.update = function(time) {\n        \n\n        var geometryUpdater = this._geometryUpdater;\n        var onTerrain = geometryUpdater._onTerrain;\n\n        var primitives = this._primitives;\n        var orderedGroundPrimitives = this._orderedGroundPrimitives;\n        if (onTerrain) {\n            orderedGroundPrimitives.remove(this._primitive);\n        } else {\n            primitives.removeAndDestroy(this._primitive);\n            primitives.removeAndDestroy(this._outlinePrimitive);\n            this._outlinePrimitive = undefined;\n        }\n        this._primitive = undefined;\n\n        var entity = this._entity;\n        var geometry = entity[this._geometryUpdater._geometryPropertyName];\n        this._setOptions(entity, geometry, time);\n        if (this._isHidden(entity, geometry, time)) {\n            return;\n        }\n\n        var shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n        var options = this._options;\n        if (!defined(geometry.fill) || geometry.fill.getValue(time)) {\n            var fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n            var isColorAppearance = fillMaterialProperty instanceof ColorMaterialProperty;\n            var appearance;\n            var closed = geometryUpdater._getIsClosed(options);\n            if (isColorAppearance) {\n                appearance = new PerInstanceColorAppearance({\n                    closed: closed,\n                    flat : onTerrain && !geometryUpdater._supportsMaterialsforEntitiesOnTerrain\n                });\n            } else {\n                var material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);\n                this._material = material;\n                appearance = new MaterialAppearance({\n                    material : material,\n                    translucent : material.isTranslucent(),\n                    closed : closed\n                });\n            }\n\n            if (onTerrain) {\n                options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;\n                this._primitive = orderedGroundPrimitives.add(new GroundPrimitive({\n                    geometryInstances : this._geometryUpdater.createFillGeometryInstance(time),\n                    appearance : appearance,\n                    asynchronous : false,\n                    shadows : shadows,\n                    classificationType : this._geometryUpdater.classificationTypeProperty.getValue(time)\n                }), Property.getValueOrUndefined(this._geometryUpdater.zIndex, time));\n            } else {\n                options.vertexFormat = appearance.vertexFormat;\n\n                var fillInstance = this._geometryUpdater.createFillGeometryInstance(time);\n\n                if (isColorAppearance) {\n                    appearance.translucent = fillInstance.attributes.color.value[3] !== 255;\n                }\n\n                this._primitive = primitives.add(new Primitive({\n                    geometryInstances : fillInstance,\n                    appearance : appearance,\n                    asynchronous : false,\n                    shadows : shadows\n                }));\n            }\n        }\n\n        if (!onTerrain && defined(geometry.outline) && geometry.outline.getValue(time)) {\n            var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time);\n            var outlineWidth = Property.getValueOrDefault(geometry.outlineWidth, time, 1.0);\n\n            this._outlinePrimitive = primitives.add(new Primitive({\n                geometryInstances : outlineInstance,\n                appearance : new PerInstanceColorAppearance({\n                    flat : true,\n                    translucent : outlineInstance.attributes.color.value[3] !== 255,\n                    renderState : {\n                        lineWidth : geometryUpdater._scene.clampLineWidth(outlineWidth)\n                    }\n                }),\n                asynchronous : false,\n                shadows : shadows\n            }));\n        }\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     * @function\n     *\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    DynamicGeometryUpdater.prototype.getBoundingSphere = function(result) {\n        \n        var entity = this._entity;\n        var primitive = this._primitive;\n        var outlinePrimitive = this._outlinePrimitive;\n\n        var attributes;\n\n        //Outline and Fill geometries have the same bounding sphere, so just use whichever one is defined and ready\n        if (defined(primitive) && primitive.show && primitive.ready) {\n            attributes = primitive.getGeometryInstanceAttributes(entity);\n            if (defined(attributes) && defined(attributes.boundingSphere)) {\n                BoundingSphere.clone(attributes.boundingSphere, result);\n                return BoundingSphereState.DONE;\n            }\n        }\n\n        if (defined(outlinePrimitive) && outlinePrimitive.show && outlinePrimitive.ready) {\n            attributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n            if (defined(attributes) && defined(attributes.boundingSphere)) {\n                BoundingSphere.clone(attributes.boundingSphere, result);\n                return BoundingSphereState.DONE;\n            }\n        }\n\n        if ((defined(primitive) && !primitive.ready) || (defined(outlinePrimitive) && !outlinePrimitive.ready)) {\n            return BoundingSphereState.PENDING;\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * @memberof DynamicGeometryUpdater\n     * @function\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    DynamicGeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     * @memberof DynamicGeometryUpdater\n     * @function\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    DynamicGeometryUpdater.prototype.destroy = function() {\n        var primitives = this._primitives;\n        var orderedGroundPrimitives = this._orderedGroundPrimitives;\n        if (this._geometryUpdater._onTerrain) {\n            orderedGroundPrimitives.remove(this._primitive);\n        } else {\n            primitives.removeAndDestroy(this._primitive);\n        }\n        primitives.removeAndDestroy(this._outlinePrimitive);\n        destroyObject(this);\n    };\nexport default DynamicGeometryUpdater;\n","import Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport Event from '../Core/Event.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport oneTimeWarning from '../Core/oneTimeWarning.js';\nimport ClassificationType from '../Scene/ClassificationType.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport ConstantProperty from './ConstantProperty.js';\nimport Entity from './Entity.js';\nimport Property from './Property.js';\n\n    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);\n    var defaultShow = new ConstantProperty(true);\n    var defaultFill = new ConstantProperty(true);\n    var defaultOutline = new ConstantProperty(false);\n    var defaultOutlineColor = new ConstantProperty(Color.BLACK);\n    var defaultShadows = new ConstantProperty(ShadowMode.DISABLED);\n    var defaultDistanceDisplayCondition = new ConstantProperty(new DistanceDisplayCondition());\n    var defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);\n\n    /**\n     * An abstract class for updating geometry entities.\n     * @alias GeometryUpdater\n     * @constructor\n     *\n     * @param {Object} options An object with the following properties:\n     * @param {Entity} options.entity The entity containing the geometry to be visualized.\n     * @param {Scene} options.scene The scene where visualization is taking place.\n     * @param {Object} options.geometryOptions Options for the geometry\n     * @param {String} options.geometryPropertyName The geometry property name\n     * @param {String[]} options.observedPropertyNames The entity properties this geometry cares about\n     */\n    function GeometryUpdater(options) {\n        \n\n        var entity = options.entity;\n        var geometryPropertyName = options.geometryPropertyName;\n\n        this._entity = entity;\n        this._scene = options.scene;\n        this._fillEnabled = false;\n        this._isClosed = false;\n        this._onTerrain = false;\n        this._dynamic = false;\n        this._outlineEnabled = false;\n        this._geometryChanged = new Event();\n        this._showProperty = undefined;\n        this._materialProperty = undefined;\n        this._showOutlineProperty = undefined;\n        this._outlineColorProperty = undefined;\n        this._outlineWidth = 1.0;\n        this._shadowsProperty = undefined;\n        this._distanceDisplayConditionProperty = undefined;\n        this._classificationTypeProperty = undefined;\n        this._options = options.geometryOptions;\n        this._geometryPropertyName = geometryPropertyName;\n        this._id = geometryPropertyName + '-' + entity.id;\n        this._observedPropertyNames = options.observedPropertyNames;\n        this._supportsMaterialsforEntitiesOnTerrain = Entity.supportsMaterialsforEntitiesOnTerrain(options.scene);\n    }\n\n    defineProperties(GeometryUpdater.prototype, {\n        /**\n         * Gets the unique ID associated with this updater\n         * @memberof GeometryUpdater.prototype\n         * @type {String}\n         * @readonly\n         */\n        id : {\n            get : function() {\n                return this._id;\n            }\n        },\n        /**\n         * Gets the entity associated with this geometry.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Entity}\n         * @readonly\n         */\n        entity : {\n            get : function() {\n                return this._entity;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has a fill component.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        fillEnabled : {\n            get : function() {\n                return this._fillEnabled;\n            }\n        },\n        /**\n         * Gets a value indicating if fill visibility varies with simulation time.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantFill : {\n            get : function() {\n                return !this._fillEnabled ||\n                       (!defined(this._entity.availability) &&\n                        Property.isConstant(this._showProperty) &&\n                        Property.isConstant(this._fillProperty));\n            }\n        },\n        /**\n         * Gets the material property used to fill the geometry.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {MaterialProperty}\n         * @readonly\n         */\n        fillMaterialProperty : {\n            get : function() {\n                return this._materialProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has an outline component.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        outlineEnabled : {\n            get : function() {\n                return this._outlineEnabled;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has an outline component.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantOutline : {\n            get : function() {\n                return !this._outlineEnabled ||\n                       (!defined(this._entity.availability) &&\n                        Property.isConstant(this._showProperty) &&\n                        Property.isConstant(this._showOutlineProperty));\n            }\n        },\n        /**\n         * Gets the {@link Color} property for the geometry outline.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        outlineColorProperty : {\n            get : function() {\n                return this._outlineColorProperty;\n            }\n        },\n        /**\n         * Gets the constant with of the geometry outline, in pixels.\n         * This value is only valid if isDynamic is false.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Number}\n         * @readonly\n         */\n        outlineWidth : {\n            get : function() {\n                return this._outlineWidth;\n            }\n        },\n        /**\n         * Gets the property specifying whether the geometry\n         * casts or receives shadows from each light source.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        shadowsProperty : {\n            get : function() {\n                return this._shadowsProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        distanceDisplayConditionProperty : {\n            get : function() {\n                return this._distanceDisplayConditionProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        classificationTypeProperty : {\n            get : function() {\n                return this._classificationTypeProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is time-varying.\n         * If true, all visualization is delegated to a DynamicGeometryUpdater\n         * returned by GeometryUpdater#createDynamicUpdater.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isDynamic : {\n            get : function() {\n                return this._dynamic;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is closed.\n         * This property is only valid for static geometry.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isClosed : {\n            get : function() {\n                return this._isClosed;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry should be drawn on terrain.\n         * @memberof EllipseGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        onTerrain : {\n            get : function() {\n                return this._onTerrain;\n            }\n        },\n        /**\n         * Gets an event that is raised whenever the public properties\n         * of this updater change.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        geometryChanged : {\n            get : function() {\n                return this._geometryChanged;\n            }\n        }\n    });\n\n    /**\n     * Checks if the geometry is outlined at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.\n     */\n    GeometryUpdater.prototype.isOutlineVisible = function(time) {\n        var entity = this._entity;\n        var visible = this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);\n        return defaultValue(visible, false);\n    };\n\n    /**\n     * Checks if the geometry is filled at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.\n     */\n    GeometryUpdater.prototype.isFilled = function(time) {\n        var entity = this._entity;\n        var visible = this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);\n        return defaultValue(visible, false);\n    };\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @function\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    GeometryUpdater.prototype.createFillGeometryInstance = DeveloperError.throwInstantiationError;\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @function\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    GeometryUpdater.prototype.createOutlineGeometryInstance = DeveloperError.throwInstantiationError;\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    GeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    GeometryUpdater.prototype.destroy = function() {\n        destroyObject(this);\n    };\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._isHidden = function(entity, geometry) {\n        var show = geometry.show;\n        return defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE);\n    };\n\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._isOnTerrain = function(entity, geometry) {\n        return false;\n    };\n\n    /**\n     * @param {GeometryOptions} options\n     * @private\n     */\n    GeometryUpdater.prototype._getIsClosed = function(options) {\n        return true;\n    };\n\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._isDynamic = DeveloperError.throwInstantiationError;\n\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._setStaticOptions = DeveloperError.throwInstantiationError;\n\n    /**\n     * @param {Entity} entity\n     * @param {String} propertyName\n     * @param {*} newValue\n     * @param {*} oldValue\n     * @private\n     */\n    GeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        if (this._observedPropertyNames.indexOf(propertyName) === -1) {\n            return;\n        }\n\n        var geometry = this._entity[this._geometryPropertyName];\n\n        if (!defined(geometry)) {\n            if (this._fillEnabled || this._outlineEnabled) {\n                this._fillEnabled = false;\n                this._outlineEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var fillProperty = geometry.fill;\n        var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;\n\n        var outlineProperty = geometry.outline;\n        var outlineEnabled = defined(outlineProperty);\n        if (outlineEnabled && outlineProperty.isConstant) {\n            outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);\n        }\n\n        if (!fillEnabled && !outlineEnabled) {\n            if (this._fillEnabled || this._outlineEnabled) {\n                this._fillEnabled = false;\n                this._outlineEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var show = geometry.show;\n        if (this._isHidden(entity, geometry)) {\n            if (this._fillEnabled || this._outlineEnabled) {\n                this._fillEnabled = false;\n                this._outlineEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        this._materialProperty = defaultValue(geometry.material, defaultMaterial);\n        this._fillProperty = defaultValue(fillProperty, defaultFill);\n        this._showProperty = defaultValue(show, defaultShow);\n        this._showOutlineProperty = defaultValue(geometry.outline, defaultOutline);\n        this._outlineColorProperty = outlineEnabled ? defaultValue(geometry.outlineColor, defaultOutlineColor) : undefined;\n        this._shadowsProperty = defaultValue(geometry.shadows, defaultShadows);\n        this._distanceDisplayConditionProperty = defaultValue(geometry.distanceDisplayCondition, defaultDistanceDisplayCondition);\n        this._classificationTypeProperty = defaultValue(geometry.classificationType, defaultClassificationType);\n\n        this._fillEnabled = fillEnabled;\n\n        var onTerrain = this._isOnTerrain(entity, geometry) &&\n            (this._supportsMaterialsforEntitiesOnTerrain || this._materialProperty instanceof ColorMaterialProperty);\n\n        if (outlineEnabled && onTerrain) {\n            oneTimeWarning(oneTimeWarning.geometryOutlines);\n            outlineEnabled = false;\n        }\n\n        this._onTerrain = onTerrain;\n        this._outlineEnabled = outlineEnabled;\n\n        if (this._isDynamic(entity, geometry)) {\n            if (!this._dynamic) {\n                this._dynamic = true;\n                this._geometryChanged.raiseEvent(this);\n            }\n        } else {\n            this._setStaticOptions(entity, geometry);\n            this._isClosed = this._getIsClosed(this._options);\n            var outlineWidth = geometry.outlineWidth;\n            this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1.0;\n            this._dynamic = false;\n            this._geometryChanged.raiseEvent(this);\n        }\n    };\n\n    /**\n     * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.\n     *\n     * @param {PrimitiveCollection} primitives The primitive collection to use.\n     * @param {PrimitiveCollection} [groundPrimitives] The primitive collection to use for ground primitives.\n     *\n     * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.\n     *\n     * @exception {DeveloperError} This instance does not represent dynamic geometry.\n     */\n    GeometryUpdater.prototype.createDynamicUpdater = function(primitives, groundPrimitives) {\n        \n\n        return new this.constructor.DynamicGeometryUpdater(this, primitives, groundPrimitives);\n    };\nexport default GeometryUpdater;\n","import Cartesian3 from '../Core/Cartesian3.js';\nimport Cartographic from '../Core/Cartographic.js';\nimport Check from '../Core/Check.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport Event from '../Core/Event.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport CesiumMath from '../Core/Math.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport SceneMode from '../Scene/SceneMode.js';\nimport Property from './Property.js';\n\n    var scratchPosition = new Cartesian3();\n    var scratchCarto = new Cartographic();\n\n    /**\n     * @private\n     */\n    function TerrainOffsetProperty(scene, positionProperty, heightReferenceProperty, extrudedHeightReferenceProperty) {\n        \n\n        this._scene = scene;\n        this._heightReference = heightReferenceProperty;\n        this._extrudedHeightReference = extrudedHeightReferenceProperty;\n        this._positionProperty = positionProperty;\n\n        this._position = new Cartesian3();\n        this._cartographicPosition = new Cartographic();\n        this._normal = new Cartesian3();\n\n        this._definitionChanged = new Event();\n        this._terrainHeight = 0;\n        this._removeCallbackFunc = undefined;\n        this._removeEventListener = undefined;\n        this._removeModeListener = undefined;\n\n        var that = this;\n        if (defined(scene.globe)) {\n            this._removeEventListener = scene.terrainProviderChanged.addEventListener(function() {\n                that._updateClamping();\n            });\n            this._removeModeListener = scene.morphComplete.addEventListener(function() {\n                that._updateClamping();\n            });\n        }\n\n        if (positionProperty.isConstant) {\n            var position = positionProperty.getValue(Iso8601.MINIMUM_VALUE, scratchPosition);\n            if (!defined(position) || Cartesian3.equals(position, Cartesian3.ZERO) || !defined(scene.globe)) {\n                return;\n            }\n            this._position = Cartesian3.clone(position, this._position);\n\n            this._updateClamping();\n\n            this._normal = scene.globe.ellipsoid.geodeticSurfaceNormal(position, this._normal);\n        }\n    }\n\n    defineProperties(TerrainOffsetProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.\n         * @memberof TerrainOffsetProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return false;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * @memberof TerrainOffsetProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        }\n    });\n\n    /**\n     * @private\n     */\n    TerrainOffsetProperty.prototype._updateClamping = function() {\n        if (defined(this._removeCallbackFunc)) {\n            this._removeCallbackFunc();\n        }\n\n        var scene = this._scene;\n        var globe = scene.globe;\n        var position = this._position;\n\n        if (!defined(globe) || Cartesian3.equals(position, Cartesian3.ZERO)) {\n            this._terrainHeight = 0;\n            return;\n        }\n        var ellipsoid = globe.ellipsoid;\n        var surface = globe._surface;\n\n        var that = this;\n        var cartographicPosition = ellipsoid.cartesianToCartographic(position, this._cartographicPosition);\n        var height = globe.getHeight(cartographicPosition);\n        if (defined(height)) {\n            this._terrainHeight = height;\n        } else {\n            this._terrainHeight = 0;\n        }\n\n        function updateFunction(clampedPosition) {\n            if (scene.mode === SceneMode.SCENE3D) {\n                var carto = ellipsoid.cartesianToCartographic(clampedPosition, scratchCarto);\n                that._terrainHeight = carto.height;\n            } else {\n                that._terrainHeight = clampedPosition.x;\n            }\n            that.definitionChanged.raiseEvent();\n        }\n        this._removeCallbackFunc = surface.updateHeight(cartographicPosition, updateFunction);\n    };\n\n    /**\n     * Gets the height relative to the terrain based on the positions.\n     *\n     * @returns {Cartesian3} The offset\n     */\n    TerrainOffsetProperty.prototype.getValue = function(time, result) {\n        var heightReference = Property.getValueOrDefault(this._heightReference, time, HeightReference.NONE);\n        var extrudedHeightReference = Property.getValueOrDefault(this._extrudedHeightReference, time, HeightReference.NONE);\n\n        if (heightReference === HeightReference.NONE && extrudedHeightReference !== HeightReference.RELATIVE_TO_GROUND) {\n            this._position = Cartesian3.clone(Cartesian3.ZERO, this._position);\n            return Cartesian3.clone(Cartesian3.ZERO, result);\n        }\n\n        if (this._positionProperty.isConstant) {\n            return Cartesian3.multiplyByScalar(this._normal, this._terrainHeight, result);\n        }\n\n        var scene = this._scene;\n        var position = this._positionProperty.getValue(time, scratchPosition);\n        if (!defined(position) || Cartesian3.equals(position, Cartesian3.ZERO) || !defined(scene.globe)) {\n            return Cartesian3.clone(Cartesian3.ZERO, result);\n        }\n\n        if (Cartesian3.equalsEpsilon(this._position, position, CesiumMath.EPSILON10)) {\n            return Cartesian3.multiplyByScalar(this._normal, this._terrainHeight, result);\n        }\n\n        this._position = Cartesian3.clone(position, this._position);\n\n        this._updateClamping();\n\n        var normal = scene.globe.ellipsoid.geodeticSurfaceNormal(position, this._normal);\n        return Cartesian3.multiplyByScalar(normal, this._terrainHeight, result);\n    };\n\n    TerrainOffsetProperty.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    TerrainOffsetProperty.prototype.destroy = function() {\n        if (defined(this._removeEventListener)) {\n            this._removeEventListener();\n        }\n        if (defined(this._removeModeListener)) {\n            this._removeModeListener();\n        }\n        if (defined(this._removeCallbackFunc)) {\n            this._removeCallbackFunc();\n        }\n        return destroyObject(this);\n    };\n\n    /**\n     * A function which creates one or more providers.\n     * @callback TerrainOffsetProperty~PositionFunction\n     * @param {JulianDate} time The clock time at which to retrieve the position\n     * @param {Cartesian3} result The result position\n     * @returns {Cartesian3} The position at which to do the terrain height check\n     */\nexport default TerrainOffsetProperty;\n","import defined from '../Core/defined.js';\nimport CallbackProperty from './CallbackProperty.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport TerrainOffsetProperty from './TerrainOffsetProperty.js';\n\n    function heightReferenceOnEntityPropertyChanged(entity, propertyName, newValue, oldValue) {\n        GeometryUpdater.prototype._onEntityPropertyChanged.call(this, entity, propertyName, newValue, oldValue);\n        if (this._observedPropertyNames.indexOf(propertyName) === -1) {\n            return;\n        }\n\n        var geometry = this._entity[this._geometryPropertyName];\n        if (!defined(geometry)) {\n            return;\n        }\n\n        if (defined(this._terrainOffsetProperty)) {\n            this._terrainOffsetProperty.destroy();\n            this._terrainOffsetProperty = undefined;\n        }\n\n        var heightReferenceProperty = geometry.heightReference;\n\n        if (defined(heightReferenceProperty)) {\n            var centerPosition = new CallbackProperty(this._computeCenter.bind(this), !this._dynamic);\n            this._terrainOffsetProperty = new TerrainOffsetProperty(this._scene, centerPosition, heightReferenceProperty);\n        }\n    }\nexport default heightReferenceOnEntityPropertyChanged;\n","import BoxGeometry from '../Core/BoxGeometry.js';\nimport BoxOutlineGeometry from '../Core/BoxOutlineGeometry.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport GeometryOffsetAttribute from '../Core/GeometryOffsetAttribute.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport heightReferenceOnEntityPropertyChanged from './heightReferenceOnEntityPropertyChanged.js';\nimport Property from './Property.js';\n\n    var defaultOffset = Cartesian3.ZERO;\n\n    var offsetScratch = new Cartesian3();\n    var positionScratch = new Cartesian3();\n    var scratchColor = new Color();\n\n    function BoxGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.dimensions = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for boxes.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias BoxGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function BoxGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new BoxGeometryOptions(entity),\n            geometryPropertyName : 'box',\n            observedPropertyNames : ['availability', 'position', 'orientation', 'box']\n        });\n\n        this._onEntityPropertyChanged(entity, 'box', entity.box, undefined);\n    }\n\n    if (defined(Object.create)) {\n        BoxGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        BoxGeometryUpdater.prototype.constructor = BoxGeometryUpdater;\n    }\n\n    defineProperties(BoxGeometryUpdater.prototype, {\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof BoxGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty: {\n            get: function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    BoxGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute,\n            color : undefined,\n            offset: undefined\n        };\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : BoxGeometry.fromDimensions(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.box.heightReference, this._options.dimensions.z * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    BoxGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : BoxOutlineGeometry.fromDimensions(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.box.heightReference, this._options.dimensions.z * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    BoxGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    BoxGeometryUpdater.prototype._isHidden = function(entity, box) {\n        return !defined(box.dimensions) || !defined(entity.position) || GeometryUpdater.prototype._isHidden.call(this, entity, box);\n    };\n\n    BoxGeometryUpdater.prototype._isDynamic = function(entity, box) {\n        return !entity.position.isConstant ||  !Property.isConstant(entity.orientation) ||  !box.dimensions.isConstant ||  !Property.isConstant(box.outlineWidth);\n    };\n\n    BoxGeometryUpdater.prototype._setStaticOptions = function(entity, box) {\n        var heightReference = Property.getValueOrDefault(box.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n\n        var options = this._options;\n        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.dimensions = box.dimensions.getValue(Iso8601.MINIMUM_VALUE, options.dimensions);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    BoxGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\n\n    BoxGeometryUpdater.DynamicGeometryUpdater = DynamicBoxGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicBoxGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicBoxGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicBoxGeometryUpdater.prototype.constructor = DynamicBoxGeometryUpdater;\n    }\n\n    DynamicBoxGeometryUpdater.prototype._isHidden = function(entity, box, time) {\n        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n        var dimensions = this._options.dimensions;\n        return !defined(position) || !defined(dimensions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, box, time);\n    };\n\n    DynamicBoxGeometryUpdater.prototype._setOptions = function(entity, box, time) {\n        var heightReference = Property.getValueOrDefault(box.heightReference, time, HeightReference.NONE);\n        var options = this._options;\n        options.dimensions = Property.getValueOrUndefined(box.dimensions, time, options.dimensions);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\nexport default BoxGeometryUpdater;\n","import Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartesian4 from './Cartesian4.js';\nimport Cartographic from './Cartographic.js';\nimport CornerType from './CornerType.js';\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport Matrix4 from './Matrix4.js';\nimport PolylinePipeline from './PolylinePipeline.js';\nimport Quaternion from './Quaternion.js';\nimport Transforms from './Transforms.js';\n\n    var scratch2Array = [new Cartesian3(), new Cartesian3()];\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartesian3 = new Cartesian3();\n    var scratchCartesian4 = new Cartesian3();\n    var scratchCartesian5 = new Cartesian3();\n    var scratchCartesian6 = new Cartesian3();\n    var scratchCartesian7 = new Cartesian3();\n    var scratchCartesian8 = new Cartesian3();\n    var scratchCartesian9 = new Cartesian3();\n\n    var scratch1 = new Cartesian3();\n    var scratch2 = new Cartesian3();\n\n    /**\n     * @private\n     */\n    var PolylineVolumeGeometryLibrary = {};\n\n    var cartographic = new Cartographic();\n    function scaleToSurface(positions, ellipsoid) {\n        var heights = new Array(positions.length);\n        for (var i = 0; i < positions.length; i++) {\n            var pos = positions[i];\n            cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);\n            heights[i] = cartographic.height;\n            positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);\n        }\n        return heights;\n    }\n\n    function subdivideHeights(points, h0, h1, granularity) {\n        var p0 = points[0];\n        var p1 = points[1];\n        var angleBetween = Cartesian3.angleBetween(p0, p1);\n        var numPoints = Math.ceil(angleBetween / granularity);\n        var heights = new Array(numPoints);\n        var i;\n        if (h0 === h1) {\n            for (i = 0; i < numPoints; i++) {\n                heights[i] = h0;\n            }\n            heights.push(h1);\n            return heights;\n        }\n\n        var dHeight = h1 - h0;\n        var heightPerVertex = dHeight / (numPoints);\n\n        for (i = 1; i < numPoints; i++) {\n            var h = h0 + i * heightPerVertex;\n            heights[i] = h;\n        }\n\n        heights[0] = h0;\n        heights.push(h1);\n        return heights;\n    }\n\n    var nextScratch = new Cartesian3();\n    var prevScratch = new Cartesian3();\n\n    function computeRotationAngle(start, end, position, ellipsoid) {\n        var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n        var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, start, nextScratch), nextScratch);\n        var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, end, prevScratch), prevScratch);\n        var angle = Cartesian2.angleBetween(next, prev);\n\n        return (prev.x * next.y - prev.y * next.x >= 0.0) ? -angle : angle;\n    }\n\n    var negativeX = new Cartesian3(-1, 0, 0);\n    var transform = new Matrix4();\n    var translation = new Matrix4();\n    var rotationZ = new Matrix3();\n    var scaleMatrix = Matrix3.IDENTITY.clone();\n    var westScratch = new Cartesian3();\n    var finalPosScratch = new Cartesian4();\n    var heightCartesian = new Cartesian3();\n    function addPosition(center, left, shape, finalPositions, ellipsoid, height, xScalar, repeat) {\n        var west = westScratch;\n        var finalPosition = finalPosScratch;\n        transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);\n\n        west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);\n        west = Cartesian3.normalize(west, west);\n        var angle = computeRotationAngle(west, left, center, ellipsoid);\n        rotationZ = Matrix3.fromRotationZ(angle, rotationZ);\n\n        heightCartesian.z = height;\n        transform = Matrix4.multiplyTransformation(transform, Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation), transform);\n        var scale = scaleMatrix;\n        scale[0] = xScalar;\n\n        for (var j = 0; j < repeat; j++) {\n            for (var i = 0; i < shape.length; i += 3) {\n                finalPosition = Cartesian3.fromArray(shape, i, finalPosition);\n                finalPosition = Matrix3.multiplyByVector(scale, finalPosition, finalPosition);\n                finalPosition = Matrix4.multiplyByPoint(transform, finalPosition, finalPosition);\n                finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);\n            }\n        }\n\n        return finalPositions;\n    }\n\n    var centerScratch = new Cartesian3();\n    function addPositions(centers, left, shape, finalPositions, ellipsoid, heights, xScalar) {\n        for (var i = 0; i < centers.length; i += 3) {\n            var center = Cartesian3.fromArray(centers, i, centerScratch);\n            finalPositions = addPosition(center, left, shape, finalPositions, ellipsoid, heights[i / 3], xScalar, 1);\n        }\n        return finalPositions;\n    }\n\n    function convertShapeTo3DDuplicate(shape2D, boundingRectangle) { //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points\n        var length = shape2D.length;\n        var shape = new Array(length * 6);\n        var index = 0;\n        var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n        var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n        var point = shape2D[0];\n        shape[index++] = point.x - xOffset;\n        shape[index++] = 0.0;\n        shape[index++] = point.y - yOffset;\n        for (var i = 1; i < length; i++) {\n            point = shape2D[i];\n            var x = point.x - xOffset;\n            var z = point.y - yOffset;\n            shape[index++] = x;\n            shape[index++] = 0.0;\n            shape[index++] = z;\n\n            shape[index++] = x;\n            shape[index++] = 0.0;\n            shape[index++] = z;\n        }\n        point = shape2D[0];\n        shape[index++] = point.x - xOffset;\n        shape[index++] = 0.0;\n        shape[index++] = point.y - yOffset;\n\n        return shape;\n    }\n\n    function convertShapeTo3D(shape2D, boundingRectangle) { //orientate 2D shape to XZ plane center at (0, 0, 0)\n        var length = shape2D.length;\n        var shape = new Array(length * 3);\n        var index = 0;\n        var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n        var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n        for (var i = 0; i < length; i++) {\n            shape[index++] = shape2D[i].x - xOffset;\n            shape[index++] = 0;\n            shape[index++] = shape2D[i].y - yOffset;\n        }\n\n        return shape;\n    }\n\n    var quaterion = new Quaternion();\n    var startPointScratch = new Cartesian3();\n    var rotMatrix = new Matrix3();\n    function computeRoundCorner(pivot, startPoint, endPoint, cornerType, leftIsOutside, ellipsoid, finalPositions, shape, height, duplicatePoints) {\n        var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, pivot, scratch1), Cartesian3.subtract(endPoint, pivot, scratch2));\n        var granularity = (cornerType === CornerType.BEVELED) ? 0 : Math.ceil(angle / CesiumMath.toRadians(5));\n\n        var m;\n        if (leftIsOutside) {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(pivot, scratch1), angle / (granularity + 1), quaterion), rotMatrix);\n        } else {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion), rotMatrix);\n        }\n\n        var left;\n        var surfacePoint;\n        startPoint = Cartesian3.clone(startPoint, startPointScratch);\n        if (granularity > 0) {\n            var repeat = duplicatePoints ? 2 : 1;\n            for (var i = 0; i < granularity; i++) {\n                startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n                left = Cartesian3.subtract(startPoint, pivot, scratch1);\n                left = Cartesian3.normalize(left, left);\n                if (!leftIsOutside) {\n                    left = Cartesian3.negate(left, left);\n                }\n                surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n                finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, repeat);\n            }\n        } else {\n            left = Cartesian3.subtract(startPoint, pivot, scratch1);\n            left = Cartesian3.normalize(left, left);\n            if (!leftIsOutside) {\n                left = Cartesian3.negate(left, left);\n            }\n            surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n            finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\n\n            endPoint = Cartesian3.clone(endPoint, startPointScratch);\n            left = Cartesian3.subtract(endPoint, pivot, scratch1);\n            left = Cartesian3.normalize(left, left);\n            if (!leftIsOutside) {\n                left = Cartesian3.negate(left, left);\n            }\n            surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);\n            finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\n        }\n\n        return finalPositions;\n    }\n\n    PolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function(shapePositions) {\n        var length = shapePositions.length;\n        var cleanedPositions = [];\n        for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n            var v0 = shapePositions[i0];\n            var v1 = shapePositions[i1];\n\n            if (!Cartesian2.equals(v0, v1)) {\n                cleanedPositions.push(v1); // Shallow copy!\n            }\n        }\n\n        return cleanedPositions;\n    };\n\n    PolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function(forward, backward, position, ellipsoid) {\n        var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n        var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, forward, nextScratch), nextScratch);\n        var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, backward, prevScratch), prevScratch);\n\n        return ((prev.x * next.y) - (prev.y * next.x)) >= 0.0;\n    };\n\n    var scratchForwardProjection = new Cartesian3();\n    var scratchBackwardProjection = new Cartesian3();\n\n    PolylineVolumeGeometryLibrary.computePositions = function(positions, shape2D, boundingRectangle, geometry, duplicatePoints) {\n        var ellipsoid = geometry._ellipsoid;\n        var heights = scaleToSurface(positions, ellipsoid);\n        var granularity = geometry._granularity;\n        var cornerType = geometry._cornerType;\n        var shapeForSides = duplicatePoints ? convertShapeTo3DDuplicate(shape2D, boundingRectangle) : convertShapeTo3D(shape2D, boundingRectangle);\n        var shapeForEnds = duplicatePoints ? convertShapeTo3D(shape2D, boundingRectangle) : undefined;\n        var heightOffset = boundingRectangle.height / 2;\n        var width = boundingRectangle.width / 2;\n        var length = positions.length;\n        var finalPositions = [];\n        var ends = duplicatePoints ? [] : undefined;\n\n        var forward = scratchCartesian1;\n        var backward = scratchCartesian2;\n        var cornerDirection = scratchCartesian3;\n        var surfaceNormal = scratchCartesian4;\n        var pivot = scratchCartesian5;\n        var start = scratchCartesian6;\n        var end = scratchCartesian7;\n        var left = scratchCartesian8;\n        var previousPosition = scratchCartesian9;\n\n        var position = positions[0];\n        var nextPosition = positions[1];\n        surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n        forward = Cartesian3.subtract(nextPosition, position, forward);\n        forward = Cartesian3.normalize(forward, forward);\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        var h0 = heights[0];\n        var h1 = heights[1];\n        if (duplicatePoints) {\n            ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h0 + heightOffset, 1, 1);\n        }\n        previousPosition = Cartesian3.clone(position, previousPosition);\n        position = nextPosition;\n        backward = Cartesian3.negate(forward, backward);\n        var subdividedHeights;\n        var subdividedPositions;\n        for (var i = 1; i < length - 1; i++) {\n            var repeat = duplicatePoints ? 2 : 1;\n            nextPosition = positions[i + 1];\n            forward = Cartesian3.subtract(nextPosition, position, forward);\n            forward = Cartesian3.normalize(forward, forward);\n            cornerDirection = Cartesian3.add(forward, backward, cornerDirection);\n            cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n            surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n\n            var forwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(forward, surfaceNormal), scratchForwardProjection);\n            Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n            Cartesian3.normalize(forwardProjection, forwardProjection);\n\n            var backwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(backward, surfaceNormal), scratchBackwardProjection);\n            Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n            Cartesian3.normalize(backwardProjection, backwardProjection);\n\n            var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\n\n            if (doCorner) {\n                cornerDirection = Cartesian3.cross(cornerDirection, surfaceNormal, cornerDirection);\n                cornerDirection = Cartesian3.cross(surfaceNormal, cornerDirection, cornerDirection);\n                cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n                var scalar = 1 / Math.max(0.25, (Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1))));\n                var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\n                if (leftIsOutside) {\n                    pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\n                    start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, start), start);\n                    scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n                    scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n                    subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scratch2Array,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n                    left = Cartesian3.cross(surfaceNormal, forward, left);\n                    left = Cartesian3.normalize(left, left);\n                    end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, end), end);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\n                    } else {\n                        cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);\n                        finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\n                    }\n                    previousPosition = Cartesian3.clone(end, previousPosition);\n                } else {\n                    pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\n                    start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, start), start);\n                    scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n                    scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n                    subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scratch2Array,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n                    left = Cartesian3.cross(surfaceNormal, forward, left);\n                    left = Cartesian3.normalize(left, left);\n                    end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, end), end);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\n                    } else {\n                        finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\n                    }\n                    previousPosition = Cartesian3.clone(end, previousPosition);\n                }\n                backward = Cartesian3.negate(forward, backward);\n            } else {\n                finalPositions = addPosition(previousPosition, left, shapeForSides, finalPositions, ellipsoid, h0 + heightOffset, 1, 1);\n                previousPosition = position;\n            }\n            h0 = h1;\n            h1 = heights[i + 1];\n            position = nextPosition;\n        }\n\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n        subdividedPositions = PolylinePipeline.generateArc({\n            positions: scratch2Array,\n            granularity: granularity,\n            ellipsoid: ellipsoid\n        });\n        finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n        if (duplicatePoints) {\n            ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h1 + heightOffset, 1, 1);\n        }\n\n        length = finalPositions.length;\n        var posLength = duplicatePoints ? length + ends.length : length;\n        var combinedPositions = new Float64Array(posLength);\n        combinedPositions.set(finalPositions);\n        if (duplicatePoints) {\n            combinedPositions.set(ends, length);\n        }\n\n        return combinedPositions;\n    };\nexport default PolylineVolumeGeometryLibrary;\n","import Cartesian3 from './Cartesian3.js';\nimport CornerType from './CornerType.js';\nimport defined from './defined.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport PolylinePipeline from './PolylinePipeline.js';\nimport PolylineVolumeGeometryLibrary from './PolylineVolumeGeometryLibrary.js';\nimport Quaternion from './Quaternion.js';\n\n    /**\n     * @private\n     */\n    var CorridorGeometryLibrary = {};\n\n    var scratch1 = new Cartesian3();\n    var scratch2 = new Cartesian3();\n    var scratch3 = new Cartesian3();\n    var scratch4 = new Cartesian3();\n\n    var scaleArray2 = [new Cartesian3(), new Cartesian3()];\n\n    var cartesian1 = new Cartesian3();\n    var cartesian2 = new Cartesian3();\n    var cartesian3 = new Cartesian3();\n    var cartesian4 = new Cartesian3();\n    var cartesian5 = new Cartesian3();\n    var cartesian6 = new Cartesian3();\n    var cartesian7 = new Cartesian3();\n    var cartesian8 = new Cartesian3();\n    var cartesian9 = new Cartesian3();\n    var cartesian10 = new Cartesian3();\n\n    var quaterion = new Quaternion();\n    var rotMatrix = new Matrix3();\n    function computeRoundCorner(cornerPoint, startPoint, endPoint, cornerType, leftIsOutside) {\n        var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, cornerPoint, scratch1), Cartesian3.subtract(endPoint, cornerPoint, scratch2));\n        var granularity = (cornerType === CornerType.BEVELED) ? 1 : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\n\n        var size = granularity * 3;\n        var array = new Array(size);\n\n        array[size - 3] = endPoint.x;\n        array[size - 2] = endPoint.y;\n        array[size - 1] = endPoint.z;\n\n        var m;\n        if (leftIsOutside) {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(cornerPoint, scratch1), angle / granularity, quaterion), rotMatrix);\n        } else {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion), rotMatrix);\n        }\n\n        var index = 0;\n        startPoint = Cartesian3.clone(startPoint, scratch1);\n        for (var i = 0; i < granularity; i++) {\n            startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n            array[index++] = startPoint.x;\n            array[index++] = startPoint.y;\n            array[index++] = startPoint.z;\n        }\n\n        return array;\n    }\n\n    function addEndCaps(calculatedPositions) {\n        var cornerPoint = cartesian1;\n        var startPoint = cartesian2;\n        var endPoint = cartesian3;\n\n        var leftEdge = calculatedPositions[1];\n        startPoint = Cartesian3.fromArray(calculatedPositions[1], leftEdge.length - 3, startPoint);\n        endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\n        cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n        var firstEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\n\n        var length = calculatedPositions.length - 1;\n        var rightEdge = calculatedPositions[length - 1];\n        leftEdge = calculatedPositions[length];\n        startPoint = Cartesian3.fromArray(rightEdge, rightEdge.length - 3, startPoint);\n        endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\n        cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n        var lastEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\n\n        return [firstEndCap, lastEndCap];\n    }\n\n    function computeMiteredCorner(position, leftCornerDirection, lastPoint, leftIsOutside) {\n        var cornerPoint = scratch1;\n        if (leftIsOutside) {\n            cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n        } else {\n            leftCornerDirection = Cartesian3.negate(leftCornerDirection, leftCornerDirection);\n            cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n        }\n        return [cornerPoint.x, cornerPoint.y, cornerPoint.z, lastPoint.x, lastPoint.y, lastPoint.z];\n    }\n\n    function addShiftedPositions(positions, left, scalar, calculatedPositions) {\n        var rightPositions = new Array(positions.length);\n        var leftPositions = new Array(positions.length);\n        var scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\n        var scaledRight = Cartesian3.negate(scaledLeft, scratch2);\n        var rightIndex = 0;\n        var leftIndex = positions.length - 1;\n\n        for (var i = 0; i < positions.length; i += 3) {\n            var pos = Cartesian3.fromArray(positions, i, scratch3);\n            var rightPos = Cartesian3.add(pos, scaledRight, scratch4);\n            rightPositions[rightIndex++] = rightPos.x;\n            rightPositions[rightIndex++] = rightPos.y;\n            rightPositions[rightIndex++] = rightPos.z;\n\n            var leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\n            leftPositions[leftIndex--] = leftPos.z;\n            leftPositions[leftIndex--] = leftPos.y;\n            leftPositions[leftIndex--] = leftPos.x;\n        }\n        calculatedPositions.push(rightPositions, leftPositions);\n\n        return calculatedPositions;\n    }\n\n    /**\n     * @private\n     */\n    CorridorGeometryLibrary.addAttribute = function(attribute, value, front, back) {\n        var x = value.x;\n        var y = value.y;\n        var z = value.z;\n        if (defined(front)) {\n            attribute[front] = x;\n            attribute[front + 1] = y;\n            attribute[front + 2] = z;\n        }\n        if (defined(back)) {\n            attribute[back] = z;\n            attribute[back - 1] = y;\n            attribute[back - 2] = x;\n        }\n    };\n\n    var scratchForwardProjection = new Cartesian3();\n    var scratchBackwardProjection = new Cartesian3();\n\n    /**\n     * @private\n     */\n    CorridorGeometryLibrary.computePositions = function(params) {\n        var granularity = params.granularity;\n        var positions = params.positions;\n        var ellipsoid = params.ellipsoid;\n        var width = params.width / 2;\n        var cornerType = params.cornerType;\n        var saveAttributes = params.saveAttributes;\n        var normal = cartesian1;\n        var forward = cartesian2;\n        var backward = cartesian3;\n        var left = cartesian4;\n        var cornerDirection = cartesian5;\n        var startPoint = cartesian6;\n        var previousPos = cartesian7;\n        var rightPos = cartesian8;\n        var leftPos = cartesian9;\n        var center = cartesian10;\n        var calculatedPositions = [];\n        var calculatedLefts = (saveAttributes) ? [] : undefined;\n        var calculatedNormals = (saveAttributes) ? [] : undefined;\n        var position = positions[0]; //add first point\n        var nextPosition = positions[1];\n\n        forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\n        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n        left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n        if (saveAttributes) {\n            calculatedLefts.push(left.x, left.y, left.z);\n            calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        previousPos = Cartesian3.clone(position, previousPos);\n        position = nextPosition;\n        backward = Cartesian3.negate(forward, backward);\n\n        var subdividedPositions;\n        var corners = [];\n        var i;\n        var length = positions.length;\n        for (i = 1; i < length - 1; i++) { // add middle points and corners\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n            nextPosition = positions[i + 1];\n            forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\n            cornerDirection = Cartesian3.normalize(Cartesian3.add(forward, backward, cornerDirection), cornerDirection);\n\n            var forwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(forward, normal), scratchForwardProjection);\n            Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n            Cartesian3.normalize(forwardProjection, forwardProjection);\n\n            var backwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(backward, normal), scratchBackwardProjection);\n            Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n            Cartesian3.normalize(backwardProjection, backwardProjection);\n\n            var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\n\n            if (doCorner) {\n                cornerDirection = Cartesian3.cross(cornerDirection, normal, cornerDirection);\n                cornerDirection = Cartesian3.cross(normal, cornerDirection, cornerDirection);\n                cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n                var scalar = width / Math.max(0.25, Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1)));\n                var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\n                cornerDirection = Cartesian3.multiplyByScalar(cornerDirection, scalar, cornerDirection);\n                if (leftIsOutside) {\n                    rightPos = Cartesian3.add(position, cornerDirection, rightPos);\n                    center = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, center), center);\n                    leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\n                    scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n                    scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scaleArray2,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n                    if (saveAttributes) {\n                        calculatedLefts.push(left.x, left.y, left.z);\n                        calculatedNormals.push(normal.x, normal.y, normal.z);\n                    }\n                    startPoint = Cartesian3.clone(leftPos, startPoint);\n                    left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n                    leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\n                    previousPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, previousPos), previousPos);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        corners.push({\n                            leftPositions : computeRoundCorner(rightPos, startPoint, leftPos, cornerType, leftIsOutside)\n                        });\n                    } else {\n                        corners.push({\n                            leftPositions : computeMiteredCorner(position, Cartesian3.negate(cornerDirection, cornerDirection), leftPos, leftIsOutside)\n                        });\n                    }\n                } else {\n                    leftPos = Cartesian3.add(position, cornerDirection, leftPos);\n                    center = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, center), center), center);\n                    rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\n                    scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n                    scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scaleArray2,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n                    if (saveAttributes) {\n                        calculatedLefts.push(left.x, left.y, left.z);\n                        calculatedNormals.push(normal.x, normal.y, normal.z);\n                    }\n                    startPoint = Cartesian3.clone(rightPos, startPoint);\n                    left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n                    rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\n                    previousPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, previousPos), previousPos), previousPos);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        corners.push({\n                            rightPositions : computeRoundCorner(leftPos, startPoint, rightPos, cornerType, leftIsOutside)\n                        });\n                    } else {\n                        corners.push({\n                            rightPositions : computeMiteredCorner(position, cornerDirection, rightPos, leftIsOutside)\n                        });\n                    }\n                }\n                backward = Cartesian3.negate(forward, backward);\n            }\n            position = nextPosition;\n        }\n\n        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n            positions: scaleArray2,\n            granularity: granularity,\n            ellipsoid: ellipsoid\n        });\n        calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n        if (saveAttributes) {\n            calculatedLefts.push(left.x, left.y, left.z);\n            calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n\n        var endPositions;\n        if (cornerType === CornerType.ROUNDED) {\n            endPositions = addEndCaps(calculatedPositions);\n        }\n\n        return {\n            positions : calculatedPositions,\n            corners : corners,\n            lefts : calculatedLefts,\n            normals : calculatedNormals,\n            endPositions : endPositions\n        };\n    };\nexport default CorridorGeometryLibrary;\n","import arrayFill from './arrayFill.js';\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CornerType from './CornerType.js';\nimport CorridorGeometryLibrary from './CorridorGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport Rectangle from './Rectangle.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var cartesian1 = new Cartesian3();\n    var cartesian2 = new Cartesian3();\n    var cartesian3 = new Cartesian3();\n    var cartesian4 = new Cartesian3();\n    var cartesian5 = new Cartesian3();\n    var cartesian6 = new Cartesian3();\n\n    var scratch1 = new Cartesian3();\n    var scratch2 = new Cartesian3();\n\n    function scaleToSurface(positions, ellipsoid) {\n        for (var i = 0; i < positions.length; i++) {\n            positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n        }\n        return positions;\n    }\n\n    function addNormals(attr, normal, left, front, back, vertexFormat) {\n        var normals = attr.normals;\n        var tangents = attr.tangents;\n        var bitangents = attr.bitangents;\n        var forward = Cartesian3.normalize(Cartesian3.cross(left, normal, scratch1), scratch1);\n        if (vertexFormat.normal) {\n            CorridorGeometryLibrary.addAttribute(normals, normal, front, back);\n        }\n        if (vertexFormat.tangent) {\n            CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);\n        }\n        if (vertexFormat.bitangent) {\n            CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);\n        }\n    }\n\n    function combine(computedPositions, vertexFormat, ellipsoid) {\n        var positions = computedPositions.positions;\n        var corners = computedPositions.corners;\n        var endPositions = computedPositions.endPositions;\n        var computedLefts = computedPositions.lefts;\n        var computedNormals = computedPositions.normals;\n        var attributes = new GeometryAttributes();\n        var corner;\n        var leftCount = 0;\n        var rightCount = 0;\n        var i;\n        var indicesLength = 0;\n        var length;\n        for (i = 0; i < positions.length; i += 2) {\n            length = positions[i].length - 3;\n            leftCount += length; //subtracting 3 to account for duplicate points at corners\n            indicesLength += length*2;\n            rightCount += positions[i + 1].length - 3;\n        }\n        leftCount += 3; //add back count for end positions\n        rightCount += 3;\n        for (i = 0; i < corners.length; i++) {\n            corner = corners[i];\n            var leftSide = corners[i].leftPositions;\n            if (defined(leftSide)) {\n                length = leftSide.length;\n                leftCount += length;\n                indicesLength += length;\n            } else {\n                length = corners[i].rightPositions.length;\n                rightCount += length;\n                indicesLength += length;\n            }\n        }\n\n        var addEndPositions = defined(endPositions);\n        var endPositionLength;\n        if (addEndPositions) {\n            endPositionLength = endPositions[0].length - 3;\n            leftCount += endPositionLength;\n            rightCount += endPositionLength;\n            endPositionLength /= 3;\n            indicesLength += endPositionLength * 6;\n        }\n        var size = leftCount + rightCount;\n        var finalPositions = new Float64Array(size);\n        var normals = (vertexFormat.normal) ? new Float32Array(size) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(size) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size) : undefined;\n        var attr = {\n            normals : normals,\n            tangents : tangents,\n            bitangents : bitangents\n        };\n        var front = 0;\n        var back = size - 1;\n        var UL, LL, UR, LR;\n        var normal = cartesian1;\n        var left = cartesian2;\n        var rightPos, leftPos;\n        var halfLength = endPositionLength / 2;\n\n        var indices = IndexDatatype.createTypedArray(size / 3, indicesLength);\n        var index = 0;\n        if (addEndPositions) { // add rounded end\n            leftPos = cartesian3;\n            rightPos = cartesian4;\n            var firstEndPositions = endPositions[0];\n            normal = Cartesian3.fromArray(computedNormals, 0, normal);\n            left = Cartesian3.fromArray(computedLefts, 0, left);\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n                addNormals(attr, normal, left, front, back, vertexFormat);\n\n                LL = front / 3;\n                LR = LL + 1;\n                UL = (back - 2) / 3;\n                UR = UL - 1;\n                indices[index++] = UL;\n                indices[index++] = LL;\n                indices[index++] = UR;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n        }\n\n        var posIndex = 0;\n        var compIndex = 0;\n        var rightEdge = positions[posIndex++]; //add first two edges\n        var leftEdge = positions[posIndex++];\n        finalPositions.set(rightEdge, front);\n        finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n        left = Cartesian3.fromArray(computedLefts, compIndex, left);\n        var rightNormal;\n        var leftNormal;\n        length = leftEdge.length - 3;\n        for (i = 0; i < length; i += 3) {\n            rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, i, scratch1), scratch1);\n            leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - i, scratch2), scratch2);\n            normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n            addNormals(attr, normal, left, front, back, vertexFormat);\n\n            LL = front / 3;\n            LR = LL + 1;\n            UL = (back - 2) / 3;\n            UR = UL - 1;\n            indices[index++] = UL;\n            indices[index++] = LL;\n            indices[index++] = UR;\n            indices[index++] = UR;\n            indices[index++] = LL;\n            indices[index++] = LR;\n\n            front += 3;\n            back -= 3;\n        }\n\n        rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, length, scratch1), scratch1);\n        leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length, scratch2), scratch2);\n        normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n        compIndex += 3;\n        for (i = 0; i < corners.length; i++) {\n            var j;\n            corner = corners[i];\n            var l = corner.leftPositions;\n            var r = corner.rightPositions;\n            var pivot;\n            var start;\n            var outsidePoint = cartesian6;\n            var previousPoint = cartesian3;\n            var nextPoint = cartesian4;\n            normal = Cartesian3.fromArray(computedNormals, compIndex, normal);\n            if (defined(l)) {\n                addNormals(attr, normal, left, undefined, back, vertexFormat);\n                back -= 3;\n                pivot = LR;\n                start = UR;\n                for (j = 0; j < l.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n                    indices[index++] = pivot;\n                    indices[index++] = start - j - 1;\n                    indices[index++] = start - j;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);\n                    previousPoint = Cartesian3.fromArray(finalPositions, (start - j - 1) * 3, previousPoint);\n                    nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);\n                    left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\n                    addNormals(attr, normal, left, undefined, back, vertexFormat);\n                    back -= 3;\n                }\n                outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\n                previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start) * 3, previousPoint), outsidePoint, previousPoint);\n                nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint), outsidePoint, nextPoint);\n                left = Cartesian3.normalize(Cartesian3.add(previousPoint, nextPoint, left), left);\n                addNormals(attr, normal, left, front, undefined, vertexFormat);\n                front += 3;\n            } else {\n                addNormals(attr, normal, left, front, undefined, vertexFormat);\n                front += 3;\n                pivot = UR;\n                start = LR;\n                for (j = 0; j < r.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n                    indices[index++] = pivot;\n                    indices[index++] = start + j;\n                    indices[index++] = start + j + 1;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);\n                    previousPoint = Cartesian3.fromArray(finalPositions, pivot * 3, previousPoint);\n                    nextPoint = Cartesian3.fromArray(finalPositions, (start + j) * 3, nextPoint);\n                    left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\n                    addNormals(attr, normal, left, front, undefined, vertexFormat);\n                    front += 3;\n                }\n                outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\n                previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint), outsidePoint, previousPoint);\n                nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, start * 3, nextPoint), outsidePoint, nextPoint);\n                left = Cartesian3.normalize(Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left), left);\n                addNormals(attr, normal, left, undefined, back, vertexFormat);\n                back -= 3;\n            }\n            rightEdge = positions[posIndex++];\n            leftEdge = positions[posIndex++];\n            rightEdge.splice(0, 3); //remove duplicate points added by corner\n            leftEdge.splice(leftEdge.length - 3, 3);\n            finalPositions.set(rightEdge, front);\n            finalPositions.set(leftEdge, back - leftEdge.length + 1);\n            length = leftEdge.length - 3;\n\n            compIndex += 3;\n            left = Cartesian3.fromArray(computedLefts, compIndex, left);\n            for (j = 0; j < leftEdge.length; j += 3) {\n                rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, j, scratch1), scratch1);\n                leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - j, scratch2), scratch2);\n                normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n                addNormals(attr, normal, left, front, back, vertexFormat);\n\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = LL;\n                indices[index++] = UR;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n            front -= 3;\n            back += 3;\n        }\n        normal = Cartesian3.fromArray(computedNormals, computedNormals.length - 3, normal);\n        addNormals(attr, normal, left, front, back, vertexFormat);\n\n        if (addEndPositions) { // add rounded end\n            front += 3;\n            back -= 3;\n            leftPos = cartesian3;\n            rightPos = cartesian4;\n            var lastEndPositions = endPositions[1];\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n                addNormals(attr, normal, left, front, back, vertexFormat);\n\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = LL;\n                indices[index++] = UR;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n        }\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : finalPositions\n        });\n\n        if (vertexFormat.st) {\n            var st = new Float32Array(size / 3 * 2);\n            var rightSt;\n            var leftSt;\n            var stIndex = 0;\n            if (addEndPositions) {\n                leftCount /= 3;\n                rightCount /= 3;\n                var theta = Math.PI / (endPositionLength + 1);\n                leftSt = 1 / (leftCount - endPositionLength + 1);\n                rightSt = 1 / (rightCount - endPositionLength + 1);\n                var a;\n                var halfEndPos = endPositionLength / 2;\n                for (i = halfEndPos + 1; i < endPositionLength + 1; i++) { // lower left rounded end\n                    a = CesiumMath.PI_OVER_TWO + theta * i;\n                    st[stIndex++] = rightSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n                for (i = 1; i < rightCount - endPositionLength + 1; i++) { // bottom edge\n                    st[stIndex++] = i * rightSt;\n                    st[stIndex++] = 0;\n                }\n                for (i = endPositionLength; i > halfEndPos; i--) { // lower right rounded end\n                    a = CesiumMath.PI_OVER_TWO - i * theta;\n                    st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n                for (i = halfEndPos; i > 0; i--) { // upper right rounded end\n                    a = CesiumMath.PI_OVER_TWO - theta * i;\n                    st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n                for (i = leftCount - endPositionLength; i > 0; i--) { // top edge\n                    st[stIndex++] = i * leftSt;\n                    st[stIndex++] = 1;\n                }\n                for (i = 1; i < halfEndPos + 1; i++) { // upper left rounded end\n                    a = CesiumMath.PI_OVER_TWO + theta * i;\n                    st[stIndex++] = leftSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n            } else {\n                leftCount /= 3;\n                rightCount /= 3;\n                leftSt = 1 / (leftCount - 1);\n                rightSt = 1 / (rightCount - 1);\n                for (i = 0; i < rightCount; i++) { // bottom edge\n                    st[stIndex++] = i * rightSt;\n                    st[stIndex++] = 0;\n                }\n                for (i = leftCount; i > 0; i--) { // top edge\n                    st[stIndex++] = (i - 1) * leftSt;\n                    st[stIndex++] = 1;\n                }\n            }\n\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : st\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attr.normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attr.tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attr.bitangents\n            });\n        }\n\n        return {\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    function extrudedAttributes(attributes, vertexFormat) {\n        if (!vertexFormat.normal && !vertexFormat.tangent && !vertexFormat.bitangent && !vertexFormat.st) {\n            return attributes;\n        }\n        var positions = attributes.position.values;\n        var topNormals;\n        var topBitangents;\n        if (vertexFormat.normal || vertexFormat.bitangent) {\n            topNormals = attributes.normal.values;\n            topBitangents = attributes.bitangent.values;\n        }\n        var size = attributes.position.values.length / 18;\n        var threeSize = size * 3;\n        var twoSize = size * 2;\n        var sixSize = threeSize * 2;\n        var i;\n        if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {\n            var normals = (vertexFormat.normal) ? new Float32Array(threeSize * 6) : undefined;\n            var tangents = (vertexFormat.tangent) ? new Float32Array(threeSize * 6) : undefined;\n            var bitangents = (vertexFormat.bitangent) ? new Float32Array(threeSize * 6) : undefined;\n            var topPosition = cartesian1;\n            var bottomPosition = cartesian2;\n            var previousPosition = cartesian3;\n            var normal = cartesian4;\n            var tangent = cartesian5;\n            var bitangent = cartesian6;\n            var attrIndex = sixSize;\n            for (i = 0; i < threeSize; i += 3) {\n                var attrIndexOffset = attrIndex + sixSize;\n                topPosition      = Cartesian3.fromArray(positions, i, topPosition);\n                bottomPosition   = Cartesian3.fromArray(positions, i + threeSize, bottomPosition);\n                previousPosition = Cartesian3.fromArray(positions, (i + 3) % threeSize, previousPosition);\n                bottomPosition   = Cartesian3.subtract(bottomPosition,   topPosition, bottomPosition);\n                previousPosition = Cartesian3.subtract(previousPosition, topPosition, previousPosition);\n                normal = Cartesian3.normalize(Cartesian3.cross(bottomPosition, previousPosition, normal), normal);\n                if (vertexFormat.normal) {\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset + 3);\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);\n                }\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\n                    bitangent = Cartesian3.fromArray(topNormals, i, bitangent);\n                    if (vertexFormat.bitangent) {\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset);\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset + 3);\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex);\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex + 3);\n                    }\n\n                    if (vertexFormat.tangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset + 3);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex + 3);\n                    }\n                }\n                attrIndex += 6;\n            }\n\n            if (vertexFormat.normal) {\n                normals.set(topNormals); //top\n                for (i = 0; i < threeSize; i += 3) { //bottom normals\n                    normals[i + threeSize] = -topNormals[i];\n                    normals[i + threeSize + 1] = -topNormals[i + 1];\n                    normals[i + threeSize + 2] = -topNormals[i + 2];\n                }\n                attributes.normal.values = normals;\n            } else {\n                attributes.normal = undefined;\n            }\n\n            if (vertexFormat.bitangent) {\n                bitangents.set(topBitangents); //top\n                bitangents.set(topBitangents, threeSize); //bottom\n                attributes.bitangent.values = bitangents;\n            } else {\n                attributes.bitangent = undefined;\n            }\n\n            if (vertexFormat.tangent) {\n                var topTangents = attributes.tangent.values;\n                tangents.set(topTangents); //top\n                tangents.set(topTangents, threeSize); //bottom\n                attributes.tangent.values = tangents;\n            }\n        }\n        if (vertexFormat.st) {\n            var topSt = attributes.st.values;\n            var st = new Float32Array(twoSize * 6);\n            st.set(topSt); //top\n            st.set(topSt, twoSize); //bottom\n            var index = twoSize * 2;\n\n            for ( var j = 0; j < 2; j++) {\n                st[index++] = topSt[0];\n                st[index++] = topSt[1];\n                for (i = 2; i < twoSize; i += 2) {\n                    var s = topSt[i];\n                    var t = topSt[i + 1];\n                    st[index++] = s;\n                    st[index++] = t;\n                    st[index++] = s;\n                    st[index++] = t;\n                }\n                st[index++] = topSt[0];\n                st[index++] = topSt[1];\n            }\n            attributes.st.values = st;\n        }\n\n        return attributes;\n    }\n\n    function addWallPositions(positions, index, wallPositions) {\n        wallPositions[index++] = positions[0];\n        wallPositions[index++] = positions[1];\n        wallPositions[index++] = positions[2];\n        for ( var i = 3; i < positions.length; i += 3) {\n            var x = positions[i];\n            var y = positions[i + 1];\n            var z = positions[i + 2];\n            wallPositions[index++] = x;\n            wallPositions[index++] = y;\n            wallPositions[index++] = z;\n            wallPositions[index++] = x;\n            wallPositions[index++] = y;\n            wallPositions[index++] = z;\n        }\n        wallPositions[index++] = positions[0];\n        wallPositions[index++] = positions[1];\n        wallPositions[index++] = positions[2];\n\n        return wallPositions;\n    }\n\n    function computePositionsExtruded(params, vertexFormat) {\n        var topVertexFormat = new VertexFormat({\n            position : vertexFormat.position,\n            normal : (vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume),\n            tangent : vertexFormat.tangent,\n            bitangent : (vertexFormat.normal || vertexFormat.bitangent),\n            st : vertexFormat.st\n        });\n        var ellipsoid = params.ellipsoid;\n        var computedPositions = CorridorGeometryLibrary.computePositions(params);\n        var attr = combine(computedPositions, topVertexFormat, ellipsoid);\n        var height = params.height;\n        var extrudedHeight = params.extrudedHeight;\n        var attributes = attr.attributes;\n        var indices = attr.indices;\n        var positions = attributes.position.values;\n        var length = positions.length;\n        var newPositions = new Float64Array(length * 6);\n        var extrudedPositions = new Float64Array(length);\n        extrudedPositions.set(positions);\n        var wallPositions = new Float64Array(length * 4);\n\n        positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);\n        wallPositions = addWallPositions(positions, 0, wallPositions);\n        extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);\n        wallPositions = addWallPositions(extrudedPositions, length * 2, wallPositions);\n        newPositions.set(positions);\n        newPositions.set(extrudedPositions, length);\n        newPositions.set(wallPositions, length * 2);\n        attributes.position.values = newPositions;\n\n        attributes = extrudedAttributes(attributes, vertexFormat);\n        var i;\n        var size = length / 3;\n        if (params.shadowVolume) {\n            var topNormals = attributes.normal.values;\n            length = topNormals.length;\n\n            var extrudeNormals = new Float32Array(length * 6);\n            for (i = 0; i < length; i ++) {\n                topNormals[i] = -topNormals[i];\n            }\n            //only get normals for bottom layer that's going to be pushed down\n            extrudeNormals.set(topNormals, length); //bottom face\n            extrudeNormals = addWallPositions(topNormals, length*4, extrudeNormals); //bottom wall\n            attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n            if (!vertexFormat.normal) {\n                attributes.normal = undefined;\n            }\n        }\n        if (defined(params.offsetAttribute)) {\n            var applyOffset = new Uint8Array(size * 6);\n            if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                applyOffset = arrayFill(applyOffset, 1, 0, size); // top face\n                applyOffset = arrayFill(applyOffset, 1, size*2, size * 4); // top wall\n            } else {\n                var applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                applyOffset = arrayFill(applyOffset, applyOffsetValue);\n            }\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        var iLength = indices.length;\n        var twoSize = size + size;\n        var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, iLength * 2 + twoSize * 3);\n        newIndices.set(indices);\n        var index = iLength;\n        for (i = 0; i < iLength; i += 3) { // bottom indices\n            var v0 = indices[i];\n            var v1 = indices[i + 1];\n            var v2 = indices[i + 2];\n            newIndices[index++] = v2 + size;\n            newIndices[index++] = v1 + size;\n            newIndices[index++] = v0 + size;\n        }\n\n        var UL, LL, UR, LR;\n\n        for (i = 0; i < twoSize; i += 2) { //wall indices\n            UL = i + twoSize;\n            LL = UL + twoSize;\n            UR = UL + 1;\n            LR = LL + 1;\n            newIndices[index++] = UL;\n            newIndices[index++] = LL;\n            newIndices[index++] = UR;\n            newIndices[index++] = UR;\n            newIndices[index++] = LL;\n            newIndices[index++] = LR;\n        }\n\n        return {\n            attributes : attributes,\n            indices : newIndices\n        };\n    }\n\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartographic = new Cartographic();\n\n    function computeOffsetPoints(position1, position2, ellipsoid, halfWidth, min, max) {\n        // Compute direction of offset the point\n        var direction = Cartesian3.subtract(position2, position1, scratchCartesian1);\n        Cartesian3.normalize(direction, direction);\n        var normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);\n        var offsetDirection = Cartesian3.cross(direction, normal, scratchCartesian1);\n        Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);\n\n        var minLat = min.latitude;\n        var minLon = min.longitude;\n        var maxLat = max.latitude;\n        var maxLon = max.longitude;\n\n        // Compute 2 offset points\n        Cartesian3.add(position1, offsetDirection, scratchCartesian2);\n        ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n        var lat = scratchCartographic.latitude;\n        var lon = scratchCartographic.longitude;\n        minLat = Math.min(minLat, lat);\n        minLon = Math.min(minLon, lon);\n        maxLat = Math.max(maxLat, lat);\n        maxLon = Math.max(maxLon, lon);\n\n        Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);\n        ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n        lat = scratchCartographic.latitude;\n        lon = scratchCartographic.longitude;\n        minLat = Math.min(minLat, lat);\n        minLon = Math.min(minLon, lon);\n        maxLat = Math.max(maxLat, lat);\n        maxLon = Math.max(maxLon, lon);\n\n        min.latitude = minLat;\n        min.longitude = minLon;\n        max.latitude = maxLat;\n        max.longitude = maxLon;\n    }\n\n    var scratchCartesianOffset = new Cartesian3();\n    var scratchCartesianEnds = new Cartesian3();\n    var scratchCartographicMin = new Cartographic();\n    var scratchCartographicMax = new Cartographic();\n\n    function computeRectangle(positions, ellipsoid, width, cornerType, result) {\n        positions = scaleToSurface(positions, ellipsoid);\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n        var length = cleanPositions.length;\n        if (length < 2 || width <= 0) {\n            return new Rectangle();\n        }\n        var halfWidth = width * 0.5;\n\n        scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;\n        scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;\n        scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;\n        scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;\n\n        var lat, lon;\n        if (cornerType === CornerType.ROUNDED) {\n            // Compute start cap\n            var first = cleanPositions[0];\n            Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);\n            Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n            Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\n            Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);\n\n            ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\n            lat = scratchCartographic.latitude;\n            lon = scratchCartographic.longitude;\n            scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\n            scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\n            scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\n            scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\n        }\n\n        // Compute the rest\n        for (var i = 0; i < length-1; ++i) {\n            computeOffsetPoints(cleanPositions[i], cleanPositions[i+1], ellipsoid, halfWidth,\n                scratchCartographicMin, scratchCartographicMax);\n        }\n\n        // Compute ending point\n        var last = cleanPositions[length-1];\n        Cartesian3.subtract(last, cleanPositions[length-2], scratchCartesianOffset);\n        Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n        Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\n        Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);\n        computeOffsetPoints(last, scratchCartesianEnds, ellipsoid, halfWidth,\n            scratchCartographicMin, scratchCartographicMax);\n\n        if (cornerType === CornerType.ROUNDED) {\n            // Compute end cap\n            ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\n            lat = scratchCartographic.latitude;\n            lon = scratchCartographic.longitude;\n            scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\n            scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\n            scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\n            scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\n        }\n\n        var rectangle = defined(result) ? result : new Rectangle();\n        rectangle.north = scratchCartographicMax.latitude;\n        rectangle.south = scratchCartographicMin.latitude;\n        rectangle.east = scratchCartographicMax.longitude;\n        rectangle.west = scratchCartographicMin.longitude;\n\n        return rectangle;\n    }\n\n    /**\n     * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias CorridorGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n     * @param {Number} options.width The distance between the edges of the corridor in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see CorridorGeometry.createGeometry\n     * @see Packable\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}\n     *\n     * @example\n     * var corridor = new Cesium.CorridorGeometry({\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n     *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n     *   width : 100000\n     * });\n     */\n    function CorridorGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var width = options.width;\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._positions = positions;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n        this._width = width;\n        this._height = Math.max(height, extrudedHeight);\n        this._extrudedHeight = Math.min(height, extrudedHeight);\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createCorridorGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n        this._rectangle = undefined;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CorridorGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CorridorGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._width;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        positions : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        width : undefined,\n        height : undefined,\n        extrudedHeight : undefined,\n        cornerType : undefined,\n        granularity : undefined,\n        shadowVolume: undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CorridorGeometry} [result] The object into which to store the result.\n     * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.\n     */\n    CorridorGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var width = array[startingIndex++];\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.width = width;\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            scratchOptions.shadowVolume = shadowVolume;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new CorridorGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._width = width;\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the bounding rectangle given the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n     * @param {Number} options.width The distance between the edges of the corridor in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     * @param {Rectangle} [result] An object in which to store the result.\n     *\n     * @returns {Rectangle} The result rectangle.\n     */\n    CorridorGeometry.computeRectangle = function(options, result) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var width = options.width;\n\n        \n\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n\n        return computeRectangle(positions, ellipsoid, width, cornerType, result);\n    };\n\n    /**\n     * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CorridorGeometry} corridorGeometry A description of the corridor.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CorridorGeometry.createGeometry = function(corridorGeometry) {\n        var positions = corridorGeometry._positions;\n        var width = corridorGeometry._width;\n        var ellipsoid = corridorGeometry._ellipsoid;\n\n        positions = scaleToSurface(positions, ellipsoid);\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n\n        if ((cleanPositions.length < 2) || (width <= 0)) {\n            return;\n        }\n\n        var height = corridorGeometry._height;\n        var extrudedHeight = corridorGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        var vertexFormat = corridorGeometry._vertexFormat;\n        var params = {\n            ellipsoid : ellipsoid,\n            positions : cleanPositions,\n            width : width,\n            cornerType : corridorGeometry._cornerType,\n            granularity : corridorGeometry._granularity,\n            saveAttributes: true\n        };\n        var attr;\n        if (extrude) {\n            params.height = height;\n            params.extrudedHeight = extrudedHeight;\n            params.shadowVolume = corridorGeometry._shadowVolume;\n            params.offsetAttribute = corridorGeometry._offsetAttribute;\n            attr = computePositionsExtruded(params, vertexFormat);\n        } else {\n            var computedPositions = CorridorGeometryLibrary.computePositions(params);\n            attr = combine(computedPositions, vertexFormat, ellipsoid);\n            attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);\n\n            if (defined(corridorGeometry._offsetAttribute)) {\n                var applyOffsetValue = corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                var length = attr.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                arrayFill(applyOffset, applyOffsetValue);\n                attr.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n        var attributes = attr.attributes;\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);\n        if (!vertexFormat.position) {\n            attr.attributes.position.values = undefined;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : attr.indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : corridorGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    CorridorGeometry.createShadowVolume = function(corridorGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = corridorGeometry._granularity;\n        var ellipsoid = corridorGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new CorridorGeometry({\n            positions : corridorGeometry._positions,\n            width : corridorGeometry._width,\n            cornerType : corridorGeometry._cornerType,\n            ellipsoid : ellipsoid,\n            granularity : granularity,\n            extrudedHeight : minHeight,\n            height : maxHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume: true\n        });\n    };\n\n    defineProperties(CorridorGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rectangle)) {\n                    this._rectangle = computeRectangle(this._positions, this._ellipsoid, this._width, this._cornerType);\n                }\n                return this._rectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.\n         *\n         * Corridors don't support stRotation,\n         * so just return the corners of the original system.\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                return [0, 0, 0, 1, 1, 0];\n            }\n        }\n    });\nexport default CorridorGeometry;\n","import arrayFill from './arrayFill.js';\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CornerType from './CornerType.js';\nimport CorridorGeometryLibrary from './CorridorGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    var cartesian1 = new Cartesian3();\n    var cartesian2 = new Cartesian3();\n    var cartesian3 = new Cartesian3();\n\n    function scaleToSurface(positions, ellipsoid) {\n        for (var i = 0; i < positions.length; i++) {\n            positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n        }\n        return positions;\n    }\n\n    function combine(computedPositions, cornerType) {\n        var wallIndices = [];\n        var positions = computedPositions.positions;\n        var corners = computedPositions.corners;\n        var endPositions = computedPositions.endPositions;\n        var attributes = new GeometryAttributes();\n        var corner;\n        var leftCount = 0;\n        var rightCount = 0;\n        var i;\n        var indicesLength = 0;\n        var length;\n        for (i = 0; i < positions.length; i += 2) {\n            length = positions[i].length - 3;\n            leftCount += length; //subtracting 3 to account for duplicate points at corners\n            indicesLength += length / 3 * 4;\n            rightCount += positions[i + 1].length - 3;\n        }\n        leftCount += 3; //add back count for end positions\n        rightCount += 3;\n        for (i = 0; i < corners.length; i++) {\n            corner = corners[i];\n            var leftSide = corners[i].leftPositions;\n            if (defined(leftSide)) {\n                length = leftSide.length;\n                leftCount += length;\n                indicesLength += length / 3 * 2;\n            } else {\n                length = corners[i].rightPositions.length;\n                rightCount += length;\n                indicesLength += length / 3 * 2;\n            }\n        }\n\n        var addEndPositions = defined(endPositions);\n        var endPositionLength;\n        if (addEndPositions) {\n            endPositionLength = endPositions[0].length - 3;\n            leftCount += endPositionLength;\n            rightCount += endPositionLength;\n            endPositionLength /= 3;\n            indicesLength += endPositionLength * 4;\n        }\n        var size = leftCount + rightCount;\n        var finalPositions = new Float64Array(size);\n        var front = 0;\n        var back = size - 1;\n        var UL, LL, UR, LR;\n        var rightPos, leftPos;\n        var halfLength = endPositionLength / 2;\n\n        var indices = IndexDatatype.createTypedArray(size / 3, indicesLength + 4);\n        var index = 0;\n\n        indices[index++] = front / 3;\n        indices[index++] = (back - 2) / 3;\n        if (addEndPositions) { // add rounded end\n            wallIndices.push(front / 3);\n            leftPos = cartesian1;\n            rightPos = cartesian2;\n            var firstEndPositions = endPositions[0];\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n\n                LL = front / 3;\n                LR = LL + 1;\n                UL = (back - 2) / 3;\n                UR = UL - 1;\n                indices[index++] = UL;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n        }\n\n        var posIndex = 0;\n        var rightEdge = positions[posIndex++]; //add first two edges\n        var leftEdge = positions[posIndex++];\n        finalPositions.set(rightEdge, front);\n        finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n        length = leftEdge.length - 3;\n        wallIndices.push(front / 3, (back - 2) / 3);\n        for (i = 0; i < length; i += 3) {\n            LL = front / 3;\n            LR = LL + 1;\n            UL = (back - 2) / 3;\n            UR = UL - 1;\n            indices[index++] = UL;\n            indices[index++] = UR;\n            indices[index++] = LL;\n            indices[index++] = LR;\n\n            front += 3;\n            back -= 3;\n        }\n\n        for (i = 0; i < corners.length; i++) {\n            var j;\n            corner = corners[i];\n            var l = corner.leftPositions;\n            var r = corner.rightPositions;\n            var start;\n            var outsidePoint = cartesian3;\n            if (defined(l)) {\n                back -= 3;\n                start = UR;\n                wallIndices.push(LR);\n                for (j = 0; j < l.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n                    indices[index++] = start - j - 1;\n                    indices[index++] = start - j;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);\n                    back -= 3;\n                }\n                wallIndices.push(start - Math.floor(l.length / 6));\n                if (cornerType === CornerType.BEVELED) {\n                    wallIndices.push((back - 2) / 3 + 1);\n                }\n                front += 3;\n            } else {\n                front += 3;\n                start = LR;\n                wallIndices.push(UR);\n                for (j = 0; j < r.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n                    indices[index++] = start + j;\n                    indices[index++] = start + j + 1;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);\n                    front += 3;\n                }\n                wallIndices.push(start + Math.floor(r.length / 6));\n                if (cornerType === CornerType.BEVELED) {\n                    wallIndices.push(front / 3 - 1);\n                }\n                back -= 3;\n            }\n            rightEdge = positions[posIndex++];\n            leftEdge = positions[posIndex++];\n            rightEdge.splice(0, 3); //remove duplicate points added by corner\n            leftEdge.splice(leftEdge.length - 3, 3);\n            finalPositions.set(rightEdge, front);\n            finalPositions.set(leftEdge, back - leftEdge.length + 1);\n            length = leftEdge.length - 3;\n\n            for (j = 0; j < leftEdge.length; j += 3) {\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n                front += 3;\n                back -= 3;\n            }\n            front -= 3;\n            back += 3;\n            wallIndices.push(front / 3, (back - 2) / 3);\n        }\n\n        if (addEndPositions) { // add rounded end\n            front += 3;\n            back -= 3;\n            leftPos = cartesian1;\n            rightPos = cartesian2;\n            var lastEndPositions = endPositions[1];\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n\n            wallIndices.push(front / 3);\n        } else {\n            wallIndices.push(front / 3, (back - 2) / 3);\n        }\n        indices[index++] = front / 3;\n        indices[index++] = (back - 2) / 3;\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : finalPositions\n        });\n\n        return {\n            attributes : attributes,\n            indices : indices,\n            wallIndices : wallIndices\n        };\n    }\n\n    function computePositionsExtruded(params) {\n        var ellipsoid = params.ellipsoid;\n        var computedPositions = CorridorGeometryLibrary.computePositions(params);\n        var attr = combine(computedPositions, params.cornerType);\n        var wallIndices = attr.wallIndices;\n        var height = params.height;\n        var extrudedHeight = params.extrudedHeight;\n        var attributes = attr.attributes;\n        var indices = attr.indices;\n        var positions = attributes.position.values;\n        var length = positions.length;\n        var extrudedPositions = new Float64Array(length);\n        extrudedPositions.set(positions);\n        var newPositions = new Float64Array(length * 2);\n\n        positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);\n        extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);\n        newPositions.set(positions);\n        newPositions.set(extrudedPositions, length);\n        attributes.position.values = newPositions;\n\n        length /= 3;\n        if (defined(params.offsetAttribute)) {\n            var applyOffset = new Uint8Array(length * 2);\n            if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                applyOffset = arrayFill(applyOffset, 1, 0, length);\n            } else {\n                var applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                applyOffset = arrayFill(applyOffset, applyOffsetValue);\n            }\n\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        var i;\n        var iLength = indices.length;\n        var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, (iLength + wallIndices.length) * 2);\n        newIndices.set(indices);\n        var index = iLength;\n        for (i = 0; i < iLength; i += 2) { // bottom indices\n            var v0 = indices[i];\n            var v1 = indices[i + 1];\n            newIndices[index++] = v0 + length;\n            newIndices[index++] = v1 + length;\n        }\n\n        var UL, LL;\n        for (i = 0; i < wallIndices.length; i++) { //wall indices\n            UL = wallIndices[i];\n            LL = UL + length;\n            newIndices[index++] = UL;\n            newIndices[index++] = LL;\n        }\n\n        return {\n            attributes : attributes,\n            indices : newIndices\n        };\n    }\n\n    /**\n     * A description of a corridor outline.\n     *\n     * @alias CorridorOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor outline.\n     * @param {Number} options.width The distance between the edges of the corridor outline.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.height=0] The distance in meters between the positions and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the extruded face and the ellipsoid surface.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see CorridorOutlineGeometry.createGeometry\n     *\n     * @example\n     * var corridor = new Cesium.CorridorOutlineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n     *   width : 100000\n     * });\n     */\n    function CorridorOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var width = options.width;\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._positions = positions;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._width = width;\n        this._height = Math.max(height, extrudedHeight);\n        this._extrudedHeight = Math.min(height, extrudedHeight);\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createCorridorOutlineGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + 6;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CorridorOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CorridorOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._width;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        positions : undefined,\n        ellipsoid : scratchEllipsoid,\n        width : undefined,\n        height : undefined,\n        extrudedHeight : undefined,\n        cornerType : undefined,\n        granularity : undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CorridorOutlineGeometry} [result] The object into which to store the result.\n     * @returns {CorridorOutlineGeometry} The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.\n     */\n    CorridorOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var width = array[startingIndex++];\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.width = width;\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n            return new CorridorOutlineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._width = width;\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CorridorOutlineGeometry} corridorOutlineGeometry A description of the corridor.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CorridorOutlineGeometry.createGeometry = function(corridorOutlineGeometry) {\n        var positions = corridorOutlineGeometry._positions;\n        var width = corridorOutlineGeometry._width;\n        var ellipsoid = corridorOutlineGeometry._ellipsoid;\n\n        positions = scaleToSurface(positions, ellipsoid);\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n\n        if ((cleanPositions.length < 2) || (width <= 0)) {\n            return;\n        }\n\n        var height = corridorOutlineGeometry._height;\n        var extrudedHeight = corridorOutlineGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        var params = {\n            ellipsoid : ellipsoid,\n            positions : cleanPositions,\n            width : width,\n            cornerType : corridorOutlineGeometry._cornerType,\n            granularity : corridorOutlineGeometry._granularity,\n            saveAttributes : false\n        };\n        var attr;\n        if (extrude) {\n            params.height = height;\n            params.extrudedHeight = extrudedHeight;\n            params.offsetAttribute = corridorOutlineGeometry._offsetAttribute;\n            attr = computePositionsExtruded(params);\n        } else {\n            var computedPositions = CorridorGeometryLibrary.computePositions(params);\n            attr = combine(computedPositions, params.cornerType);\n            attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);\n\n            if (defined(corridorOutlineGeometry._offsetAttribute)) {\n                var length = attr.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = corridorOutlineGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                attr.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n        var attributes = attr.attributes;\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);\n\n        return new Geometry({\n            attributes : attributes,\n            indices : attr.indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : corridorOutlineGeometry._offsetAttribute\n        });\n    };\nexport default CorridorOutlineGeometry;\n","import Check from '../Core/Check.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport GeometryOffsetAttribute from '../Core/GeometryOffsetAttribute.js';\nimport oneTimeWarning from '../Core/oneTimeWarning.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport CallbackProperty from './CallbackProperty.js';\nimport ConstantProperty from './ConstantProperty.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport TerrainOffsetProperty from './TerrainOffsetProperty.js';\n\n    var defaultZIndex = new ConstantProperty(0);\n\n    /**\n     * An abstract class for updating ground geometry entities.\n     * @constructor\n     * @alias GroundGeometryUpdater\n     * @param {Object} options An object with the following properties:\n     * @param {Entity} options.entity The entity containing the geometry to be visualized.\n     * @param {Scene} options.scene The scene where visualization is taking place.\n     * @param {Object} options.geometryOptions Options for the geometry\n     * @param {String} options.geometryPropertyName The geometry property name\n     * @param {String[]} options.observedPropertyNames The entity properties this geometry cares about\n     */\n    function GroundGeometryUpdater(options) {\n        GeometryUpdater.call(this, options);\n\n        this._zIndex = 0;\n        this._terrainOffsetProperty = undefined;\n    }\n\n    if (defined(Object.create)) {\n        GroundGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        GroundGeometryUpdater.prototype.constructor = GroundGeometryUpdater;\n    }\n\n    defineProperties(GroundGeometryUpdater.prototype, {\n        /**\n         * Gets the zindex\n         * @type {Number}\n         * @memberof GroundGeometryUpdater.prototype\n         * @readonly\n         */\n        zIndex: {\n            get: function() {\n                return this._zIndex;\n            }\n        },\n\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof GroundGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty: {\n            get: function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    GroundGeometryUpdater.prototype._isOnTerrain = function(entity, geometry) {\n        return this._fillEnabled && !defined(geometry.height) && !defined(geometry.extrudedHeight) && GroundPrimitive.isSupported(this._scene);\n    };\n\n    GroundGeometryUpdater.prototype._getIsClosed = function(options) {\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        return height === 0 || (defined(extrudedHeight) && extrudedHeight !== height);\n    };\n\n    GroundGeometryUpdater.prototype._computeCenter = DeveloperError.throwInstantiationError;\n\n    GroundGeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        GeometryUpdater.prototype._onEntityPropertyChanged.call(this, entity, propertyName, newValue, oldValue);\n        if (this._observedPropertyNames.indexOf(propertyName) === -1) {\n            return;\n        }\n\n        var geometry = this._entity[this._geometryPropertyName];\n        if (!defined(geometry)) {\n            return;\n        }\n        if (defined(geometry.zIndex) && (defined(geometry.height) || defined(geometry.extrudedHeight))) {\n            oneTimeWarning(oneTimeWarning.geometryZIndex);\n        }\n\n        this._zIndex = defaultValue(geometry.zIndex, defaultZIndex);\n\n        if (defined(this._terrainOffsetProperty)) {\n            this._terrainOffsetProperty.destroy();\n            this._terrainOffsetProperty = undefined;\n        }\n\n        var heightReferenceProperty = geometry.heightReference;\n        var extrudedHeightReferenceProperty = geometry.extrudedHeightReference;\n\n        if (defined(heightReferenceProperty) || defined(extrudedHeightReferenceProperty)) {\n            var centerPosition = new CallbackProperty(this._computeCenter.bind(this), !this._dynamic);\n            this._terrainOffsetProperty = new TerrainOffsetProperty(this._scene, centerPosition, heightReferenceProperty, extrudedHeightReferenceProperty);\n        }\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    GroundGeometryUpdater.prototype.destroy = function() {\n        if (defined(this._terrainOffsetProperty)) {\n            this._terrainOffsetProperty.destroy();\n            this._terrainOffsetProperty = undefined;\n        }\n\n        GeometryUpdater.prototype.destroy.call(this);\n    };\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.getGeometryHeight = function(height, heightReference) {\n        \n        if (!defined(height)) {\n            if (heightReference !== HeightReference.NONE) {\n                oneTimeWarning(oneTimeWarning.geometryHeightReference);\n            }\n            return;\n        }\n\n        if (heightReference !== HeightReference.CLAMP_TO_GROUND) {\n            return height;\n        }\n        return 0.0;\n    };\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.getGeometryExtrudedHeight = function(extrudedHeight, extrudedHeightReference) {\n        \n        if (!defined(extrudedHeight)) {\n            if (extrudedHeightReference !== HeightReference.NONE) {\n                oneTimeWarning(oneTimeWarning.geometryExtrudedHeightReference);\n            }\n            return;\n        }\n        if (extrudedHeightReference !== HeightReference.CLAMP_TO_GROUND) {\n            return extrudedHeight;\n        }\n\n        return GroundGeometryUpdater.CLAMP_TO_GROUND;\n    };\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.CLAMP_TO_GROUND = 'clamp';\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.computeGeometryOffsetAttribute = function(height, heightReference, extrudedHeight, extrudedHeightReference) {\n        if (!defined(height) || !defined(heightReference)) {\n            heightReference = HeightReference.NONE;\n        }\n        if (!defined(extrudedHeight) || !defined(extrudedHeightReference)) {\n            extrudedHeightReference = HeightReference.NONE;\n        }\n        var n = 0;\n        if (heightReference !== HeightReference.NONE) {\n            n++;\n        }\n        if (extrudedHeightReference === HeightReference.RELATIVE_TO_GROUND) {\n            n++;\n        }\n        if (n === 2) {\n            return GeometryOffsetAttribute.ALL;\n        }\n        if (n === 1) {\n            return GeometryOffsetAttribute.TOP;\n        }\n\n        return undefined;\n    };\nexport default GroundGeometryUpdater;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport CorridorGeometry from '../Core/CorridorGeometry.js';\nimport CorridorOutlineGeometry from '../Core/CorridorOutlineGeometry.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport Rectangle from '../Core/Rectangle.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport GroundGeometryUpdater from './GroundGeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n\n    function CorridorGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.positions = undefined;\n        this.width = undefined;\n        this.cornerType = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for corridors.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias CorridorGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function CorridorGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new CorridorGeometryOptions(entity),\n            geometryPropertyName : 'corridor',\n            observedPropertyNames : ['availability', 'corridor']\n        });\n\n        this._onEntityPropertyChanged(entity, 'corridor', entity.corridor, undefined);\n    }\n\n    if (defined(Object.create)) {\n        CorridorGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        CorridorGeometryUpdater.prototype.constructor = CorridorGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    CorridorGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CorridorGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    CorridorGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined\n        };\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CorridorOutlineGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    CorridorGeometryUpdater.prototype._computeCenter = function(time, result) {\n        var positions = Property.getValueOrUndefined(this._entity.corridor.positions, time);\n        if (!defined(positions) || positions.length === 0) {\n            return;\n        }\n        return Cartesian3.clone(positions[Math.floor(positions.length / 2.0)], result);\n    };\n\n    CorridorGeometryUpdater.prototype._isHidden = function(entity, corridor) {\n        return !defined(corridor.positions) || !defined(corridor.width) || GeometryUpdater.prototype._isHidden.call(this, entity, corridor);\n    };\n\n    CorridorGeometryUpdater.prototype._isDynamic = function(entity, corridor) {\n        return !corridor.positions.isConstant || //\n               !Property.isConstant(corridor.height) || //\n               !Property.isConstant(corridor.extrudedHeight) || //\n               !Property.isConstant(corridor.granularity) || //\n               !Property.isConstant(corridor.width) || //\n               !Property.isConstant(corridor.outlineWidth) || //\n               !Property.isConstant(corridor.cornerType) || //\n               !Property.isConstant(corridor.zIndex) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    CorridorGeometryUpdater.prototype._setStaticOptions = function(entity, corridor) {\n        var heightValue = Property.getValueOrUndefined(corridor.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(corridor.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(corridor.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(corridor.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        var options = this._options;\n        options.vertexFormat = (this._materialProperty instanceof ColorMaterialProperty) ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.positions = corridor.positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);\n        options.width = corridor.width.getValue(Iso8601.MINIMUM_VALUE);\n        options.granularity = Property.getValueOrUndefined(corridor.granularity, Iso8601.MINIMUM_VALUE);\n        options.cornerType = Property.getValueOrUndefined(corridor.cornerType, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    CorridorGeometryUpdater.DynamicGeometryUpdater = DynamicCorridorGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicCorridorGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicCorridorGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicCorridorGeometryUpdater.prototype.constructor = DynamicCorridorGeometryUpdater;\n    }\n\n    DynamicCorridorGeometryUpdater.prototype._isHidden = function(entity, corridor, time) {\n        var options = this._options;\n        return !defined(options.positions) || !defined(options.width) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, corridor, time);\n    };\n\n    DynamicCorridorGeometryUpdater.prototype._setOptions = function(entity, corridor, time) {\n        var options = this._options;\n        var heightValue = Property.getValueOrUndefined(corridor.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(corridor.heightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(corridor.extrudedHeight, time);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(corridor.extrudedHeightReference, time, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        options.positions = Property.getValueOrUndefined(corridor.positions, time);\n        options.width = Property.getValueOrUndefined(corridor.width, time);\n        options.granularity = Property.getValueOrUndefined(corridor.granularity, time);\n        options.cornerType = Property.getValueOrUndefined(corridor.cornerType, time);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\nexport default CorridorGeometryUpdater;\n","import CesiumMath from './Math.js';\n\n    /**\n     * @private\n     */\n    var CylinderGeometryLibrary = {};\n\n    /**\n     * @private\n     */\n    CylinderGeometryLibrary.computePositions = function(length, topRadius, bottomRadius, slices, fill){\n        var topZ = length * 0.5;\n        var bottomZ = -topZ;\n\n        var twoSlice = slices + slices;\n        var size = (fill) ? 2 * twoSlice : twoSlice;\n        var positions = new Float64Array(size*3);\n        var i;\n        var index = 0;\n        var tbIndex = 0;\n        var bottomOffset = (fill) ? twoSlice*3 : 0;\n        var topOffset = (fill) ? (twoSlice + slices)*3 : slices*3;\n\n        for (i = 0; i < slices; i++) {\n            var angle = i / slices * CesiumMath.TWO_PI;\n            var x = Math.cos(angle);\n            var y = Math.sin(angle);\n            var bottomX = x * bottomRadius;\n            var bottomY = y * bottomRadius;\n            var topX = x * topRadius;\n            var topY = y * topRadius;\n\n            positions[tbIndex + bottomOffset] = bottomX;\n            positions[tbIndex + bottomOffset + 1] = bottomY;\n            positions[tbIndex + bottomOffset + 2] = bottomZ;\n\n            positions[tbIndex + topOffset] = topX;\n            positions[tbIndex + topOffset + 1] = topY;\n            positions[tbIndex + topOffset + 2] = topZ;\n            tbIndex += 3;\n            if (fill) {\n                positions[index++] = bottomX;\n                positions[index++] = bottomY;\n                positions[index++] = bottomZ;\n                positions[index++] = topX;\n                positions[index++] = topY;\n                positions[index++] = topZ;\n            }\n        }\n\n        return positions;\n    };\nexport default CylinderGeometryLibrary;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CylinderGeometryLibrary from './CylinderGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var radiusScratch = new Cartesian2();\n    var normalScratch = new Cartesian3();\n    var bitangentScratch = new Cartesian3();\n    var tangentScratch = new Cartesian3();\n    var positionScratch = new Cartesian3();\n\n    /**\n     * A description of a cylinder.\n     *\n     * @alias CylinderGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Number} options.length The length of the cylinder.\n     * @param {Number} options.topRadius The radius of the top of the cylinder.\n     * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n     * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n     *\n     * @see CylinderGeometry.createGeometry\n     *\n     * @example\n     * // create cylinder geometry\n     * var cylinder = new Cesium.CylinderGeometry({\n     *     length: 200000,\n     *     topRadius: 80000,\n     *     bottomRadius: 200000,\n     * });\n     * var geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\n     */\n    function CylinderGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var length = options.length;\n        var topRadius = options.topRadius;\n        var bottomRadius = options.bottomRadius;\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        var slices = defaultValue(options.slices, 128);\n\n        \n\n        this._length = length;\n        this._topRadius = topRadius;\n        this._bottomRadius = bottomRadius;\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._slices = slices;\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createCylinderGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    CylinderGeometry.packedLength = VertexFormat.packedLength + 5;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CylinderGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CylinderGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._length;\n        array[startingIndex++] = value._topRadius;\n        array[startingIndex++] = value._bottomRadius;\n        array[startingIndex++] = value._slices;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        vertexFormat : scratchVertexFormat,\n        length : undefined,\n        topRadius : undefined,\n        bottomRadius : undefined,\n        slices : undefined,\n        offsetAttribute : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CylinderGeometry} [result] The object into which to store the result.\n     * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\n     */\n    CylinderGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var length = array[startingIndex++];\n        var topRadius = array[startingIndex++];\n        var bottomRadius = array[startingIndex++];\n        var slices = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.length = length;\n            scratchOptions.topRadius = topRadius;\n            scratchOptions.bottomRadius = bottomRadius;\n            scratchOptions.slices = slices;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n            return new CylinderGeometry(scratchOptions);\n        }\n\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._length = length;\n        result._topRadius = topRadius;\n        result._bottomRadius = bottomRadius;\n        result._slices = slices;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CylinderGeometry.createGeometry = function(cylinderGeometry) {\n        var length = cylinderGeometry._length;\n        var topRadius = cylinderGeometry._topRadius;\n        var bottomRadius = cylinderGeometry._bottomRadius;\n        var vertexFormat = cylinderGeometry._vertexFormat;\n        var slices = cylinderGeometry._slices;\n\n        if ((length <= 0) || (topRadius < 0) || (bottomRadius < 0) || ((topRadius === 0) && (bottomRadius === 0))) {\n            return;\n        }\n\n        var twoSlices = slices + slices;\n        var threeSlices = slices + twoSlices;\n        var numVertices = twoSlices + twoSlices;\n\n        var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, true);\n\n        var st = (vertexFormat.st) ? new Float32Array(numVertices * 2) : undefined;\n        var normals = (vertexFormat.normal) ? new Float32Array(numVertices * 3) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(numVertices * 3) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(numVertices * 3) : undefined;\n\n        var i;\n        var computeNormal = (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent);\n\n        if (computeNormal) {\n            var computeTangent = (vertexFormat.tangent || vertexFormat.bitangent);\n\n            var normalIndex = 0;\n            var tangentIndex = 0;\n            var bitangentIndex = 0;\n\n            var theta = Math.atan2(bottomRadius - topRadius, length);\n            var normal = normalScratch;\n            normal.z = Math.sin(theta);\n            var normalScale = Math.cos(theta);\n            var tangent = tangentScratch;\n            var bitangent = bitangentScratch;\n\n            for (i = 0; i < slices; i++) {\n                var angle = i / slices * CesiumMath.TWO_PI;\n                var x = normalScale * Math.cos(angle);\n                var y = normalScale * Math.sin(angle);\n                if (computeNormal) {\n                    normal.x = x;\n                    normal.y = y;\n\n                    if (computeTangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);\n                    }\n\n                    if (vertexFormat.normal) {\n                        normals[normalIndex++] = normal.x;\n                        normals[normalIndex++] = normal.y;\n                        normals[normalIndex++] = normal.z;\n                        normals[normalIndex++] = normal.x;\n                        normals[normalIndex++] = normal.y;\n                        normals[normalIndex++] = normal.z;\n                    }\n\n                    if (vertexFormat.tangent) {\n                        tangents[tangentIndex++] = tangent.x;\n                        tangents[tangentIndex++] = tangent.y;\n                        tangents[tangentIndex++] = tangent.z;\n                        tangents[tangentIndex++] = tangent.x;\n                        tangents[tangentIndex++] = tangent.y;\n                        tangents[tangentIndex++] = tangent.z;\n                    }\n\n                    if (vertexFormat.bitangent) {\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                        bitangents[bitangentIndex++] = bitangent.x;\n                        bitangents[bitangentIndex++] = bitangent.y;\n                        bitangents[bitangentIndex++] = bitangent.z;\n                        bitangents[bitangentIndex++] = bitangent.x;\n                        bitangents[bitangentIndex++] = bitangent.y;\n                        bitangents[bitangentIndex++] = bitangent.z;\n                    }\n                }\n            }\n\n            for (i = 0; i < slices; i++) {\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = -1;\n                }\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = 1;\n                    tangents[tangentIndex++] = 0;\n                    tangents[tangentIndex++] = 0;\n                }\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = 0;\n                    bitangents[bitangentIndex++] = -1;\n                    bitangents[bitangentIndex++] = 0;\n                }\n            }\n\n            for (i = 0; i < slices; i++) {\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = 1;\n                }\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = 1;\n                    tangents[tangentIndex++] = 0;\n                    tangents[tangentIndex++] = 0;\n                }\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = 0;\n                    bitangents[bitangentIndex++] = 1;\n                    bitangents[bitangentIndex++] = 0;\n                }\n            }\n        }\n\n        var numIndices = 12 * slices - 12;\n        var indices = IndexDatatype.createTypedArray(numVertices, numIndices);\n        var index = 0;\n        var j = 0;\n        for (i = 0; i < slices - 1; i++) {\n            indices[index++] = j;\n            indices[index++] = j + 2;\n            indices[index++] = j + 3;\n\n            indices[index++] = j;\n            indices[index++] = j + 3;\n            indices[index++] = j + 1;\n\n            j += 2;\n        }\n\n        indices[index++] = twoSlices - 2;\n        indices[index++] = 0;\n        indices[index++] = 1;\n        indices[index++] = twoSlices - 2;\n        indices[index++] = 1;\n        indices[index++] = twoSlices - 1;\n\n        for (i = 1; i < slices - 1; i++) {\n            indices[index++] = twoSlices + i + 1;\n            indices[index++] = twoSlices + i;\n            indices[index++] = twoSlices;\n        }\n\n        for (i = 1; i < slices - 1; i++) {\n            indices[index++] = threeSlices;\n            indices[index++] = threeSlices + i;\n            indices[index++] = threeSlices + i + 1;\n        }\n\n        var textureCoordIndex = 0;\n        if (vertexFormat.st) {\n            var rad = Math.max(topRadius, bottomRadius);\n            for (i = 0; i < numVertices; i++) {\n                var position = Cartesian3.fromArray(positions, i * 3, positionScratch);\n                st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\n                st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype: ComponentDatatype.DOUBLE,\n                componentsPerAttribute: 3,\n                values: positions\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : st\n            });\n        }\n\n        radiusScratch.x = length * 0.5;\n        radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n        var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));\n\n        if (defined(cylinderGeometry._offsetAttribute)) {\n            length = positions.length;\n            var applyOffset = new Uint8Array(length / 3);\n            var offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n            arrayFill(applyOffset, offsetValue);\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : cylinderGeometry._offsetAttribute\n        });\n    };\n\n    var unitCylinderGeometry;\n\n    /**\n     * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\n     * @returns {Geometry} The computed vertices and indices.\n     *\n     * @private\n     */\n    CylinderGeometry.getUnitCylinder = function() {\n        if (!defined(unitCylinderGeometry)) {\n            unitCylinderGeometry = CylinderGeometry.createGeometry(new CylinderGeometry({\n                topRadius : 1.0,\n                bottomRadius : 1.0,\n                length : 1.0,\n                vertexFormat : VertexFormat.POSITION_ONLY\n            }));\n        }\n        return unitCylinderGeometry;\n    };\nexport default CylinderGeometry;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CylinderGeometryLibrary from './CylinderGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    var radiusScratch = new Cartesian2();\n\n    /**\n     * A description of the outline of a cylinder.\n     *\n     * @alias CylinderOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Number} options.length The length of the cylinder.\n     * @param {Number} options.topRadius The radius of the top of the cylinder.\n     * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n     * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n     * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surfaces of the cylinder.\n     *\n     * @exception {DeveloperError} options.length must be greater than 0.\n     * @exception {DeveloperError} options.topRadius must be greater than 0.\n     * @exception {DeveloperError} options.bottomRadius must be greater than 0.\n     * @exception {DeveloperError} bottomRadius and topRadius cannot both equal 0.\n     * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n     *\n     * @see CylinderOutlineGeometry.createGeometry\n     *\n     * @example\n     * // create cylinder geometry\n     * var cylinder = new Cesium.CylinderOutlineGeometry({\n     *     length: 200000,\n     *     topRadius: 80000,\n     *     bottomRadius: 200000,\n     * });\n     * var geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);\n     */\n    function CylinderOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var length = options.length;\n        var topRadius = options.topRadius;\n        var bottomRadius = options.bottomRadius;\n        var slices = defaultValue(options.slices, 128);\n        var numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);\n\n        \n\n        this._length = length;\n        this._topRadius = topRadius;\n        this._bottomRadius = bottomRadius;\n        this._slices = slices;\n        this._numberOfVerticalLines = numberOfVerticalLines;\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createCylinderOutlineGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    CylinderOutlineGeometry.packedLength = 6;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CylinderOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CylinderOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        array[startingIndex++] = value._length;\n        array[startingIndex++] = value._topRadius;\n        array[startingIndex++] = value._bottomRadius;\n        array[startingIndex++] = value._slices;\n        array[startingIndex++] = value._numberOfVerticalLines;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchOptions = {\n        length : undefined,\n        topRadius : undefined,\n        bottomRadius : undefined,\n        slices : undefined,\n        numberOfVerticalLines : undefined,\n        offsetAttribute : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CylinderOutlineGeometry} [result] The object into which to store the result.\n     * @returns {CylinderOutlineGeometry} The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.\n     */\n    CylinderOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var length = array[startingIndex++];\n        var topRadius = array[startingIndex++];\n        var bottomRadius = array[startingIndex++];\n        var slices = array[startingIndex++];\n        var numberOfVerticalLines = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.length = length;\n            scratchOptions.topRadius = topRadius;\n            scratchOptions.bottomRadius = bottomRadius;\n            scratchOptions.slices = slices;\n            scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n            return new CylinderOutlineGeometry(scratchOptions);\n        }\n\n        result._length = length;\n        result._topRadius = topRadius;\n        result._bottomRadius = bottomRadius;\n        result._slices = slices;\n        result._numberOfVerticalLines = numberOfVerticalLines;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CylinderOutlineGeometry} cylinderGeometry A description of the cylinder outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CylinderOutlineGeometry.createGeometry = function(cylinderGeometry) {\n        var length = cylinderGeometry._length;\n        var topRadius = cylinderGeometry._topRadius;\n        var bottomRadius = cylinderGeometry._bottomRadius;\n        var slices = cylinderGeometry._slices;\n        var numberOfVerticalLines = cylinderGeometry._numberOfVerticalLines;\n\n        if ((length <= 0) || (topRadius < 0) || (bottomRadius < 0) || ((topRadius === 0) && (bottomRadius === 0))) {\n            return;\n        }\n\n        var numVertices = slices * 2;\n\n        var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, false);\n        var numIndices = slices * 2;\n        var numSide;\n        if (numberOfVerticalLines > 0) {\n            var numSideLines = Math.min(numberOfVerticalLines, slices);\n            numSide = Math.round(slices / numSideLines);\n            numIndices += numSideLines;\n        }\n\n        var indices = IndexDatatype.createTypedArray(numVertices, numIndices * 2);\n        var index = 0;\n        var i;\n        for (i = 0; i < slices - 1; i++) {\n            indices[index++] = i;\n            indices[index++] = i + 1;\n            indices[index++] = i + slices;\n            indices[index++] = i + 1 + slices;\n        }\n\n        indices[index++] = slices - 1;\n        indices[index++] = 0;\n        indices[index++] = slices + slices - 1;\n        indices[index++] = slices;\n\n        if (numberOfVerticalLines > 0) {\n            for (i = 0; i < slices; i += numSide) {\n                indices[index++] = i;\n                indices[index++] = i + slices;\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : positions\n        });\n\n        radiusScratch.x = length * 0.5;\n        radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n        var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));\n\n        if (defined(cylinderGeometry._offsetAttribute)) {\n            length = positions.length;\n            var applyOffset = new Uint8Array(length / 3);\n            var offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n            arrayFill(applyOffset, offsetValue);\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : cylinderGeometry._offsetAttribute\n        });\n    };\nexport default CylinderOutlineGeometry;\n","import Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport CylinderGeometry from '../Core/CylinderGeometry.js';\nimport CylinderOutlineGeometry from '../Core/CylinderOutlineGeometry.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport GeometryOffsetAttribute from '../Core/GeometryOffsetAttribute.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport heightReferenceOnEntityPropertyChanged from './heightReferenceOnEntityPropertyChanged.js';\nimport Property from './Property.js';\n\n    var defaultOffset = Cartesian3.ZERO;\n\n    var offsetScratch = new Cartesian3();\n    var positionScratch = new Cartesian3();\n    var scratchColor = new Color();\n\n    function CylinderGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.length = undefined;\n        this.topRadius = undefined;\n        this.bottomRadius = undefined;\n        this.slices = undefined;\n        this.numberOfVerticalLines = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for cylinders.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias CylinderGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function CylinderGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity: entity,\n            scene: scene,\n            geometryOptions: new CylinderGeometryOptions(entity),\n            geometryPropertyName: 'cylinder',\n            observedPropertyNames: ['availability', 'position', 'orientation', 'cylinder']\n        });\n\n        this._onEntityPropertyChanged(entity, 'cylinder', entity.cylinder, undefined);\n    }\n\n    if (defined(Object.create)) {\n        CylinderGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        CylinderGeometryUpdater.prototype.constructor = CylinderGeometryUpdater;\n    }\n\n    defineProperties(CylinderGeometryUpdater.prototype, {\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof CylinderGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty: {\n            get: function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    CylinderGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute,\n            color : undefined,\n            offset: undefined\n        };\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CylinderGeometry(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.cylinder.heightReference, this._options.length * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    CylinderGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CylinderOutlineGeometry(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.cylinder.heightReference, this._options.length * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    CylinderGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    CylinderGeometryUpdater.prototype._isHidden = function(entity, cylinder) {\n        return !defined(entity.position) || !defined(cylinder.length) || !defined(cylinder.topRadius) || !defined(cylinder.bottomRadius) || GeometryUpdater.prototype._isHidden.call(this, entity, cylinder);\n    };\n\n    CylinderGeometryUpdater.prototype._isDynamic = function(entity, cylinder) {\n        return !entity.position.isConstant || //\n                !Property.isConstant(entity.orientation) || //\n                !cylinder.length.isConstant || //\n                !cylinder.topRadius.isConstant || //\n                !cylinder.bottomRadius.isConstant || //\n                !Property.isConstant(cylinder.slices) || //\n                !Property.isConstant(cylinder.outlineWidth) || //\n                !Property.isConstant(cylinder.numberOfVerticalLines);\n    };\n\n    CylinderGeometryUpdater.prototype._setStaticOptions = function(entity, cylinder) {\n        var heightReference = Property.getValueOrDefault(cylinder.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var options = this._options;\n        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.length = cylinder.length.getValue(Iso8601.MINIMUM_VALUE);\n        options.topRadius = cylinder.topRadius.getValue(Iso8601.MINIMUM_VALUE);\n        options.bottomRadius = cylinder.bottomRadius.getValue(Iso8601.MINIMUM_VALUE);\n        options.slices = Property.getValueOrUndefined(cylinder.slices, Iso8601.MINIMUM_VALUE);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(cylinder.numberOfVerticalLines, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    CylinderGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\n\n    CylinderGeometryUpdater.DynamicGeometryUpdater = DynamicCylinderGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicCylinderGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicCylinderGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicCylinderGeometryUpdater.prototype.constructor = DynamicCylinderGeometryUpdater;\n    }\n\n    DynamicCylinderGeometryUpdater.prototype._isHidden = function(entity, cylinder, time) {\n        var options = this._options;\n        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n        return !defined(position) || !defined(options.length) || !defined(options.topRadius) || //\n               !defined(options.bottomRadius) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, cylinder, time);\n    };\n\n    DynamicCylinderGeometryUpdater.prototype._setOptions = function(entity, cylinder, time) {\n        var heightReference = Property.getValueOrDefault(cylinder.heightReference, time, HeightReference.NONE);\n        var options = this._options;\n        options.length = Property.getValueOrUndefined(cylinder.length, time);\n        options.topRadius = Property.getValueOrUndefined(cylinder.topRadius, time);\n        options.bottomRadius = Property.getValueOrUndefined(cylinder.bottomRadius, time);\n        options.slices = Property.getValueOrUndefined(cylinder.slices, time);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(cylinder.numberOfVerticalLines, time);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\nexport default CylinderGeometryUpdater;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport defined from '../Core/defined.js';\nimport BoundingSphereState from './BoundingSphereState.js';\n\n    /**\n     * @private\n     */\n    function DynamicGeometryBatch(primitives, orderedGroundPrimitives) {\n        this._primitives = primitives;\n        this._orderedGroundPrimitives = orderedGroundPrimitives;\n        this._dynamicUpdaters = new AssociativeArray();\n    }\n\n    DynamicGeometryBatch.prototype.add = function(time, updater) {\n        this._dynamicUpdaters.set(updater.id, updater.createDynamicUpdater(this._primitives, this._orderedGroundPrimitives));\n    };\n\n    DynamicGeometryBatch.prototype.remove = function(updater) {\n        var id = updater.id;\n        var dynamicUpdater = this._dynamicUpdaters.get(id);\n        if (defined(dynamicUpdater)) {\n            this._dynamicUpdaters.remove(id);\n            dynamicUpdater.destroy();\n        }\n    };\n\n    DynamicGeometryBatch.prototype.update = function(time) {\n        var geometries = this._dynamicUpdaters.values;\n        for (var i = 0, len = geometries.length; i < len; i++) {\n            geometries[i].update(time);\n        }\n        return true;\n    };\n\n    DynamicGeometryBatch.prototype.removeAllPrimitives = function() {\n        var geometries = this._dynamicUpdaters.values;\n        for (var i = 0, len = geometries.length; i < len; i++) {\n            geometries[i].destroy();\n        }\n        this._dynamicUpdaters.removeAll();\n    };\n\n    DynamicGeometryBatch.prototype.getBoundingSphere = function(updater, result) {\n        updater = this._dynamicUpdaters.get(updater.id);\n        if (defined(updater) && defined(updater.getBoundingSphere)) {\n            return updater.getBoundingSphere(result);\n        }\n        return BoundingSphereState.FAILED;\n    };\nexport default DynamicGeometryBatch;\n","import Cartesian3 from './Cartesian3.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport Quaternion from './Quaternion.js';\n\n    var EllipseGeometryLibrary = {};\n\n    var rotAxis = new Cartesian3();\n    var tempVec = new Cartesian3();\n    var unitQuat = new Quaternion();\n    var rotMtx = new Matrix3();\n\n    function pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, result) {\n        var azimuth = theta + rotation;\n\n        Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\n        Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\n        Cartesian3.add(rotAxis, tempVec, rotAxis);\n\n        var cosThetaSquared = Math.cos(theta);\n        cosThetaSquared = cosThetaSquared * cosThetaSquared;\n\n        var sinThetaSquared = Math.sin(theta);\n        sinThetaSquared = sinThetaSquared * sinThetaSquared;\n\n        var radius = ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\n        var angle = radius / mag;\n\n        // Create the quaternion to rotate the position vector to the boundary of the ellipse.\n        Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);\n        Matrix3.fromQuaternion(unitQuat, rotMtx);\n\n        Matrix3.multiplyByVector(rotMtx, unitPos, result);\n        Cartesian3.normalize(result, result);\n        Cartesian3.multiplyByScalar(result, mag, result);\n        return result;\n    }\n\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartesian3 = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n    /**\n     * Returns the positions raised to the given heights\n     * @private\n     */\n    EllipseGeometryLibrary.raisePositionsToHeight = function(positions, options, extrude) {\n        var ellipsoid = options.ellipsoid;\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        var size = (extrude) ? positions.length / 3 * 2 : positions.length / 3;\n\n        var finalPositions = new Float64Array(size * 3);\n\n        var length = positions.length;\n        var bottomOffset = (extrude) ? length : 0;\n        for (var i = 0; i < length; i += 3) {\n            var i1 = i + 1;\n            var i2 = i + 2;\n\n            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n            ellipsoid.scaleToGeodeticSurface(position, position);\n\n            var extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n            var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n            var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian3);\n            Cartesian3.add(position, scaledNormal, position);\n\n            if (extrude) {\n                Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n                Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n                finalPositions[i + bottomOffset] = extrudedPosition.x;\n                finalPositions[i1 + bottomOffset] = extrudedPosition.y;\n                finalPositions[i2 + bottomOffset] = extrudedPosition.z;\n            }\n\n            finalPositions[i] = position.x;\n            finalPositions[i1] = position.y;\n            finalPositions[i2] = position.z;\n        }\n\n        return finalPositions;\n    };\n\n    var unitPosScratch = new Cartesian3();\n    var eastVecScratch = new Cartesian3();\n    var northVecScratch = new Cartesian3();\n    /**\n     * Returns an array of positions that make up the ellipse.\n     * @private\n     */\n    EllipseGeometryLibrary.computeEllipsePositions = function(options, addFillPositions, addEdgePositions) {\n        var semiMinorAxis = options.semiMinorAxis;\n        var semiMajorAxis = options.semiMajorAxis;\n        var rotation = options.rotation;\n        var center = options.center;\n\n        // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\n        // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\n        // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\n        // the distance along the ellipse boundary more closely match the granularity.\n        var granularity = options.granularity * 8.0;\n\n        var aSqr = semiMinorAxis * semiMinorAxis;\n        var bSqr = semiMajorAxis * semiMajorAxis;\n        var ab = semiMajorAxis * semiMinorAxis;\n\n        var mag = Cartesian3.magnitude(center);\n\n        var unitPos = Cartesian3.normalize(center, unitPosScratch);\n        var eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);\n        eastVec = Cartesian3.normalize(eastVec, eastVec);\n        var northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);\n\n        // The number of points in the first quadrant\n        var numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);\n\n        var deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);\n        var theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;\n        if (theta < 0.0) {\n            numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\n        }\n\n        // If the number of points were three, the ellipse\n        // would be tessellated like below:\n        //\n        //         *---*\n        //       / | \\ | \\\n        //     *---*---*---*\n        //   / | \\ | \\ | \\ | \\\n        //  / .*---*---*---*. \\\n        // * ` | \\ | \\ | \\ | `*\n        //  \\`.*---*---*---*.`/\n        //   \\ | \\ | \\ | \\ | /\n        //     *---*---*---*\n        //       \\ | \\ | /\n        //         *---*\n        // The first and last column have one position and fan to connect to the adjacent column.\n        // Each other vertical column contains an even number of positions.\n        var size = 2 * (numPts * (numPts + 2));\n        var positions = (addFillPositions) ? new Array(size * 3) : undefined;\n        var positionIndex = 0;\n        var position = scratchCartesian1;\n        var reflectedPosition = scratchCartesian2;\n\n        var outerPositionsLength = (numPts * 4) * 3;\n        var outerRightIndex = outerPositionsLength - 1;\n        var outerLeftIndex = 0;\n        var outerPositions = (addEdgePositions) ? new Array(outerPositionsLength) : undefined;\n\n        var i;\n        var j;\n        var numInterior;\n        var t;\n        var interiorPosition;\n\n        // Compute points in the 'eastern' half of the ellipse\n        theta = CesiumMath.PI_OVER_TWO;\n        position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n        if (addFillPositions) {\n            positions[positionIndex++] = position.x;\n            positions[positionIndex++] = position.y;\n            positions[positionIndex++] = position.z;\n        }\n        if (addEdgePositions) {\n            outerPositions[outerRightIndex--] = position.z;\n            outerPositions[outerRightIndex--] = position.y;\n            outerPositions[outerRightIndex--] = position.x;\n        }\n        theta = CesiumMath.PI_OVER_TWO -  deltaTheta;\n        for (i = 1; i < numPts + 1; ++i) {\n            position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n            reflectedPosition = pointOnEllipsoid(Math.PI - theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\n\n            if (addFillPositions) {\n                positions[positionIndex++] = position.x;\n                positions[positionIndex++] = position.y;\n                positions[positionIndex++] = position.z;\n\n                numInterior = 2 * i + 2;\n                for (j = 1; j < numInterior - 1; ++j) {\n                    t = j / (numInterior - 1);\n                    interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\n                    positions[positionIndex++] = interiorPosition.x;\n                    positions[positionIndex++] = interiorPosition.y;\n                    positions[positionIndex++] = interiorPosition.z;\n                }\n\n                positions[positionIndex++] = reflectedPosition.x;\n                positions[positionIndex++] = reflectedPosition.y;\n                positions[positionIndex++] = reflectedPosition.z;\n            }\n\n            if (addEdgePositions) {\n                outerPositions[outerRightIndex--] = position.z;\n                outerPositions[outerRightIndex--] = position.y;\n                outerPositions[outerRightIndex--] = position.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.y;\n                outerPositions[outerLeftIndex++] = reflectedPosition.z;\n            }\n\n            theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;\n        }\n\n        // Compute points in the 'western' half of the ellipse\n        for (i = numPts; i > 1; --i) {\n            theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;\n\n            position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n            reflectedPosition = pointOnEllipsoid(theta + Math.PI, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\n\n            if (addFillPositions) {\n                positions[positionIndex++] = position.x;\n                positions[positionIndex++] = position.y;\n                positions[positionIndex++] = position.z;\n\n                numInterior = 2 * (i - 1) + 2;\n                for (j = 1; j < numInterior - 1; ++j) {\n                    t = j / (numInterior - 1);\n                    interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\n                    positions[positionIndex++] = interiorPosition.x;\n                    positions[positionIndex++] = interiorPosition.y;\n                    positions[positionIndex++] = interiorPosition.z;\n                }\n\n                positions[positionIndex++] = reflectedPosition.x;\n                positions[positionIndex++] = reflectedPosition.y;\n                positions[positionIndex++] = reflectedPosition.z;\n            }\n\n            if (addEdgePositions) {\n                outerPositions[outerRightIndex--] = position.z;\n                outerPositions[outerRightIndex--] = position.y;\n                outerPositions[outerRightIndex--] = position.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.y;\n                outerPositions[outerLeftIndex++] = reflectedPosition.z;\n            }\n        }\n\n        theta = CesiumMath.PI_OVER_TWO;\n        position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n\n        var r = {};\n        if (addFillPositions) {\n            positions[positionIndex++] = position.x;\n            positions[positionIndex++] = position.y;\n            positions[positionIndex++] = position.z;\n            r.positions = positions;\n            r.numPts = numPts;\n        }\n        if (addEdgePositions) {\n            outerPositions[outerRightIndex--] = position.z;\n            outerPositions[outerRightIndex--] = position.y;\n            outerPositions[outerRightIndex--] = position.x;\n            r.outerPositions = outerPositions;\n        }\n\n        return r;\n    };\nexport default EllipseGeometryLibrary;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\nimport EllipseGeometryLibrary from './EllipseGeometryLibrary.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport GeographicProjection from './GeographicProjection.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport Quaternion from './Quaternion.js';\nimport Rectangle from './Rectangle.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartesian3 = new Cartesian3();\n    var scratchCartesian4 = new Cartesian3();\n    var texCoordScratch = new Cartesian2();\n    var textureMatrixScratch = new Matrix3();\n    var tangentMatrixScratch = new Matrix3();\n    var quaternionScratch = new Quaternion();\n\n    var scratchNormal = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n\n    var scratchCartographic = new Cartographic();\n    var projectedCenterScratch = new Cartesian3();\n\n    var scratchMinTexCoord = new Cartesian2();\n    var scratchMaxTexCoord = new Cartesian2();\n\n    function computeTopBottomAttributes(positions, options, extrude) {\n        var vertexFormat = options.vertexFormat;\n        var center = options.center;\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var ellipsoid = options.ellipsoid;\n        var stRotation = options.stRotation;\n        var size = (extrude) ? positions.length / 3 * 2 : positions.length / 3;\n        var shadowVolume = options.shadowVolume;\n\n        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;\n        var normals = (vertexFormat.normal) ? new Float32Array(size * 3) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(size * 3) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size * 3) : undefined;\n\n        var extrudeNormals = (shadowVolume) ? new Float32Array(size * 3) : undefined;\n\n        var textureCoordIndex = 0;\n\n        // Raise positions to a height above the ellipsoid and compute the\n        // texture coordinates, normals, tangents, and bitangents.\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n\n        var projection = new GeographicProjection(ellipsoid);\n        var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);\n\n        var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);\n        ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n\n        var textureMatrix = textureMatrixScratch;\n        var tangentMatrix = tangentMatrixScratch;\n        if (stRotation !== 0) {\n            var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);\n            textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n            rotation = Quaternion.fromAxisAngle(geodeticNormal, -stRotation, quaternionScratch);\n            tangentMatrix = Matrix3.fromQuaternion(rotation, tangentMatrix);\n        } else {\n            textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n            tangentMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentMatrix);\n        }\n\n        var minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);\n        var maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);\n\n        var length = positions.length;\n        var bottomOffset = (extrude) ? length : 0;\n        var stOffset = bottomOffset / 3 * 2;\n        for (var i = 0; i < length; i += 3) {\n            var i1 = i + 1;\n            var i2 = i + 2;\n            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n\n            if (vertexFormat.st) {\n                var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);\n                var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);\n                Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n                texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n                texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n                minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n                minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n                maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n                maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n                if (extrude) {\n                    textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n                    textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n                }\n\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n            }\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n                normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n                if (shadowVolume) {\n                    extrudeNormals[i + bottomOffset] = -normal.x;\n                    extrudeNormals[i1 + bottomOffset] = -normal.y;\n                    extrudeNormals[i2 + bottomOffset] = -normal.z;\n                }\n\n                if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n                    if (vertexFormat.tangent || vertexFormat.bitangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);\n                        Matrix3.multiplyByVector(tangentMatrix, tangent, tangent);\n                    }\n                    if (vertexFormat.normal) {\n                        normals[i] = normal.x;\n                        normals[i1] = normal.y;\n                        normals[i2] = normal.z;\n                        if (extrude) {\n                            normals[i + bottomOffset] = -normal.x;\n                            normals[i1 + bottomOffset] = -normal.y;\n                            normals[i2 + bottomOffset] = -normal.z;\n                        }\n                    }\n\n                    if (vertexFormat.tangent) {\n                        tangents[i] = tangent.x;\n                        tangents[i1] = tangent.y;\n                        tangents[i2] = tangent.z;\n                        if (extrude) {\n                            tangents[i + bottomOffset] = -tangent.x;\n                            tangents[i1 + bottomOffset] = -tangent.y;\n                            tangents[i2 + bottomOffset] = -tangent.z;\n                        }\n                    }\n\n                    if (vertexFormat.bitangent) {\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                        bitangents[i ] = bitangent.x;\n                        bitangents[i1] = bitangent.y;\n                        bitangents[i2] = bitangent.z;\n                        if (extrude) {\n                            bitangents[i + bottomOffset] = bitangent.x;\n                            bitangents[i1 + bottomOffset] = bitangent.y;\n                            bitangents[i2 + bottomOffset] = bitangent.z;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (vertexFormat.st) {\n            length = textureCoordinates.length;\n            for (var k = 0; k < length; k += 2) {\n                textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);\n                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            var finalPositions = EllipseGeometryLibrary.raisePositionsToHeight(positions, options, extrude);\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : finalPositions\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (shadowVolume) {\n            attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n        }\n\n        if (extrude && defined(options.offsetAttribute)) {\n            var offsetAttribute = new Uint8Array(size);\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        return attributes;\n    }\n\n    function topIndices(numPts) {\n        // numTriangles in half = 3 + 8 + 12 + ... = -1 + 4 + (4 + 4) + (4 + 4 + 4) + ... = -1 + 4 * (1 + 2 + 3 + ...)\n        //              = -1 + 4 * ((n * ( n + 1)) / 2)\n        // total triangles = 2 * numTrangles in half\n        // indices = total triangles * 3;\n        // Substitute numPts for n above\n\n        var indices = new Array(12 * (numPts * ( numPts + 1)) - 6);\n        var indicesIndex = 0;\n        var prevIndex;\n        var numInterior;\n        var positionIndex;\n        var i;\n        var j;\n        // Indices triangles to the 'right' of the north vector\n\n        prevIndex = 0;\n        positionIndex = 1;\n        for (i = 0; i < 3; i++) {\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n\n        for (i = 2; i < numPts + 1; ++i) {\n            positionIndex = i * (i + 1) - 1;\n            prevIndex = (i - 1) * i - 1;\n\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n\n            numInterior = 2 * i;\n            for (j = 0; j < numInterior - 1; ++j) {\n\n                indices[indicesIndex++] = positionIndex;\n                indices[indicesIndex++] = prevIndex++;\n                indices[indicesIndex++] = prevIndex;\n\n                indices[indicesIndex++] = positionIndex++;\n                indices[indicesIndex++] = prevIndex;\n                indices[indicesIndex++] = positionIndex;\n            }\n\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n\n        // Indices for center column of triangles\n        numInterior = numPts * 2;\n        ++positionIndex;\n        ++prevIndex;\n        for (i = 0; i < numInterior - 1; ++i) {\n            indices[indicesIndex++] = positionIndex;\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex;\n\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n\n        indices[indicesIndex++] = positionIndex;\n        indices[indicesIndex++] = prevIndex++;\n        indices[indicesIndex++] = prevIndex;\n\n        indices[indicesIndex++] = positionIndex++;\n        indices[indicesIndex++] = prevIndex++;\n        indices[indicesIndex++] = prevIndex;\n\n        // Reverse the process creating indices to the 'left' of the north vector\n        ++prevIndex;\n        for (i = numPts - 1; i > 1; --i) {\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n\n            numInterior = 2 * i;\n            for (j = 0; j < numInterior - 1; ++j) {\n                indices[indicesIndex++] = positionIndex;\n                indices[indicesIndex++] = prevIndex++;\n                indices[indicesIndex++] = prevIndex;\n\n                indices[indicesIndex++] = positionIndex++;\n                indices[indicesIndex++] = prevIndex;\n                indices[indicesIndex++] = positionIndex;\n            }\n\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = positionIndex++;\n        }\n\n        for (i = 0; i < 3; i++) {\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n        return indices;\n    }\n\n    var boundingSphereCenter = new Cartesian3();\n\n    function computeEllipse(options) {\n        var center = options.center;\n        boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);\n        boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);\n        var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);\n        var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, false);\n        var positions = cep.positions;\n        var numPts = cep.numPts;\n        var attributes = computeTopBottomAttributes(positions, options, false);\n        var indices = topIndices(numPts);\n        indices = IndexDatatype.createTypedArray(positions.length / 3, indices);\n        return {\n            boundingSphere : boundingSphere,\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    function computeWallAttributes(positions, options) {\n        var vertexFormat = options.vertexFormat;\n        var center = options.center;\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var ellipsoid = options.ellipsoid;\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        var stRotation = options.stRotation;\n        var size = positions.length / 3 * 2;\n\n        var finalPositions = new Float64Array(size * 3);\n        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;\n        var normals = (vertexFormat.normal) ? new Float32Array(size * 3) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(size * 3) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size * 3) : undefined;\n\n        var shadowVolume = options.shadowVolume;\n        var extrudeNormals = (shadowVolume) ? new Float32Array(size * 3) : undefined;\n\n        var textureCoordIndex = 0;\n\n        // Raise positions to a height above the ellipsoid and compute the\n        // texture coordinates, normals, tangents, and bitangents.\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n\n        var projection = new GeographicProjection(ellipsoid);\n        var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);\n\n        var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);\n        ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n        var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);\n        var textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrixScratch);\n\n        var minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);\n        var maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);\n\n        var length = positions.length;\n        var stOffset = length / 3 * 2;\n        for (var i = 0; i < length; i += 3) {\n            var i1 = i + 1;\n            var i2 = i + 2;\n            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n            var extrudedPosition;\n\n            if (vertexFormat.st) {\n                var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);\n                var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);\n                Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n                texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n                texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n                minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n                minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n                maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n                maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n                textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n                textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n            }\n\n            position = ellipsoid.scaleToGeodeticSurface(position, position);\n            extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n            if (shadowVolume) {\n                extrudeNormals[i + length] = -normal.x;\n                extrudeNormals[i1 + length] = -normal.y;\n                extrudeNormals[i2 + length] = -normal.z;\n            }\n\n            var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian4);\n            position = Cartesian3.add(position, scaledNormal, position);\n            scaledNormal = Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n            extrudedPosition = Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n            if (vertexFormat.position) {\n                finalPositions[i + length] = extrudedPosition.x;\n                finalPositions[i1 + length] = extrudedPosition.y;\n                finalPositions[i2 + length] = extrudedPosition.z;\n\n                finalPositions[i] = position.x;\n                finalPositions[i1] = position.y;\n                finalPositions[i2] = position.z;\n            }\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n\n                bitangent = Cartesian3.clone(normal, bitangent);\n                var next = Cartesian3.fromArray(positions, (i + 3) % length, scratchCartesian4);\n                Cartesian3.subtract(next, position, next);\n                var bottom = Cartesian3.subtract(extrudedPosition, position, scratchCartesian3);\n\n                normal = Cartesian3.normalize(Cartesian3.cross(bottom, next, normal), normal);\n\n                if (vertexFormat.normal) {\n                    normals[i] = normal.x;\n                    normals[i1] = normal.y;\n                    normals[i2] = normal.z;\n\n                    normals[i + length] = normal.x;\n                    normals[i1 + length] = normal.y;\n                    normals[i2 + length] = normal.z;\n                }\n\n                if (vertexFormat.tangent) {\n                    tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                    tangents[i] = tangent.x;\n                    tangents[i1] = tangent.y;\n                    tangents[i2] = tangent.z;\n\n                    tangents[i + length] = tangent.x;\n                    tangents[i + 1 + length] = tangent.y;\n                    tangents[i + 2 + length] = tangent.z;\n                }\n\n                if (vertexFormat.bitangent) {\n                    bitangents[i ] = bitangent.x;\n                    bitangents[i1] = bitangent.y;\n                    bitangents[i2] = bitangent.z;\n\n                    bitangents[i + length] = bitangent.x;\n                    bitangents[i1 + length] = bitangent.y;\n                    bitangents[i2 + length] = bitangent.z;\n                }\n            }\n        }\n\n        if (vertexFormat.st) {\n            length = textureCoordinates.length;\n            for (var k = 0; k < length; k += 2) {\n                textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);\n                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : finalPositions\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (shadowVolume) {\n            attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n        }\n\n        if (defined(options.offsetAttribute)) {\n            var offsetAttribute = new Uint8Array(size);\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        return attributes;\n    }\n\n    function computeWallIndices(positions) {\n        var length = positions.length / 3;\n        var indices = IndexDatatype.createTypedArray(length, length * 6);\n        var index = 0;\n        for (var i = 0; i < length; i++) {\n            var UL = i;\n            var LL = i + length;\n            var UR = (UL + 1) % length;\n            var LR = UR + length;\n            indices[index++] = UL;\n            indices[index++] = LL;\n            indices[index++] = UR;\n            indices[index++] = UR;\n            indices[index++] = LL;\n            indices[index++] = LR;\n        }\n\n        return indices;\n    }\n\n    var topBoundingSphere = new BoundingSphere();\n    var bottomBoundingSphere = new BoundingSphere();\n\n    function computeExtrudedEllipse(options) {\n        var center = options.center;\n        var ellipsoid = options.ellipsoid;\n        var semiMajorAxis = options.semiMajorAxis;\n        var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);\n        topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);\n        topBoundingSphere.radius = semiMajorAxis;\n\n        scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);\n        bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);\n        bottomBoundingSphere.radius = semiMajorAxis;\n\n        var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, true);\n        var positions = cep.positions;\n        var numPts = cep.numPts;\n        var outerPositions = cep.outerPositions;\n        var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);\n        var topBottomAttributes = computeTopBottomAttributes(positions, options, true);\n        var indices = topIndices(numPts);\n        var length = indices.length;\n        indices.length = length * 2;\n        var posLength = positions.length / 3;\n        for (var i = 0; i < length; i += 3) {\n            indices[i + length] = indices[i + 2] + posLength;\n            indices[i + 1 + length] = indices[i + 1] + posLength;\n            indices[i + 2 + length] = indices[i] + posLength;\n        }\n\n        var topBottomIndices = IndexDatatype.createTypedArray(posLength * 2 / 3, indices);\n\n        var topBottomGeo = new Geometry({\n            attributes : topBottomAttributes,\n            indices : topBottomIndices,\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        var wallAttributes = computeWallAttributes(outerPositions, options);\n        indices = computeWallIndices(outerPositions);\n        var wallIndices = IndexDatatype.createTypedArray(outerPositions.length * 2 / 3, indices);\n\n        var wallGeo = new Geometry({\n            attributes : wallAttributes,\n            indices : wallIndices,\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        var geo = GeometryPipeline.combineInstances([\n            new GeometryInstance({\n                geometry : topBottomGeo\n            }),\n            new GeometryInstance({\n                geometry : wallGeo\n            })\n        ]);\n\n        return {\n            boundingSphere : boundingSphere,\n            attributes : geo[0].attributes,\n            indices : geo[0].indices\n        };\n    }\n\n    function computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result) {\n        var cep = EllipseGeometryLibrary.computeEllipsePositions({\n            center : center,\n            semiMajorAxis : semiMajorAxis,\n            semiMinorAxis : semiMinorAxis,\n            rotation : rotation,\n            granularity : granularity\n        }, false, true);\n        var positionsFlat = cep.outerPositions;\n        var positionsCount = positionsFlat.length / 3;\n        var positions = new Array(positionsCount);\n        for (var i = 0; i < positionsCount; ++i) {\n            positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n        }\n        var rectangle = Rectangle.fromCartesianArray(positions, ellipsoid, result);\n        // Rectangle width goes beyond 180 degrees when the ellipse crosses a pole.\n        // When this happens, make the rectangle into a \"circle\" around the pole\n        if (rectangle.width > CesiumMath.PI) {\n            rectangle.north = rectangle.north > 0.0 ? CesiumMath.PI_OVER_TWO - CesiumMath.EPSILON7 : rectangle.north;\n            rectangle.south = rectangle.south < 0.0 ? CesiumMath.EPSILON7 - CesiumMath.PI_OVER_TWO : rectangle.south;\n            rectangle.east = CesiumMath.PI;\n            rectangle.west = -CesiumMath.PI;\n        }\n        return rectangle;\n    }\n\n    /**\n     * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias EllipseGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n     * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n     * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates counter-clockwise from north.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n     * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n     * @exception {DeveloperError} granularity must be greater than zero.\n     *\n     *\n     * @example\n     * // Create an ellipse.\n     * var ellipse = new Cesium.EllipseGeometry({\n     *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n     *   semiMajorAxis : 500000.0,\n     *   semiMinorAxis : 300000.0,\n     *   rotation : Cesium.Math.toRadians(60.0)\n     * });\n     * var geometry = Cesium.EllipseGeometry.createGeometry(ellipse);\n     *\n     * @see EllipseGeometry.createGeometry\n     */\n    function EllipseGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var center = options.center;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._center = Cartesian3.clone(center);\n        this._semiMajorAxis = semiMajorAxis;\n        this._semiMinorAxis = semiMinorAxis;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._rotation = defaultValue(options.rotation, 0.0);\n        this._stRotation = defaultValue(options.stRotation, 0.0);\n        this._height = Math.max(extrudedHeight, height);\n        this._granularity = granularity;\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._extrudedHeight = Math.min(extrudedHeight, height);\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createEllipseGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n\n        this._rectangle = undefined;\n        this._textureCoordinateRotationPoints = undefined;\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    EllipseGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 9;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {EllipseGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    EllipseGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        Cartesian3.pack(value._center, array, startingIndex);\n        startingIndex += Cartesian3.packedLength;\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._semiMajorAxis;\n        array[startingIndex++] = value._semiMinorAxis;\n        array[startingIndex++] = value._rotation;\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchCenter = new Cartesian3();\n    var scratchEllipsoid = new Ellipsoid();\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        center : scratchCenter,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        semiMajorAxis : undefined,\n        semiMinorAxis : undefined,\n        rotation : undefined,\n        stRotation : undefined,\n        height : undefined,\n        granularity : undefined,\n        extrudedHeight : undefined,\n        shadowVolume: undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {EllipseGeometry} [result] The object into which to store the result.\n     * @returns {EllipseGeometry} The modified result parameter or a new EllipseGeometry instance if one was not provided.\n     */\n    EllipseGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n        startingIndex += Cartesian3.packedLength;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var semiMajorAxis = array[startingIndex++];\n        var semiMinorAxis = array[startingIndex++];\n        var rotation = array[startingIndex++];\n        var stRotation = array[startingIndex++];\n        var height = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.granularity = granularity;\n            scratchOptions.stRotation = stRotation;\n            scratchOptions.rotation = rotation;\n            scratchOptions.semiMajorAxis = semiMajorAxis;\n            scratchOptions.semiMinorAxis = semiMinorAxis;\n            scratchOptions.shadowVolume = shadowVolume;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new EllipseGeometry(scratchOptions);\n        }\n\n        result._center = Cartesian3.clone(center, result._center);\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._semiMajorAxis = semiMajorAxis;\n        result._semiMinorAxis = semiMinorAxis;\n        result._rotation = rotation;\n        result._stRotation = stRotation;\n        result._height = height;\n        result._granularity = granularity;\n        result._extrudedHeight = extrudedHeight;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the bounding rectangle based on the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n     * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n     * @param {Rectangle} [result] An object in which to store the result\n     *\n     * @returns {Rectangle} The result rectangle\n     */\n    EllipseGeometry.computeRectangle = function(options, result) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var center = options.center;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var rotation = defaultValue(options.rotation, 0.0);\n\n        \n\n        return computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result);\n    };\n\n    /**\n     * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {EllipseGeometry} ellipseGeometry A description of the ellipse.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    EllipseGeometry.createGeometry = function(ellipseGeometry) {\n        if ((ellipseGeometry._semiMajorAxis <= 0.0) || (ellipseGeometry._semiMinorAxis <= 0.0)) {\n            return;\n        }\n\n        var height = ellipseGeometry._height;\n        var extrudedHeight = ellipseGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);\n        var options = {\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            ellipsoid : ellipseGeometry._ellipsoid,\n            rotation : ellipseGeometry._rotation,\n            height : height,\n            granularity : ellipseGeometry._granularity,\n            vertexFormat : ellipseGeometry._vertexFormat,\n            stRotation : ellipseGeometry._stRotation\n        };\n        var geometry;\n        if (extrude) {\n            options.extrudedHeight = extrudedHeight;\n            options.shadowVolume = ellipseGeometry._shadowVolume;\n            options.offsetAttribute = ellipseGeometry._offsetAttribute;\n            geometry = computeExtrudedEllipse(options);\n        } else {\n            geometry = computeEllipse(options);\n\n            if (defined(ellipseGeometry._offsetAttribute)) {\n                var length = geometry.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                geometry.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : geometry.boundingSphere,\n            offsetAttribute : ellipseGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    EllipseGeometry.createShadowVolume = function(ellipseGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = ellipseGeometry._granularity;\n        var ellipsoid = ellipseGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new EllipseGeometry({\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            ellipsoid : ellipsoid,\n            rotation : ellipseGeometry._rotation,\n            stRotation : ellipseGeometry._stRotation,\n            granularity : granularity,\n            extrudedHeight : minHeight,\n            height : maxHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume: true\n        });\n    };\n\n    function textureCoordinateRotationPoints(ellipseGeometry) {\n        var stRotation = -ellipseGeometry._stRotation;\n        if (stRotation === 0.0) {\n            return [0, 0, 0, 1, 1, 0];\n        }\n\n        var cep = EllipseGeometryLibrary.computeEllipsePositions({\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            rotation : ellipseGeometry._rotation,\n            granularity : ellipseGeometry._granularity\n        }, false, true);\n        var positionsFlat = cep.outerPositions;\n        var positionsCount = positionsFlat.length / 3;\n        var positions = new Array(positionsCount);\n        for (var i = 0; i < positionsCount; ++i) {\n            positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n        }\n\n        var ellipsoid = ellipseGeometry._ellipsoid;\n        var boundingRectangle = ellipseGeometry.rectangle;\n        return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);\n    }\n\n    defineProperties(EllipseGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rectangle)) {\n                    this._rectangle = computeRectangle(this._center, this._semiMajorAxis, this._semiMinorAxis, this._rotation, this._granularity, this._ellipsoid);\n                }\n                return this._rectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering EllipseGeometries as GroundPrimitives.\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                if (!defined(this._textureCoordinateRotationPoints)) {\n                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n                }\n                return this._textureCoordinateRotationPoints;\n            }\n        }\n    });\nexport default EllipseGeometry;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport EllipseGeometryLibrary from './EllipseGeometryLibrary.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    var scratchCartesian1 = new Cartesian3();\n    var boundingSphereCenter = new Cartesian3();\n\n    function computeEllipse(options) {\n        var center = options.center;\n        boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);\n        boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);\n        var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);\n        var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\n\n        var attributes = new GeometryAttributes({\n            position: new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : EllipseGeometryLibrary.raisePositionsToHeight(positions, options, false)\n            })\n        });\n\n        var length = positions.length / 3;\n        var indices = IndexDatatype.createTypedArray(length, length * 2);\n        var index = 0;\n        for ( var i = 0; i < length; ++i) {\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n        }\n\n        return {\n            boundingSphere : boundingSphere,\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    var topBoundingSphere = new BoundingSphere();\n    var bottomBoundingSphere = new BoundingSphere();\n    function computeExtrudedEllipse(options) {\n        var center = options.center;\n        var ellipsoid = options.ellipsoid;\n        var semiMajorAxis = options.semiMajorAxis;\n        var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);\n        topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);\n        topBoundingSphere.radius = semiMajorAxis;\n\n        scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);\n        bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);\n        bottomBoundingSphere.radius = semiMajorAxis;\n\n        var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\n        var attributes = new GeometryAttributes({\n            position: new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : EllipseGeometryLibrary.raisePositionsToHeight(positions, options, true)\n            })\n        });\n\n        positions = attributes.position.values;\n        var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);\n        var length = positions.length/3;\n\n        if (defined(options.offsetAttribute)) {\n            var applyOffset = new Uint8Array(length);\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                applyOffset = arrayFill(applyOffset, 1, 0, length / 2);\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                applyOffset = arrayFill(applyOffset, offsetValue);\n            }\n\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        var numberOfVerticalLines = defaultValue(options.numberOfVerticalLines, 16);\n        numberOfVerticalLines = CesiumMath.clamp(numberOfVerticalLines, 0, length/2);\n\n        var indices = IndexDatatype.createTypedArray(length, length * 2 + numberOfVerticalLines * 2);\n\n        length /= 2;\n        var index = 0;\n        var i;\n        for (i = 0; i < length; ++i) {\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n            indices[index++] = i + length;\n            indices[index++] = ((i + 1) % length) + length;\n        }\n\n        var numSide;\n        if (numberOfVerticalLines > 0) {\n            var numSideLines = Math.min(numberOfVerticalLines, length);\n            numSide = Math.round(length / numSideLines);\n\n            var maxI = Math.min(numSide * numberOfVerticalLines, length);\n            for (i = 0; i < maxI; i += numSide) {\n                indices[index++] = i;\n                indices[index++] = i + length;\n            }\n        }\n\n        return {\n            boundingSphere : boundingSphere,\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    /**\n     * A description of the outline of an ellipse on an ellipsoid.\n     *\n     * @alias EllipseOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n     * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n     * @param {Number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.\n     * @param {Number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.\n     * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.\n     *\n     * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n     * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n     * @exception {DeveloperError} granularity must be greater than zero.\n     *\n     * @see EllipseOutlineGeometry.createGeometry\n     *\n     * @example\n     * var ellipse = new Cesium.EllipseOutlineGeometry({\n     *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n     *   semiMajorAxis : 500000.0,\n     *   semiMinorAxis : 300000.0,\n     *   rotation : Cesium.Math.toRadians(60.0)\n     * });\n     * var geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);\n     */\n    function EllipseOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var center = options.center;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._center = Cartesian3.clone(center);\n        this._semiMajorAxis = semiMajorAxis;\n        this._semiMinorAxis = semiMinorAxis;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._rotation = defaultValue(options.rotation, 0.0);\n        this._height = Math.max(extrudedHeight, height);\n        this._granularity = granularity;\n        this._extrudedHeight = Math.min(extrudedHeight, height);\n        this._numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createEllipseOutlineGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    EllipseOutlineGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + 8;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {EllipseOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    EllipseOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        Cartesian3.pack(value._center, array, startingIndex);\n        startingIndex += Cartesian3.packedLength;\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._semiMajorAxis;\n        array[startingIndex++] = value._semiMinorAxis;\n        array[startingIndex++] = value._rotation;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++]   = value._numberOfVerticalLines;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchCenter = new Cartesian3();\n    var scratchEllipsoid = new Ellipsoid();\n    var scratchOptions = {\n        center : scratchCenter,\n        ellipsoid : scratchEllipsoid,\n        semiMajorAxis : undefined,\n        semiMinorAxis : undefined,\n        rotation : undefined,\n        height : undefined,\n        granularity : undefined,\n        extrudedHeight : undefined,\n        numberOfVerticalLines : undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {EllipseOutlineGeometry} [result] The object into which to store the result.\n     * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.\n     */\n    EllipseOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n        startingIndex += Cartesian3.packedLength;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var semiMajorAxis = array[startingIndex++];\n        var semiMinorAxis = array[startingIndex++];\n        var rotation = array[startingIndex++];\n        var height = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var numberOfVerticalLines = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.granularity = granularity;\n            scratchOptions.rotation = rotation;\n            scratchOptions.semiMajorAxis = semiMajorAxis;\n            scratchOptions.semiMinorAxis = semiMinorAxis;\n            scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new EllipseOutlineGeometry(scratchOptions);\n        }\n\n        result._center = Cartesian3.clone(center, result._center);\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._semiMajorAxis = semiMajorAxis;\n        result._semiMinorAxis = semiMinorAxis;\n        result._rotation = rotation;\n        result._height = height;\n        result._granularity = granularity;\n        result._extrudedHeight = extrudedHeight;\n        result._numberOfVerticalLines = numberOfVerticalLines;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    EllipseOutlineGeometry.createGeometry = function(ellipseGeometry) {\n        if ((ellipseGeometry._semiMajorAxis <= 0.0) || (ellipseGeometry._semiMinorAxis <= 0.0)) {\n            return;\n        }\n\n        var height = ellipseGeometry._height;\n        var extrudedHeight = ellipseGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);\n        var options = {\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            ellipsoid : ellipseGeometry._ellipsoid,\n            rotation : ellipseGeometry._rotation,\n            height : height,\n            granularity : ellipseGeometry._granularity,\n            numberOfVerticalLines : ellipseGeometry._numberOfVerticalLines\n        };\n        var geometry;\n        if (extrude) {\n            options.extrudedHeight = extrudedHeight;\n            options.offsetAttribute = ellipseGeometry._offsetAttribute;\n            geometry = computeExtrudedEllipse(options);\n        } else {\n            geometry = computeEllipse(options);\n\n            if (defined(ellipseGeometry._offsetAttribute)) {\n                var length = geometry.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                geometry.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : geometry.boundingSphere,\n            offsetAttribute : ellipseGeometry._offsetAttribute\n        });\n    };\nexport default EllipseOutlineGeometry;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport EllipseGeometry from '../Core/EllipseGeometry.js';\nimport EllipseOutlineGeometry from '../Core/EllipseOutlineGeometry.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport Rectangle from '../Core/Rectangle.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport GroundGeometryUpdater from './GroundGeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n\n    function EllipseGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.center = undefined;\n        this.semiMajorAxis = undefined;\n        this.semiMinorAxis = undefined;\n        this.rotation = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.stRotation = undefined;\n        this.numberOfVerticalLines = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for ellipses.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias EllipseGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function EllipseGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new EllipseGeometryOptions(entity),\n            geometryPropertyName : 'ellipse',\n            observedPropertyNames : ['availability', 'position', 'ellipse']\n        });\n\n        this._onEntityPropertyChanged(entity, 'ellipse', entity.ellipse, undefined);\n    }\n\n    if (defined(Object.create)) {\n        EllipseGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        EllipseGeometryUpdater.prototype.constructor = EllipseGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    EllipseGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipseGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    EllipseGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipseOutlineGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    EllipseGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    EllipseGeometryUpdater.prototype._isHidden = function(entity, ellipse) {\n        var position = entity.position;\n\n        return !defined(position) || !defined(ellipse.semiMajorAxis) || !defined(ellipse.semiMinorAxis) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipse);\n    };\n\n    EllipseGeometryUpdater.prototype._isDynamic = function(entity, ellipse) {\n        return !entity.position.isConstant || //\n               !ellipse.semiMajorAxis.isConstant || //\n               !ellipse.semiMinorAxis.isConstant || //\n               !Property.isConstant(ellipse.rotation) || //\n               !Property.isConstant(ellipse.height) || //\n               !Property.isConstant(ellipse.extrudedHeight) || //\n               !Property.isConstant(ellipse.granularity) || //\n               !Property.isConstant(ellipse.stRotation) || //\n               !Property.isConstant(ellipse.outlineWidth) || //\n               !Property.isConstant(ellipse.numberOfVerticalLines) || //\n               !Property.isConstant(ellipse.zIndex) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    EllipseGeometryUpdater.prototype._setStaticOptions = function(entity, ellipse) {\n        var heightValue = Property.getValueOrUndefined(ellipse.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        var options = this._options;\n        options.vertexFormat = (this._materialProperty instanceof ColorMaterialProperty) ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.center = entity.position.getValue(Iso8601.MINIMUM_VALUE, options.center);\n        options.semiMajorAxis = ellipse.semiMajorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMajorAxis);\n        options.semiMinorAxis = ellipse.semiMinorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMinorAxis);\n        options.rotation = Property.getValueOrUndefined(ellipse.rotation, Iso8601.MINIMUM_VALUE);\n        options.granularity = Property.getValueOrUndefined(ellipse.granularity, Iso8601.MINIMUM_VALUE);\n        options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, Iso8601.MINIMUM_VALUE);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    EllipseGeometryUpdater.DynamicGeometryUpdater = DynamicEllipseGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicEllipseGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicEllipseGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicEllipseGeometryUpdater.prototype.constructor = DynamicEllipseGeometryUpdater;\n    }\n\n    DynamicEllipseGeometryUpdater.prototype._isHidden = function(entity, ellipse, time) {\n        var options = this._options;\n        return !defined(options.center) || !defined(options.semiMajorAxis) || !defined(options.semiMinorAxis) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, ellipse, time);\n    };\n\n    DynamicEllipseGeometryUpdater.prototype._setOptions = function(entity, ellipse, time) {\n        var options = this._options;\n        var heightValue = Property.getValueOrUndefined(ellipse.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, time);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, time, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        options.center = Property.getValueOrUndefined(entity.position, time, options.center);\n        options.semiMajorAxis = Property.getValueOrUndefined(ellipse.semiMajorAxis, time);\n        options.semiMinorAxis = Property.getValueOrUndefined(ellipse.semiMinorAxis, time);\n        options.rotation = Property.getValueOrUndefined(ellipse.rotation, time);\n        options.granularity = Property.getValueOrUndefined(ellipse.granularity, time);\n        options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, time);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, time);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\nexport default EllipseGeometryUpdater;\n","import Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport EllipsoidGeometry from '../Core/EllipsoidGeometry.js';\nimport EllipsoidOutlineGeometry from '../Core/EllipsoidOutlineGeometry.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport GeometryOffsetAttribute from '../Core/GeometryOffsetAttribute.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport Primitive from '../Scene/Primitive.js';\nimport SceneMode from '../Scene/SceneMode.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport heightReferenceOnEntityPropertyChanged from './heightReferenceOnEntityPropertyChanged.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);\n    var defaultOffset = Cartesian3.ZERO;\n\n    var offsetScratch = new Cartesian3();\n    var radiiScratch = new Cartesian3();\n    var innerRadiiScratch = new Cartesian3();\n    var scratchColor = new Color();\n    var unitSphere = new Cartesian3(1, 1, 1);\n\n    function EllipsoidGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.radii = undefined;\n        this.innerRadii = undefined;\n        this.minimumClock = undefined;\n        this.maximumClock = undefined;\n        this.minimumCone = undefined;\n        this.maximumCone = undefined;\n        this.stackPartitions = undefined;\n        this.slicePartitions = undefined;\n        this.subdivisions = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for ellipsoids.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias EllipsoidGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function EllipsoidGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new EllipsoidGeometryOptions(entity),\n            geometryPropertyName : 'ellipsoid',\n            observedPropertyNames : ['availability', 'position', 'orientation', 'ellipsoid']\n        });\n\n        this._onEntityPropertyChanged(entity, 'ellipsoid', entity.ellipsoid, undefined);\n    }\n\n    if (defined(Object.create)) {\n        EllipsoidGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        EllipsoidGeometryUpdater.prototype.constructor = EllipsoidGeometryUpdater;\n    }\n\n    defineProperties(EllipsoidGeometryUpdater.prototype, {\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof EllipsoidGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty : {\n            get : function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n     * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    EllipsoidGeometryUpdater.prototype.createFillGeometryInstance = function(time, skipModelMatrix, modelMatrixResult) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute,\n            color : undefined,\n            offset : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes.color = color;\n        }\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipsoidGeometry(this._options),\n            modelMatrix : skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.mapProjection.ellipsoid, modelMatrixResult),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n     * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    EllipsoidGeometryUpdater.prototype.createOutlineGeometryInstance = function(time, skipModelMatrix, modelMatrixResult) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipsoidOutlineGeometry(this._options),\n            modelMatrix : skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.mapProjection.ellipsoid, modelMatrixResult),\n            attributes : attributes\n        });\n    };\n\n    EllipsoidGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    EllipsoidGeometryUpdater.prototype._isHidden = function(entity, ellipsoid) {\n        return !defined(entity.position) || !defined(ellipsoid.radii) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipsoid);\n    };\n\n    EllipsoidGeometryUpdater.prototype._isDynamic = function(entity, ellipsoid) {\n        return !entity.position.isConstant || //\n               !Property.isConstant(entity.orientation) || //\n               !ellipsoid.radii.isConstant || //\n               !Property.isConstant(ellipsoid.innerRadii) || //\n               !Property.isConstant(ellipsoid.stackPartitions) || //\n               !Property.isConstant(ellipsoid.slicePartitions) || //\n               !Property.isConstant(ellipsoid.outlineWidth) || //\n               !Property.isConstant(ellipsoid.minimumClock) || //\n               !Property.isConstant(ellipsoid.maximumClock) || //\n               !Property.isConstant(ellipsoid.minimumCone) || //\n               !Property.isConstant(ellipsoid.maximumCone) || //\n               !Property.isConstant(ellipsoid.subdivisions);\n    };\n\n    EllipsoidGeometryUpdater.prototype._setStaticOptions = function(entity, ellipsoid) {\n        var heightReference = Property.getValueOrDefault(ellipsoid.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var options = this._options;\n        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.radii = ellipsoid.radii.getValue(Iso8601.MINIMUM_VALUE, options.radii);\n        options.innerRadii = Property.getValueOrUndefined(ellipsoid.innerRadii, options.radii);\n        options.minimumClock = Property.getValueOrUndefined(ellipsoid.minimumClock, Iso8601.MINIMUM_VALUE);\n        options.maximumClock = Property.getValueOrUndefined(ellipsoid.maximumClock, Iso8601.MINIMUM_VALUE);\n        options.minimumCone = Property.getValueOrUndefined(ellipsoid.minimumCone, Iso8601.MINIMUM_VALUE);\n        options.maximumCone = Property.getValueOrUndefined(ellipsoid.maximumCone, Iso8601.MINIMUM_VALUE);\n        options.stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, Iso8601.MINIMUM_VALUE);\n        options.slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, Iso8601.MINIMUM_VALUE);\n        options.subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    EllipsoidGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\n\n    EllipsoidGeometryUpdater.DynamicGeometryUpdater = DynamicEllipsoidGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicEllipsoidGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n\n        this._scene = geometryUpdater._scene;\n        this._modelMatrix = new Matrix4();\n        this._attributes = undefined;\n        this._outlineAttributes = undefined;\n        this._lastSceneMode = undefined;\n        this._lastShow = undefined;\n        this._lastOutlineShow = undefined;\n        this._lastOutlineWidth = undefined;\n        this._lastOutlineColor = undefined;\n        this._lastOffset = new Cartesian3();\n        this._material = {};\n    }\n\n    if (defined(Object.create)) {\n        DynamicEllipsoidGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicEllipsoidGeometryUpdater.prototype.constructor = DynamicEllipsoidGeometryUpdater;\n    }\n\n    DynamicEllipsoidGeometryUpdater.prototype.update = function(time) {\n        \n\n        var entity = this._entity;\n        var ellipsoid = entity.ellipsoid;\n        if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(ellipsoid.show, time, true)) {\n            if (defined(this._primitive)) {\n                this._primitive.show = false;\n            }\n\n            if (defined(this._outlinePrimitive)) {\n                this._outlinePrimitive.show = false;\n            }\n            return;\n        }\n\n        var radii = Property.getValueOrUndefined(ellipsoid.radii, time, radiiScratch);\n        var modelMatrix = defined(radii) ? entity.computeModelMatrixForHeightReference(time, ellipsoid.heightReference, radii.z * 0.5, this._scene.mapProjection.ellipsoid, this._modelMatrix) : undefined;\n        if (!defined(modelMatrix) || !defined(radii)) {\n            if (defined(this._primitive)) {\n                this._primitive.show = false;\n            }\n\n            if (defined(this._outlinePrimitive)) {\n                this._outlinePrimitive.show = false;\n            }\n            return;\n        }\n\n        //Compute attributes and material.\n        var showFill = Property.getValueOrDefault(ellipsoid.fill, time, true);\n        var showOutline = Property.getValueOrDefault(ellipsoid.outline, time, false);\n        var outlineColor = Property.getValueOrClonedDefault(ellipsoid.outlineColor, time, Color.BLACK, scratchColor);\n        var material = MaterialProperty.getValue(time, defaultValue(ellipsoid.material, defaultMaterial), this._material);\n\n        // Check properties that could trigger a primitive rebuild.\n        var innerRadii = Property.getValueOrUndefined(ellipsoid.innerRadii, time, innerRadiiScratch);\n        var minimumClock = Property.getValueOrUndefined(ellipsoid.minimumClock, time);\n        var maximumClock = Property.getValueOrUndefined(ellipsoid.maximumClock, time);\n        var minimumCone = Property.getValueOrUndefined(ellipsoid.minimumCone, time);\n        var maximumCone = Property.getValueOrUndefined(ellipsoid.maximumCone, time);\n        var stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, time);\n        var slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, time);\n        var subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, time);\n        var outlineWidth = Property.getValueOrDefault(ellipsoid.outlineWidth, time, 1.0);\n        var heightReference = Property.getValueOrDefault(ellipsoid.heightReference, time, HeightReference.NONE);\n        var offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n\n        //In 3D we use a fast path by modifying Primitive.modelMatrix instead of regenerating the primitive every frame.\n        //Also check for height reference because this method doesn't work when the height is relative to terrain.\n        var sceneMode = this._scene.mode;\n        var in3D = sceneMode === SceneMode.SCENE3D && heightReference === HeightReference.NONE;\n\n        var options = this._options;\n\n        var shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n\n        var distanceDisplayConditionProperty = this._geometryUpdater.distanceDisplayConditionProperty;\n        var distanceDisplayCondition = distanceDisplayConditionProperty.getValue(time);\n\n        var offset = Property.getValueOrDefault(this._geometryUpdater.terrainOffsetProperty, time, defaultOffset, offsetScratch);\n\n        //We only rebuild the primitive if something other than the radii has changed\n        //For the radii, we use unit sphere and then deform it with a scale matrix.\n        var rebuildPrimitives = !in3D || this._lastSceneMode !== sceneMode || !defined(this._primitive) || //\n                                options.stackPartitions !== stackPartitions || options.slicePartitions !== slicePartitions || //\n                                defined(innerRadii) && !Cartesian3.equals(options.innerRadii !== innerRadii) || options.minimumClock !== minimumClock || //\n                                options.maximumClock !== maximumClock || options.minimumCone !== minimumCone || //\n                                options.maximumCone !== maximumCone || options.subdivisions !== subdivisions || //\n                                this._lastOutlineWidth !== outlineWidth || options.offsetAttribute !== offsetAttribute;\n\n        if (rebuildPrimitives) {\n            var primitives = this._primitives;\n            primitives.removeAndDestroy(this._primitive);\n            primitives.removeAndDestroy(this._outlinePrimitive);\n            this._primitive = undefined;\n            this._outlinePrimitive = undefined;\n            this._lastSceneMode = sceneMode;\n            this._lastOutlineWidth = outlineWidth;\n\n            options.stackPartitions = stackPartitions;\n            options.slicePartitions = slicePartitions;\n            options.subdivisions = subdivisions;\n            options.offsetAttribute = offsetAttribute;\n            options.radii = Cartesian3.clone(in3D ? unitSphere : radii, options.radii);\n            if (defined(innerRadii)) {\n                if (in3D) {\n                    var mag = Cartesian3.magnitude(radii);\n                    options.innerRadii = Cartesian3.fromElements(innerRadii.x / mag, innerRadii.y / mag, innerRadii.z / mag, options.innerRadii);\n                } else {\n                    options.innerRadii = Cartesian3.clone(innerRadii, options.innerRadii);\n                }\n            } else {\n                options.innerRadii = undefined;\n            }\n            options.minimumClock = minimumClock;\n            options.maximumClock = maximumClock;\n            options.minimumCone = minimumCone;\n            options.maximumCone = maximumCone;\n\n            var appearance = new MaterialAppearance({\n                material : material,\n                translucent : material.isTranslucent(),\n                closed : true\n            });\n            options.vertexFormat = appearance.vertexFormat;\n\n            var fillInstance = this._geometryUpdater.createFillGeometryInstance(time, in3D, this._modelMatrix);\n\n            this._primitive = primitives.add(new Primitive({\n                geometryInstances : fillInstance,\n                appearance : appearance,\n                asynchronous : false,\n                shadows : shadows\n            }));\n\n            var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time, in3D, this._modelMatrix);\n            this._outlinePrimitive = primitives.add(new Primitive({\n                geometryInstances : outlineInstance,\n                appearance : new PerInstanceColorAppearance({\n                    flat : true,\n                    translucent : outlineInstance.attributes.color.value[3] !== 255,\n                    renderState : {\n                        lineWidth : this._geometryUpdater._scene.clampLineWidth(outlineWidth)\n                    }\n                }),\n                asynchronous : false,\n                shadows : shadows\n            }));\n\n            this._lastShow = showFill;\n            this._lastOutlineShow = showOutline;\n            this._lastOutlineColor = Color.clone(outlineColor, this._lastOutlineColor);\n            this._lastDistanceDisplayCondition = distanceDisplayCondition;\n            this._lastOffset = Cartesian3.clone(offset, this._lastOffset);\n        } else if (this._primitive.ready) {\n            //Update attributes only.\n            var primitive = this._primitive;\n            var outlinePrimitive = this._outlinePrimitive;\n\n            primitive.show = true;\n            outlinePrimitive.show = true;\n            primitive.appearance.material = material;\n\n            var attributes = this._attributes;\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(entity);\n                this._attributes = attributes;\n            }\n            if (showFill !== this._lastShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(showFill, attributes.show);\n                this._lastShow = showFill;\n            }\n\n            var outlineAttributes = this._outlineAttributes;\n\n            if (!defined(outlineAttributes)) {\n                outlineAttributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n                this._outlineAttributes = outlineAttributes;\n            }\n\n            if (showOutline !== this._lastOutlineShow) {\n                outlineAttributes.show = ShowGeometryInstanceAttribute.toValue(showOutline, outlineAttributes.show);\n                this._lastOutlineShow = showOutline;\n            }\n\n            if (!Color.equals(outlineColor, this._lastOutlineColor)) {\n                outlineAttributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, outlineAttributes.color);\n                Color.clone(outlineColor, this._lastOutlineColor);\n            }\n\n            if (!DistanceDisplayCondition.equals(distanceDisplayCondition, this._lastDistanceDisplayCondition)) {\n                attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                outlineAttributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, outlineAttributes.distanceDisplayCondition);\n                DistanceDisplayCondition.clone(distanceDisplayCondition, this._lastDistanceDisplayCondition);\n            }\n\n            if (!Cartesian3.equals(offset, this._lastOffset)) {\n                attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                outlineAttributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                Cartesian3.clone(offset, this._lastOffset);\n            }\n        }\n\n        if (in3D) {\n            //Since we are scaling a unit sphere, we can't let any of the values go to zero.\n            //Instead we clamp them to a small value.  To the naked eye, this produces the same results\n            //that you get passing EllipsoidGeometry a radii with a zero component.\n            radii.x = Math.max(radii.x, 0.001);\n            radii.y = Math.max(radii.y, 0.001);\n            radii.z = Math.max(radii.z, 0.001);\n\n            modelMatrix = Matrix4.multiplyByScale(modelMatrix, radii, modelMatrix);\n            this._primitive.modelMatrix = modelMatrix;\n            this._outlinePrimitive.modelMatrix = modelMatrix;\n        }\n    };\nexport default EllipsoidGeometryUpdater;\n","import BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\n\n    /**\n     * Describes geometry representing a plane centered at the origin, with a unit width and length.\n     *\n     * @alias PlaneGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @example\n     * var planeGeometry = new Cesium.PlaneGeometry({\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY\n     * });\n     */\n    function PlaneGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n        this._vertexFormat = vertexFormat;\n        this._workerName = 'createPlaneGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    PlaneGeometry.packedLength = VertexFormat.packedLength;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PlaneGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PlaneGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n\n        return array;\n    };\n\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        vertexFormat: scratchVertexFormat\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PlaneGeometry} [result] The object into which to store the result.\n     * @returns {PlaneGeometry} The modified result parameter or a new PlaneGeometry instance if one was not provided.\n     */\n    PlaneGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n\n        if (!defined(result)) {\n            return new PlaneGeometry(scratchOptions);\n        }\n\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n\n        return result;\n    };\n\n    var min = new Cartesian3(-0.5, -0.5, 0.0);\n    var max = new Cartesian3( 0.5,  0.5, 0.0);\n\n    /**\n     * Computes the geometric representation of a plane, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PlaneGeometry} planeGeometry A description of the plane.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PlaneGeometry.createGeometry = function(planeGeometry) {\n        var vertexFormat = planeGeometry._vertexFormat;\n\n        var attributes = new GeometryAttributes();\n        var indices;\n        var positions;\n\n        if (vertexFormat.position) {\n            // 4 corner points.  Duplicated 3 times each for each incident edge/face.\n            positions = new Float64Array(4 * 3);\n\n            // +z face\n            positions[0]  = min.x;\n            positions[1]  = min.y;\n            positions[2]  = 0.0;\n            positions[3]  = max.x;\n            positions[4]  = min.y;\n            positions[5]  = 0.0;\n            positions[6]  = max.x;\n            positions[7]  = max.y;\n            positions[8]  = 0.0;\n            positions[9]  = min.x;\n            positions[10] = max.y;\n            positions[11] = 0.0;\n\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : positions\n            });\n\n            if (vertexFormat.normal) {\n                var normals = new Float32Array(4 * 3);\n\n                // +z face\n                normals[0]  = 0.0;\n                normals[1]  = 0.0;\n                normals[2]  = 1.0;\n                normals[3]  = 0.0;\n                normals[4]  = 0.0;\n                normals[5]  = 1.0;\n                normals[6]  = 0.0;\n                normals[7]  = 0.0;\n                normals[8]  = 1.0;\n                normals[9]  = 0.0;\n                normals[10] = 0.0;\n                normals[11] = 1.0;\n\n                attributes.normal = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : normals\n                });\n            }\n\n            if (vertexFormat.st) {\n                var texCoords = new Float32Array(4 * 2);\n\n                // +z face\n                texCoords[0]  = 0.0;\n                texCoords[1]  = 0.0;\n                texCoords[2]  = 1.0;\n                texCoords[3]  = 0.0;\n                texCoords[4]  = 1.0;\n                texCoords[5]  = 1.0;\n                texCoords[6]  = 0.0;\n                texCoords[7]  = 1.0;\n\n                attributes.st = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 2,\n                    values : texCoords\n                });\n            }\n\n            if (vertexFormat.tangent) {\n                var tangents = new Float32Array(4 * 3);\n\n                // +z face\n                tangents[0]  = 1.0;\n                tangents[1]  = 0.0;\n                tangents[2]  = 0.0;\n                tangents[3]  = 1.0;\n                tangents[4]  = 0.0;\n                tangents[5]  = 0.0;\n                tangents[6]  = 1.0;\n                tangents[7]  = 0.0;\n                tangents[8]  = 0.0;\n                tangents[9]  = 1.0;\n                tangents[10] = 0.0;\n                tangents[11] = 0.0;\n\n                attributes.tangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : tangents\n                });\n            }\n\n            if (vertexFormat.bitangent) {\n                var bitangents = new Float32Array(4 * 3);\n\n                // +z face\n                bitangents[0] = 0.0;\n                bitangents[1] = 1.0;\n                bitangents[2] = 0.0;\n                bitangents[3] = 0.0;\n                bitangents[4] = 1.0;\n                bitangents[5] = 0.0;\n                bitangents[6] = 0.0;\n                bitangents[7] = 1.0;\n                bitangents[8] = 0.0;\n                bitangents[9] = 0.0;\n                bitangents[10] = 1.0;\n                bitangents[11] = 0.0;\n\n                attributes.bitangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : bitangents\n                });\n            }\n\n            // 2 triangles\n            indices = new Uint16Array(2 * 3);\n\n            // +z face\n            indices[0] = 0;\n            indices[1] = 1;\n            indices[2] = 2;\n            indices[3] = 0;\n            indices[4] = 2;\n            indices[5] = 3;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0))\n        });\n    };\nexport default PlaneGeometry;\n","import BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defined from './defined.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    /**\n     * Describes geometry representing the outline of a plane centered at the origin, with a unit width and length.\n     *\n     * @alias PlaneOutlineGeometry\n     * @constructor\n     *\n     */\n    function PlaneOutlineGeometry() {\n        this._workerName = 'createPlaneOutlineGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    PlaneOutlineGeometry.packedLength = 0;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PlaneOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PlaneOutlineGeometry.pack = function(value, array) {\n        \n\n        return array;\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PlaneOutlineGeometry} [result] The object into which to store the result.\n     * @returns {PlaneOutlineGeometry} The modified result parameter or a new PlaneOutlineGeometry instance if one was not provided.\n     */\n    PlaneOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        if (!defined(result)) {\n            return new PlaneOutlineGeometry();\n        }\n\n        return result;\n    };\n\n    var min = new Cartesian3(-0.5, -0.5, 0.0);\n    var max = new Cartesian3( 0.5,  0.5, 0.0);\n\n    /**\n     * Computes the geometric representation of an outline of a plane, including its vertices, indices, and a bounding sphere.\n     *\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PlaneOutlineGeometry.createGeometry = function() {\n        var attributes = new GeometryAttributes();\n        var indices = new Uint16Array(4 * 2);\n        var positions = new Float64Array(4 * 3);\n\n        positions[0] = min.x;\n        positions[1] = min.y;\n        positions[2] = min.z;\n        positions[3] = max.x;\n        positions[4] = min.y;\n        positions[5] = min.z;\n        positions[6] = max.x;\n        positions[7] = max.y;\n        positions[8] = min.z;\n        positions[9] = min.x;\n        positions[10] = max.y;\n        positions[11] = min.z;\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : positions\n        });\n\n        indices[0] = 0;\n        indices[1] = 1;\n        indices[2] = 1;\n        indices[3] = 2;\n        indices[4] = 2;\n        indices[5] = 3;\n        indices[6] = 3;\n        indices[7] = 0;\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0))\n        });\n    };\nexport default PlaneOutlineGeometry;\n","import Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport CesiumMath from '../Core/Math.js';\nimport Matrix3 from '../Core/Matrix3.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport PlaneGeometry from '../Core/PlaneGeometry.js';\nimport PlaneOutlineGeometry from '../Core/PlaneOutlineGeometry.js';\nimport Quaternion from '../Core/Quaternion.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport Property from './Property.js';\n\n    var positionScratch = new Cartesian3();\n    var scratchColor = new Color();\n\n    function PlaneGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.plane = undefined;\n        this.dimensions = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for planes.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PlaneGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PlaneGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new PlaneGeometryOptions(entity),\n            geometryPropertyName : 'plane',\n            observedPropertyNames : ['availability', 'position', 'orientation', 'plane']\n        });\n\n        this._onEntityPropertyChanged(entity, 'plane', entity.plane, undefined);\n    }\n\n    if (defined(Object.create)) {\n        PlaneGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        PlaneGeometryUpdater.prototype.constructor = PlaneGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PlaneGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes;\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute,\n                color : color\n            };\n        } else {\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute\n            };\n        }\n\n        var planeGraphics = entity.plane;\n        var options = this._options;\n        var modelMatrix = entity.computeModelMatrix(time);\n        var plane = Property.getValueOrDefault(planeGraphics.plane, time, options.plane);\n        var dimensions = Property.getValueOrUndefined(planeGraphics.dimensions, time, options.dimensions);\n\n        options.plane = plane;\n        options.dimensions = dimensions;\n\n        modelMatrix = createPrimitiveMatrix(plane, dimensions, modelMatrix, this._scene.mapProjection.ellipsoid, modelMatrix);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PlaneGeometry(this._options),\n            modelMatrix : modelMatrix,\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PlaneGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var planeGraphics = entity.plane;\n        var options = this._options;\n        var modelMatrix = entity.computeModelMatrix(time);\n        var plane = Property.getValueOrDefault(planeGraphics.plane, time, options.plane);\n        var dimensions = Property.getValueOrUndefined(planeGraphics.dimensions, time, options.dimensions);\n\n        options.plane = plane;\n        options.dimensions = dimensions;\n\n        modelMatrix = createPrimitiveMatrix(plane, dimensions, modelMatrix, this._scene.mapProjection.ellipsoid, modelMatrix);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PlaneOutlineGeometry(),\n            modelMatrix : modelMatrix,\n            attributes : {\n                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n            }\n        });\n    };\n\n    PlaneGeometryUpdater.prototype._isHidden = function(entity, plane) {\n        return !defined(plane.plane) || !defined(plane.dimensions) || !defined(entity.position) || GeometryUpdater.prototype._isHidden.call(this, entity, plane);\n    };\n\n    PlaneGeometryUpdater.prototype._getIsClosed = function(options) {\n        return false;\n    };\n\n    PlaneGeometryUpdater.prototype._isDynamic = function(entity, plane) {\n        return !entity.position.isConstant || //\n               !Property.isConstant(entity.orientation) || //\n               !plane.plane.isConstant || //\n               !plane.dimensions.isConstant || //\n               !Property.isConstant(plane.outlineWidth);\n    };\n\n    PlaneGeometryUpdater.prototype._setStaticOptions = function(entity, plane) {\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.plane = plane.plane.getValue(Iso8601.MINIMUM_VALUE, options.plane);\n        options.dimensions = plane.dimensions.getValue(Iso8601.MINIMUM_VALUE, options.dimensions);\n    };\n\n    PlaneGeometryUpdater.DynamicGeometryUpdater = DynamicPlaneGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicPlaneGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicPlaneGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicPlaneGeometryUpdater.prototype.constructor = DynamicPlaneGeometryUpdater;\n    }\n\n    DynamicPlaneGeometryUpdater.prototype._isHidden = function(entity, plane, time) {\n        var options = this._options;\n        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n        return !defined(position) || !defined(options.plane) || !defined(options.dimensions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, plane, time);\n    };\n\n    DynamicPlaneGeometryUpdater.prototype._setOptions = function(entity, plane, time) {\n        var options = this._options;\n        options.plane = Property.getValueOrDefault(plane.plane, time, options.plane);\n        options.dimensions = Property.getValueOrUndefined(plane.dimensions, time, options.dimensions);\n    };\n\n    var scratchAxis = new Cartesian3();\n    var scratchAxis2 = new Cartesian3();\n    var scratchTranslation = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n    var scratchScale = new Cartesian3();\n    var scratchQuaternion = new Quaternion();\n    var scratchMatrix3 = new Matrix3();\n    function createPrimitiveMatrix(plane, dimensions, transform, ellipsoid, result) {\n        var normal = plane.normal;\n        var distance = plane.distance;\n\n        var translation = Cartesian3.multiplyByScalar(normal, -distance, scratchTranslation);\n        translation = Matrix4.multiplyByPoint(transform, translation, translation);\n\n        var transformedNormal = Matrix4.multiplyByPointAsVector(transform, normal, scratchNormal);\n        Cartesian3.normalize(transformedNormal, transformedNormal);\n\n        var up = ellipsoid.geodeticSurfaceNormal(translation, scratchAxis2);\n        if (CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(up, transformedNormal)), 1.0, CesiumMath.EPSILON8)) {\n            up = Cartesian3.clone(Cartesian3.UNIT_Z, up);\n        }\n\n        var left = Cartesian3.cross(up, transformedNormal, scratchAxis);\n        up = Cartesian3.cross(transformedNormal, left, up);\n        Cartesian3.normalize(left, left);\n        Cartesian3.normalize(up, up);\n\n        var rotationMatrix = scratchMatrix3;\n        Matrix3.setColumn(rotationMatrix, 0, left, rotationMatrix);\n        Matrix3.setColumn(rotationMatrix, 1, up, rotationMatrix);\n        Matrix3.setColumn(rotationMatrix, 2, transformedNormal, rotationMatrix);\n        var rotation = Quaternion.fromRotationMatrix(rotationMatrix, scratchQuaternion);\n\n        var scale = Cartesian2.clone(dimensions, scratchScale);\n        scale.z = 1.0;\n\n        return Matrix4.fromTranslationQuaternionRotationScale(translation, rotation, scale, result);\n    }\n\n    /**\n     * @private\n     */\n    PlaneGeometryUpdater.createPrimitiveMatrix = createPrimitiveMatrix;\nexport default PlaneGeometryUpdater;\n","import Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport Matrix3 from './Matrix3.js';\nimport OrientedBoundingBox from './OrientedBoundingBox.js';\n\n    /**\n     * @private\n     */\n    var CoplanarPolygonGeometryLibrary = {};\n\n    var scratchIntersectionPoint = new Cartesian3();\n    var scratchXAxis = new Cartesian3();\n    var scratchYAxis = new Cartesian3();\n    var scratchZAxis = new Cartesian3();\n    var obbScratch = new OrientedBoundingBox();\n\n    CoplanarPolygonGeometryLibrary.validOutline = function(positions) {\n        \n\n        var orientedBoundingBox = OrientedBoundingBox.fromPoints(positions, obbScratch);\n        var halfAxes = orientedBoundingBox.halfAxes;\n        var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n        var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n        var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n        var xMag = Cartesian3.magnitude(xAxis);\n        var yMag = Cartesian3.magnitude(yAxis);\n        var zMag = Cartesian3.magnitude(zAxis);\n\n        // If all the points are on a line return undefined because we can't draw a polygon\n        return !((xMag === 0 && (yMag === 0 || zMag === 0)) || (yMag === 0 && zMag === 0));\n    };\n\n    // call after removeDuplicates\n    CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments = function(positions, centerResult, planeAxis1Result, planeAxis2Result) {\n        \n\n        var orientedBoundingBox = OrientedBoundingBox.fromPoints(positions, obbScratch);\n        var halfAxes = orientedBoundingBox.halfAxes;\n        var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n        var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n        var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n        var xMag = Cartesian3.magnitude(xAxis);\n        var yMag = Cartesian3.magnitude(yAxis);\n        var zMag = Cartesian3.magnitude(zAxis);\n        var min = Math.min(xMag, yMag, zMag);\n\n        // If all the points are on a line return undefined because we can't draw a polygon\n        if ((xMag === 0 && (yMag === 0 || zMag === 0)) || (yMag === 0 && zMag === 0)) {\n            return false;\n        }\n\n        var planeAxis1;\n        var planeAxis2;\n\n        if (min === yMag || min === zMag) {\n            planeAxis1 = xAxis;\n        }\n        if (min === xMag) {\n            planeAxis1 = yAxis;\n        } else if (min === zMag) {\n            planeAxis2 = yAxis;\n        }\n        if (min === xMag || min === yMag) {\n            planeAxis2 = zAxis;\n        }\n\n        Cartesian3.normalize(planeAxis1, planeAxis1Result);\n        Cartesian3.normalize(planeAxis2, planeAxis2Result);\n        Cartesian3.clone(orientedBoundingBox.center, centerResult);\n        return true;\n    };\n\n    function projectTo2D(position, center, axis1, axis2, result) {\n        var v = Cartesian3.subtract(position, center, scratchIntersectionPoint);\n        var x = Cartesian3.dot(axis1, v);\n        var y = Cartesian3.dot(axis2, v);\n\n        return Cartesian2.fromElements(x, y, result);\n    }\n\n    CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction = function(center, axis1, axis2) {\n        return function(positions) {\n            var positionResults = new Array(positions.length);\n            for (var i = 0; i < positions.length; i++) {\n                positionResults[i] = projectTo2D(positions[i], center, axis1, axis2);\n            }\n\n            return positionResults;\n        };\n    };\n\n    CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction = function(center, axis1, axis2) {\n        return function(position, result) {\n            return projectTo2D(position, center, axis1, axis2, result);\n        };\n    };\nexport default CoplanarPolygonGeometryLibrary;\n","import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingRectangle from './BoundingRectangle.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CoplanarPolygonGeometryLibrary from './CoplanarPolygonGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport Quaternion from './Quaternion.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var scratchPosition = new Cartesian3();\n    var scratchBR = new BoundingRectangle();\n    var stScratch = new Cartesian2();\n    var textureCoordinatesOrigin = new Cartesian2();\n    var scratchNormal = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n    var centerScratch = new Cartesian3();\n    var axis1Scratch = new Cartesian3();\n    var axis2Scratch = new Cartesian3();\n    var quaternionScratch = new Quaternion();\n    var textureMatrixScratch = new Matrix3();\n    var tangentRotationScratch = new Matrix3();\n    var surfaceNormalScratch = new Cartesian3();\n\n    function createGeometryFromPolygon(polygon, vertexFormat, boundingRectangle, stRotation, projectPointTo2D, normal, tangent, bitangent) {\n        var positions = polygon.positions;\n        var indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n\n        /* If polygon is completely unrenderable, just use the first three vertices */\n        if (indices.length < 3) {\n            indices = [0, 1, 2];\n        }\n\n        var newIndices = IndexDatatype.createTypedArray(positions.length, indices.length);\n        newIndices.set(indices);\n\n        var textureMatrix = textureMatrixScratch;\n        if (stRotation !== 0.0) {\n            var rotation = Quaternion.fromAxisAngle(normal, stRotation, quaternionScratch);\n            textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n            if (vertexFormat.tangent || vertexFormat.bitangent) {\n                rotation = Quaternion.fromAxisAngle(normal, -stRotation, quaternionScratch);\n                var tangentRotation = Matrix3.fromQuaternion(rotation, tangentRotationScratch);\n\n                tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotation, tangent, tangent), tangent);\n                if (vertexFormat.bitangent) {\n                    bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                }\n            }\n        } else {\n            textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n        }\n\n        var stOrigin = textureCoordinatesOrigin;\n        if (vertexFormat.st) {\n            stOrigin.x = boundingRectangle.x;\n            stOrigin.y = boundingRectangle.y;\n        }\n\n        var length = positions.length;\n        var size = length * 3;\n        var flatPositions = new Float64Array(size);\n        var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n        var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n        var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n        var textureCoordinates = vertexFormat.st ? new Float32Array(length * 2) : undefined;\n\n        var positionIndex = 0;\n        var normalIndex = 0;\n        var bitangentIndex = 0;\n        var tangentIndex = 0;\n        var stIndex = 0;\n\n        for (var i = 0; i < length; i++) {\n            var position = positions[i];\n            flatPositions[positionIndex++] = position.x;\n            flatPositions[positionIndex++] = position.y;\n            flatPositions[positionIndex++] = position.z;\n\n            if (vertexFormat.st) {\n                var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);\n                var st = projectPointTo2D(p, stScratch);\n                Cartesian2.subtract(st, stOrigin, st);\n\n                var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n                var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n                textureCoordinates[stIndex++] = stx;\n                textureCoordinates[stIndex++] = sty;\n            }\n\n            if (vertexFormat.normal) {\n                normals[normalIndex++] = normal.x;\n                normals[normalIndex++] = normal.y;\n                normals[normalIndex++] = normal.z;\n            }\n\n            if (vertexFormat.tangent) {\n                tangents[tangentIndex++] = tangent.x;\n                tangents[tangentIndex++] = tangent.y;\n                tangents[tangentIndex++] = tangent.z;\n            }\n\n            if (vertexFormat.bitangent) {\n                bitangents[bitangentIndex++] = bitangent.x;\n                bitangents[bitangentIndex++] = bitangent.y;\n                bitangents[bitangentIndex++] = bitangent.z;\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : flatPositions\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : newIndices,\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n    }\n\n    /**\n     * A description of a polygon composed of arbitrary coplanar positions.\n     *\n     * @alias CoplanarPolygonGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     *\n     * @example\n     * var polygon = new Cesium.CoplanarPolygonGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *      -90.0, 30.0, 0.0,\n     *      -90.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 0.0\n     *   ])\n     * });\n     * var geometry = Cesium.CoplanarPolygonGeometry.createGeometry(polygon);\n     *\n     * @see CoplanarPolygonGeometry.createGeometry\n     */\n    function CoplanarPolygonGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var polygonHierarchy = options.polygonHierarchy;\n        \n\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._polygonHierarchy = polygonHierarchy;\n        this._stRotation = defaultValue(options.stRotation, 0.0);\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._workerName = 'createCoplanarPolygonGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + VertexFormat.packedLength + Ellipsoid.packedLength + 2;\n    }\n\n    /**\n     * A description of a coplanar polygon from an array of positions.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @returns {CoplanarPolygonGeometry}\n     *\n     * @example\n     * // create a polygon from points\n     * var polygon = Cesium.CoplanarPolygonGeometry.fromPositions({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0,\n     *     -75.0, 30.0,\n     *     -70.0, 30.0,\n     *     -68.0, 40.0\n     *   ])\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n     *\n     * @see PolygonGeometry#createGeometry\n     */\n    CoplanarPolygonGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            },\n            vertexFormat : options.vertexFormat,\n            stRotation : options.stRotation,\n            ellipsoid : options.ellipsoid\n        };\n        return new CoplanarPolygonGeometry(newOptions);\n    };\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CoplanarPolygonGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CoplanarPolygonGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        polygonHierarchy : {}\n    };\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CoplanarPolygonGeometry} [result] The object into which to store the result.\n     * @returns {CoplanarPolygonGeometry} The modified result parameter or a new CoplanarPolygonGeometry instance if one was not provided.\n     */\n    CoplanarPolygonGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var stRotation = array[startingIndex++];\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new CoplanarPolygonGeometry(scratchOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._stRotation = stRotation;\n        result.packedLength = packedLength;\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CoplanarPolygonGeometry} polygonGeometry A description of the polygon.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CoplanarPolygonGeometry.createGeometry = function(polygonGeometry) {\n        var vertexFormat = polygonGeometry._vertexFormat;\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n        var stRotation = polygonGeometry._stRotation;\n\n        var outerPositions = polygonHierarchy.positions;\n        outerPositions = arrayRemoveDuplicates(outerPositions, Cartesian3.equalsEpsilon, true);\n        if (outerPositions.length < 3) {\n            return;\n        }\n\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n        var axis1 = axis1Scratch;\n        var axis2 = axis2Scratch;\n\n        var validGeometry = CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(outerPositions, centerScratch, axis1, axis2);\n        if (!validGeometry) {\n            return undefined;\n        }\n\n        normal = Cartesian3.cross(axis1, axis2, normal);\n        normal = Cartesian3.normalize(normal, normal);\n\n        if (!Cartesian3.equalsEpsilon(centerScratch, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n            var surfaceNormal = polygonGeometry._ellipsoid.geodeticSurfaceNormal(centerScratch, surfaceNormalScratch);\n            if (Cartesian3.dot(normal, surfaceNormal) < 0) {\n                normal = Cartesian3.negate(normal, normal);\n                axis1 = Cartesian3.negate(axis1, axis1);\n            }\n        }\n\n        var projectPoints = CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(centerScratch, axis1, axis2);\n        var projectPoint = CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction(centerScratch, axis1, axis2);\n\n        if (vertexFormat.tangent) {\n            tangent = Cartesian3.clone(axis1, tangent);\n        }\n        if (vertexFormat.bitangent) {\n            bitangent = Cartesian3.clone(axis2, bitangent);\n        }\n\n        var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, projectPoints, false);\n        var hierarchy = results.hierarchy;\n        var polygons = results.polygons;\n\n        if (hierarchy.length === 0) {\n            return;\n        }\n        outerPositions = hierarchy[0].outerRing;\n\n        var boundingSphere = BoundingSphere.fromPoints(outerPositions);\n        var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(normal, projectPoint, outerPositions, stRotation, scratchBR);\n\n        var geometries = [];\n        for (var i = 0; i < polygons.length; i++) {\n            var geometryInstance = new GeometryInstance({\n                geometry : createGeometryFromPolygon(polygons[i], vertexFormat, boundingRectangle, stRotation, projectPoint, normal, tangent, bitangent)\n            });\n\n            geometries.push(geometryInstance);\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);\n        geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);\n\n        var attributes = geometry.attributes;\n        if (!vertexFormat.position) {\n            delete attributes.position;\n        }\n        return new Geometry({\n            attributes : attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere\n        });\n    };\nexport default CoplanarPolygonGeometry;\n","import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CoplanarPolygonGeometryLibrary from './CoplanarPolygonGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    function createGeometryFromPositions(positions){\n        var length = positions.length;\n        var flatPositions = new Float64Array(length * 3);\n        var indices = IndexDatatype.createTypedArray(length, length * 2);\n\n        var positionIndex = 0;\n        var index = 0;\n\n        for (var i = 0; i < length; i++) {\n            var position = positions[i];\n            flatPositions[positionIndex++] = position.x;\n            flatPositions[positionIndex++] = position.y;\n            flatPositions[positionIndex++] = position.z;\n\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n        }\n\n        var attributes = new GeometryAttributes({\n            position: new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : flatPositions\n            })\n        });\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES\n        });\n    }\n\n    /**\n     * A description of the outline of a polygon composed of arbitrary coplanar positions.\n     *\n     * @alias CoplanarPolygonOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     *\n     * @see CoplanarPolygonOutlineGeometry.createGeometry\n     *\n     * @example\n     * var polygonOutline = new Cesium.CoplanarPolygonOutlineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *      -90.0, 30.0, 0.0,\n     *      -90.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 0.0\n     *   ])\n     * });\n     * var geometry = Cesium.CoplanarPolygonOutlineGeometry.createGeometry(polygonOutline);\n     */\n    function CoplanarPolygonOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var polygonHierarchy = options.polygonHierarchy;\n        \n\n        this._polygonHierarchy = polygonHierarchy;\n        this._workerName = 'createCoplanarPolygonOutlineGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + 1;\n    }\n\n    /**\n     * A description of a coplanar polygon outline from an array of positions.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @returns {CoplanarPolygonOutlineGeometry}\n     */\n    CoplanarPolygonOutlineGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            }\n        };\n        return new CoplanarPolygonOutlineGeometry(newOptions);\n    };\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CoplanarPolygonOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CoplanarPolygonOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchOptions = {\n        polygonHierarchy : {}\n    };\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CoplanarPolygonOutlineGeometry} [result] The object into which to store the result.\n     * @returns {CoplanarPolygonOutlineGeometry} The modified result parameter or a new CoplanarPolygonOutlineGeometry instance if one was not provided.\n     */\n    CoplanarPolygonOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new CoplanarPolygonOutlineGeometry(scratchOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result.packedLength = packedLength;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CoplanarPolygonOutlineGeometry} polygonGeometry A description of the polygon.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CoplanarPolygonOutlineGeometry.createGeometry = function(polygonGeometry) {\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n\n        var outerPositions = polygonHierarchy.positions;\n        outerPositions = arrayRemoveDuplicates(outerPositions, Cartesian3.equalsEpsilon, true);\n        if (outerPositions.length < 3) {\n            return;\n        }\n        var isValid = CoplanarPolygonGeometryLibrary.validOutline(outerPositions);\n        if (!isValid) {\n            return undefined;\n        }\n\n        var polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(polygonHierarchy, false);\n\n        if (polygons.length === 0) {\n            return undefined;\n        }\n\n        var geometries = [];\n\n        for (var i = 0; i < polygons.length; i++) {\n            var geometryInstance = new GeometryInstance({\n                geometry : createGeometryFromPositions(polygons[i])\n            });\n            geometries.push(geometryInstance);\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        var boundingSphere = BoundingSphere.fromPoints(polygonHierarchy.positions);\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere\n        });\n    };\nexport default CoplanarPolygonOutlineGeometry;\n","import ArcType from './ArcType.js';\nimport arrayFill from './arrayFill.js';\nimport BoundingRectangle from './BoundingRectangle.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport EllipsoidGeodesic from './EllipsoidGeodesic.js';\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport Quaternion from './Quaternion.js';\nimport Rectangle from './Rectangle.js';\nimport VertexFormat from './VertexFormat.js';\nimport WindingOrder from './WindingOrder.js';\n\n    var scratchCarto1 = new Cartographic();\n    var scratchCarto2 = new Cartographic();\n    function adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\n        var carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\n        var height = carto1.height;\n        var p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\n        p1Carto.height = height;\n        ellipsoid.cartographicToCartesian(p1Carto, p1);\n\n        var p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\n        p2Carto.height = height - 100;\n        ellipsoid.cartographicToCartesian(p2Carto, p2);\n    }\n\n    var scratchBoundingRectangle = new BoundingRectangle();\n    var scratchPosition = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n    var p1Scratch = new Cartesian3();\n    var p2Scratch = new Cartesian3();\n    var scratchPerPosNormal = new Cartesian3();\n    var scratchPerPosTangent = new Cartesian3();\n    var scratchPerPosBitangent = new Cartesian3();\n\n    var appendTextureCoordinatesOrigin = new Cartesian2();\n    var appendTextureCoordinatesCartesian2 = new Cartesian2();\n    var appendTextureCoordinatesCartesian3 = new Cartesian3();\n    var appendTextureCoordinatesQuaternion = new Quaternion();\n    var appendTextureCoordinatesMatrix3 = new Matrix3();\n    var tangentMatrixScratch = new Matrix3();\n\n    function computeAttributes(options) {\n        var vertexFormat = options.vertexFormat;\n        var geometry = options.geometry;\n        var shadowVolume = options.shadowVolume;\n        var flatPositions = geometry.attributes.position.values;\n        var length = flatPositions.length;\n        var wall = options.wall;\n        var top = options.top || wall;\n        var bottom = options.bottom || wall;\n        if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n            // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\n            // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\n            var boundingRectangle = options.boundingRectangle;\n            var tangentPlane = options.tangentPlane;\n            var ellipsoid = options.ellipsoid;\n            var stRotation = options.stRotation;\n            var perPositionHeight = options.perPositionHeight;\n\n            var origin = appendTextureCoordinatesOrigin;\n            origin.x = boundingRectangle.x;\n            origin.y = boundingRectangle.y;\n\n            var textureCoordinates = vertexFormat.st ? new Float32Array(2 * (length / 3)) : undefined;\n            var normals;\n            if (vertexFormat.normal) {\n                if (perPositionHeight && top && !wall) {\n                    normals = geometry.attributes.normal.values;\n                } else {\n                    normals = new Float32Array(length);\n                }\n            }\n            var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n            var bitangents = vertexFormat.bitangent ? new Float32Array(length) : undefined;\n            var extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\n\n            var textureCoordIndex = 0;\n            var attrIndex = 0;\n\n            var normal = scratchNormal;\n            var tangent = scratchTangent;\n            var bitangent = scratchBitangent;\n            var recomputeNormal = true;\n\n            var textureMatrix = appendTextureCoordinatesMatrix3;\n            var tangentRotationMatrix = tangentMatrixScratch;\n            if (stRotation !== 0.0) {\n                var rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, stRotation, appendTextureCoordinatesQuaternion);\n                textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n                rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, -stRotation, appendTextureCoordinatesQuaternion);\n                tangentRotationMatrix = Matrix3.fromQuaternion(rotation, tangentRotationMatrix);\n            } else {\n                textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n                tangentRotationMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n            }\n\n            var bottomOffset = 0;\n            var bottomOffset2 = 0;\n\n            if (top && bottom) {\n                bottomOffset = length / 2;\n                bottomOffset2 = length / 3;\n\n                length /= 2;\n            }\n\n            for ( var i = 0; i < length; i += 3) {\n                var position = Cartesian3.fromArray(flatPositions, i, appendTextureCoordinatesCartesian3);\n\n                if (vertexFormat.st) {\n                    var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);\n                    p = ellipsoid.scaleToGeodeticSurface(p,p);\n                    var st = tangentPlane.projectPointOntoPlane(p, appendTextureCoordinatesCartesian2);\n                    Cartesian2.subtract(st, origin, st);\n\n                    var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n                    var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n                    if (bottom) {\n                        textureCoordinates[textureCoordIndex + bottomOffset2] = stx;\n                        textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;\n                    }\n                    if (top) {\n                        textureCoordinates[textureCoordIndex] = stx;\n                        textureCoordinates[textureCoordIndex + 1] = sty;\n                    }\n\n                    textureCoordIndex += 2;\n                }\n\n                if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n                    var attrIndex1 = attrIndex + 1;\n                    var attrIndex2 = attrIndex + 2;\n\n                    if (wall) {\n                        if (i + 3 < length) {\n                            var p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\n\n                            if (recomputeNormal) {\n                                var p2 = Cartesian3.fromArray(flatPositions, i + length, p2Scratch);\n                                if (perPositionHeight) {\n                                    adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\n                                }\n                                Cartesian3.subtract(p1, position, p1);\n                                Cartesian3.subtract(p2, position, p2);\n                                normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n                                recomputeNormal = false;\n                            }\n\n                            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) { // if we've reached a corner\n                                recomputeNormal = true;\n                            }\n                        }\n\n                        if (vertexFormat.tangent || vertexFormat.bitangent) {\n                            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\n                            if (vertexFormat.tangent) {\n                                tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                            }\n                        }\n                    } else {\n                        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n                        if (vertexFormat.tangent || vertexFormat.bitangent) {\n                            if (perPositionHeight) {\n                                scratchPerPosNormal = Cartesian3.fromArray(normals, attrIndex, scratchPerPosNormal);\n                                scratchPerPosTangent = Cartesian3.cross(Cartesian3.UNIT_Z, scratchPerPosNormal, scratchPerPosTangent);\n                                scratchPerPosTangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, scratchPerPosTangent, scratchPerPosTangent), scratchPerPosTangent);\n                                if (vertexFormat.bitangent) {\n                                    scratchPerPosBitangent = Cartesian3.normalize(Cartesian3.cross(scratchPerPosNormal, scratchPerPosTangent, scratchPerPosBitangent), scratchPerPosBitangent);\n                                }\n                            }\n\n                            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n                            tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent), tangent);\n                            if (vertexFormat.bitangent) {\n                                bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                            }\n                        }\n                    }\n\n                    if (vertexFormat.normal) {\n                        if (options.wall) {\n                            normals[attrIndex + bottomOffset] = normal.x;\n                            normals[attrIndex1 + bottomOffset] = normal.y;\n                            normals[attrIndex2 + bottomOffset] = normal.z;\n                        } else if (bottom){\n                            normals[attrIndex + bottomOffset] = -normal.x;\n                            normals[attrIndex1 + bottomOffset] = -normal.y;\n                            normals[attrIndex2 + bottomOffset] = -normal.z;\n                        }\n\n                        if ((top && !perPositionHeight) || wall) {\n                            normals[attrIndex] = normal.x;\n                            normals[attrIndex1] = normal.y;\n                            normals[attrIndex2] = normal.z;\n                        }\n                    }\n\n                    if (shadowVolume) {\n                        if (wall) {\n                            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n                        }\n                        extrudeNormals[attrIndex + bottomOffset] = -normal.x;\n                        extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\n                        extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\n                    }\n\n                    if (vertexFormat.tangent) {\n                        if (options.wall) {\n                            tangents[attrIndex + bottomOffset] = tangent.x;\n                            tangents[attrIndex1 + bottomOffset] = tangent.y;\n                            tangents[attrIndex2 + bottomOffset] = tangent.z;\n                        } else if (bottom) {\n                            tangents[attrIndex + bottomOffset] = -tangent.x;\n                            tangents[attrIndex1 + bottomOffset] = -tangent.y;\n                            tangents[attrIndex2 + bottomOffset] = -tangent.z;\n                        }\n\n                        if(top) {\n                            if (perPositionHeight) {\n                                tangents[attrIndex] = scratchPerPosTangent.x;\n                                tangents[attrIndex1] = scratchPerPosTangent.y;\n                                tangents[attrIndex2] = scratchPerPosTangent.z;\n                            } else {\n                                tangents[attrIndex] = tangent.x;\n                                tangents[attrIndex1] = tangent.y;\n                                tangents[attrIndex2] = tangent.z;\n                            }\n                        }\n                    }\n\n                    if (vertexFormat.bitangent) {\n                        if (bottom) {\n                            bitangents[attrIndex + bottomOffset] = bitangent.x;\n                            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\n                            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\n                        }\n                        if (top) {\n                            if (perPositionHeight) {\n                                bitangents[attrIndex] = scratchPerPosBitangent.x;\n                                bitangents[attrIndex1] = scratchPerPosBitangent.y;\n                                bitangents[attrIndex2] = scratchPerPosBitangent.z;\n                            } else {\n                                bitangents[attrIndex] = bitangent.x;\n                                bitangents[attrIndex1] = bitangent.y;\n                                bitangents[attrIndex2] = bitangent.z;\n                            }\n                        }\n                    }\n                    attrIndex += 3;\n                }\n            }\n\n            if (vertexFormat.st) {\n                geometry.attributes.st = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 2,\n                    values : textureCoordinates\n                });\n            }\n\n            if (vertexFormat.normal) {\n                geometry.attributes.normal = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : normals\n                });\n            }\n\n            if (vertexFormat.tangent) {\n                geometry.attributes.tangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : tangents\n                });\n            }\n\n            if (vertexFormat.bitangent) {\n                geometry.attributes.bitangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : bitangents\n                });\n            }\n\n            if (shadowVolume) {\n                geometry.attributes.extrudeDirection = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : extrudeNormals\n                });\n            }\n        }\n\n        if (options.extrude && defined(options.offsetAttribute)) {\n            var size = flatPositions.length / 3;\n            var offsetAttribute = new Uint8Array(size);\n\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                if ((top && bottom) || wall) {\n                    offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n                } else if (top) {\n                    offsetAttribute = arrayFill(offsetAttribute, 1);\n                }\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n\n            geometry.attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        return geometry;\n    }\n\n    var startCartographicScratch = new Cartographic();\n    var endCartographicScratch = new Cartographic();\n    var idlCross = {\n        westOverIDL : 0.0,\n        eastOverIDL : 0.0\n    };\n    var ellipsoidGeodesic = new EllipsoidGeodesic();\n    function computeRectangle(positions, ellipsoid, arcType, granularity, result) {\n        result = defaultValue(result, new Rectangle());\n        if (!defined(positions) || positions.length < 3) {\n            result.west = 0.0;\n            result.north = 0.0;\n            result.south = 0.0;\n            result.east = 0.0;\n            return result;\n        }\n\n        if (arcType === ArcType.RHUMB) {\n            return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n        }\n\n        if (!ellipsoidGeodesic.ellipsoid.equals(ellipsoid)) {\n            ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\n        }\n\n        result.west = Number.POSITIVE_INFINITY;\n        result.east = Number.NEGATIVE_INFINITY;\n        result.south = Number.POSITIVE_INFINITY;\n        result.north = Number.NEGATIVE_INFINITY;\n\n        idlCross.westOverIDL = Number.POSITIVE_INFINITY;\n        idlCross.eastOverIDL = Number.NEGATIVE_INFINITY;\n\n        var inverseChordLength = 1.0 / CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n        var positionsLength = positions.length;\n        var endCartographic = ellipsoid.cartesianToCartographic(positions[0], endCartographicScratch);\n        var startCartographic = startCartographicScratch;\n        var swap;\n\n        for (var i = 1; i < positionsLength; i++) {\n            swap = startCartographic;\n            startCartographic = endCartographic;\n            endCartographic = ellipsoid.cartesianToCartographic(positions[i], swap);\n            ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n            interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);\n        }\n\n        swap = startCartographic;\n        startCartographic = endCartographic;\n        endCartographic = ellipsoid.cartesianToCartographic(positions[0], swap);\n        ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n        interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);\n\n        if (result.east - result.west > idlCross.eastOverIDL - idlCross.westOverIDL) {\n            result.west = idlCross.westOverIDL;\n            result.east = idlCross.eastOverIDL;\n\n            if (result.east > CesiumMath.PI) {\n                result.east = result.east - CesiumMath.TWO_PI;\n            }\n            if (result.west > CesiumMath.PI) {\n                result.west = result.west - CesiumMath.TWO_PI;\n            }\n        }\n\n        return result;\n    }\n\n    var interpolatedCartographicScratch = new Cartographic();\n    function interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross) {\n        var segmentLength = ellipsoidGeodesic.surfaceDistance;\n\n        var numPoints = Math.ceil(segmentLength * inverseChordLength);\n        var subsegmentDistance = numPoints > 0 ? segmentLength / (numPoints - 1) : Number.POSITIVE_INFINITY;\n        var interpolationDistance = 0.0;\n\n        for (var i = 0; i < numPoints; i++) {\n            var interpolatedCartographic = ellipsoidGeodesic.interpolateUsingSurfaceDistance(interpolationDistance, interpolatedCartographicScratch);\n            interpolationDistance += subsegmentDistance;\n            var longitude = interpolatedCartographic.longitude;\n            var latitude = interpolatedCartographic.latitude;\n\n            result.west = Math.min(result.west, longitude);\n            result.east = Math.max(result.east, longitude);\n            result.south = Math.min(result.south, latitude);\n            result.north = Math.max(result.north, latitude);\n\n            var lonAdjusted = longitude >= 0 ?  longitude : longitude +  CesiumMath.TWO_PI;\n            idlCross.westOverIDL = Math.min(idlCross.westOverIDL, lonAdjusted);\n            idlCross.eastOverIDL = Math.max(idlCross.eastOverIDL, lonAdjusted);\n        }\n    }\n\n    var createGeometryFromPositionsExtrudedPositions = [];\n\n    function createGeometryFromPositionsExtruded(ellipsoid, polygon, granularity, hierarchy, perPositionHeight, closeTop, closeBottom, vertexFormat, arcType) {\n        var geos = {\n            walls : []\n        };\n        var i;\n\n        if (closeTop || closeBottom) {\n            var topGeo = PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygon, granularity, perPositionHeight, vertexFormat, arcType);\n\n            var edgePoints = topGeo.attributes.position.values;\n            var indices = topGeo.indices;\n            var numPositions;\n            var newIndices;\n\n            if (closeTop && closeBottom) {\n                var topBottomPositions = edgePoints.concat(edgePoints);\n\n                numPositions = topBottomPositions.length / 3;\n\n                newIndices = IndexDatatype.createTypedArray(numPositions, indices.length * 2);\n                newIndices.set(indices);\n                var ilength = indices.length;\n\n                var length = numPositions / 2;\n\n                for (i = 0; i < ilength; i += 3) {\n                    var i0 = newIndices[i] + length;\n                    var i1 = newIndices[i + 1] + length;\n                    var i2 = newIndices[i + 2] + length;\n\n                    newIndices[i + ilength] = i2;\n                    newIndices[i + 1 + ilength] = i1;\n                    newIndices[i + 2 + ilength] = i0;\n                }\n\n                topGeo.attributes.position.values = topBottomPositions;\n                if (perPositionHeight && vertexFormat.normal) {\n                    var normals = topGeo.attributes.normal.values;\n                    topGeo.attributes.normal.values = new Float32Array(topBottomPositions.length);\n                    topGeo.attributes.normal.values.set(normals);\n                }\n                topGeo.indices = newIndices;\n            } else if (closeBottom) {\n                numPositions = edgePoints.length / 3;\n                newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\n\n                for (i = 0; i < indices.length; i += 3) {\n                    newIndices[i] = indices[i + 2];\n                    newIndices[i + 1] = indices[i + 1];\n                    newIndices[i + 2] = indices[i];\n                }\n\n                topGeo.indices = newIndices;\n            }\n\n            geos.topAndBottom = new GeometryInstance({\n                geometry : topGeo\n            });\n        }\n\n        var outerRing = hierarchy.outerRing;\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(outerRing, createGeometryFromPositionsExtrudedPositions);\n\n        var windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n        if (windingOrder === WindingOrder.CLOCKWISE) {\n            outerRing = outerRing.slice().reverse();\n        }\n\n        var wallGeo = PolygonGeometryLibrary.computeWallGeometry(outerRing, ellipsoid, granularity, perPositionHeight, arcType);\n        geos.walls.push(new GeometryInstance({\n            geometry : wallGeo\n        }));\n\n        var holes = hierarchy.holes;\n        for (i = 0; i < holes.length; i++) {\n            var hole = holes[i];\n\n            tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);\n            positions2D = tangentPlane.projectPointsOntoPlane(hole, createGeometryFromPositionsExtrudedPositions);\n\n            windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n            if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\n                hole = hole.slice().reverse();\n            }\n\n            wallGeo = PolygonGeometryLibrary.computeWallGeometry(hole, ellipsoid, granularity, perPositionHeight, arcType);\n            geos.walls.push(new GeometryInstance({\n                geometry : wallGeo\n            }));\n        }\n\n        return geos;\n    }\n\n    /**\n     * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias PolygonGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n     * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     *\n     * @see PolygonGeometry#createGeometry\n     * @see PolygonGeometry#fromPositions\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\n     *\n     * @example\n     * // 1. create a polygon from points\n     * var polygon = new Cesium.PolygonGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   )\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n     *\n     * // 2. create a nested polygon with holes\n     * var polygonWithHole = new Cesium.PolygonGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -109.0, 30.0,\n     *       -95.0, 30.0,\n     *       -95.0, 40.0,\n     *       -109.0, 40.0\n     *     ]),\n     *     [new Cesium.PolygonHierarchy(\n     *       Cesium.Cartesian3.fromDegreesArray([\n     *         -107.0, 31.0,\n     *         -107.0, 39.0,\n     *         -97.0, 39.0,\n     *         -97.0, 31.0\n     *       ]),\n     *       [new Cesium.PolygonHierarchy(\n     *         Cesium.Cartesian3.fromDegreesArray([\n     *           -105.0, 33.0,\n     *           -99.0, 33.0,\n     *           -99.0, 37.0,\n     *           -105.0, 37.0\n     *         ]),\n     *         [new Cesium.PolygonHierarchy(\n     *           Cesium.Cartesian3.fromDegreesArray([\n     *             -103.0, 34.0,\n     *             -101.0, 34.0,\n     *             -101.0, 36.0,\n     *             -103.0, 36.0\n     *           ])\n     *         )]\n     *       )]\n     *     )]\n     *   )\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\n     *\n     * // 3. create extruded polygon\n     * var extrudedPolygon = new Cesium.PolygonGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   ),\n     *   extrudedHeight: 300000\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\n     */\n    function PolygonGeometry(options) {\n        \n\n        var polygonHierarchy = options.polygonHierarchy;\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var stRotation = defaultValue(options.stRotation, 0.0);\n        var perPositionHeight = defaultValue(options.perPositionHeight, false);\n        var perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        if (!perPositionHeightExtrude) {\n            var h = Math.max(height, extrudedHeight);\n            extrudedHeight = Math.min(height, extrudedHeight);\n            height = h;\n        }\n\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._granularity = granularity;\n        this._stRotation = stRotation;\n        this._height = height;\n        this._extrudedHeight = extrudedHeight;\n        this._closeTop = defaultValue(options.closeTop, true);\n        this._closeBottom = defaultValue(options.closeBottom, true);\n        this._polygonHierarchy = polygonHierarchy;\n        this._perPositionHeight = perPositionHeight;\n        this._perPositionHeightExtrude = perPositionHeightExtrude;\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createPolygonGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n        this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n        this._rectangle = undefined;\n        this._textureCoordinateRotationPoints = undefined;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + VertexFormat.packedLength + 12;\n    }\n\n    /**\n     * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @param {Number} [options.height=0.0] The height of the polygon.\n     * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n     * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     * @returns {PolygonGeometry}\n     *\n     *\n     * @example\n     * // create a polygon from points\n     * var polygon = Cesium.PolygonGeometry.fromPositions({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0,\n     *     -75.0, 30.0,\n     *     -70.0, 30.0,\n     *     -68.0, 40.0\n     *   ])\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n     *\n     * @see PolygonGeometry#createGeometry\n     */\n    PolygonGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            },\n            height : options.height,\n            extrudedHeight : options.extrudedHeight,\n            vertexFormat : options.vertexFormat,\n            stRotation : options.stRotation,\n            ellipsoid : options.ellipsoid,\n            granularity : options.granularity,\n            perPositionHeight : options.perPositionHeight,\n            closeTop : options.closeTop,\n            closeBottom : options.closeBottom,\n            offsetAttribute : options.offsetAttribute,\n            arcType : options.arcType\n        };\n        return new PolygonGeometry(newOptions);\n    };\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolygonGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolygonGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n        array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n        array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\n        array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n        array[startingIndex++] = value._arcType;\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n\n    //Only used to avoid inability to default construct.\n    var dummyOptions = {\n        polygonHierarchy : {}\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolygonGeometry} [result] The object into which to store the result.\n     */\n    PolygonGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var stRotation = array[startingIndex++];\n        var perPositionHeightExtrude = array[startingIndex++] === 1.0;\n        var perPositionHeight = array[startingIndex++] === 1.0;\n        var closeTop = array[startingIndex++] === 1.0;\n        var closeBottom = array[startingIndex++] === 1.0;\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex++];\n        var arcType = array[startingIndex++];\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new PolygonGeometry(dummyOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._granularity = granularity;\n        result._stRotation = stRotation;\n        result._perPositionHeightExtrude = perPositionHeightExtrude;\n        result._perPositionHeight = perPositionHeight;\n        result._closeTop = closeTop;\n        result._closeBottom = closeBottom;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n        result._arcType = arcType;\n        result.packedLength = packedLength;\n        return result;\n    };\n\n    /**\n     * Returns the bounding rectangle given the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Rectangle} [result] An object in which to store the result.\n     *\n     * @returns {Rectangle} The result rectangle\n     */\n    PolygonGeometry.computeRectangle = function(options, result) {\n        \n\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n        \n\n        var polygonHierarchy = options.polygonHierarchy;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n        return computeRectangle(polygonHierarchy.positions, ellipsoid, arcType, granularity, result);\n    };\n\n    /**\n     * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolygonGeometry} polygonGeometry A description of the polygon.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolygonGeometry.createGeometry = function(polygonGeometry) {\n        var vertexFormat = polygonGeometry._vertexFormat;\n        var ellipsoid = polygonGeometry._ellipsoid;\n        var granularity = polygonGeometry._granularity;\n        var stRotation = polygonGeometry._stRotation;\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n        var perPositionHeight = polygonGeometry._perPositionHeight;\n        var closeTop = polygonGeometry._closeTop;\n        var closeBottom = polygonGeometry._closeBottom;\n        var arcType = polygonGeometry._arcType;\n\n        var outerPositions = polygonHierarchy.positions;\n        if (outerPositions.length < 3) {\n            return;\n        }\n\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerPositions, ellipsoid);\n\n        var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, tangentPlane.projectPointsOntoPlane.bind(tangentPlane), !perPositionHeight, ellipsoid);\n\n        var hierarchy = results.hierarchy;\n        var polygons = results.polygons;\n\n        if (hierarchy.length === 0) {\n            return;\n        }\n\n        outerPositions = hierarchy[0].outerRing;\n        var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(tangentPlane.plane.normal, tangentPlane.projectPointOntoPlane.bind(tangentPlane), outerPositions, stRotation, scratchBoundingRectangle);\n\n        var geometries = [];\n\n        var height = polygonGeometry._height;\n        var extrudedHeight = polygonGeometry._extrudedHeight;\n        var extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        var options = {\n            perPositionHeight: perPositionHeight,\n            vertexFormat: vertexFormat,\n            geometry: undefined,\n            tangentPlane: tangentPlane,\n            boundingRectangle: boundingRectangle,\n            ellipsoid: ellipsoid,\n            stRotation: stRotation,\n            bottom: false,\n            top: true,\n            wall: false,\n            extrude: false,\n            arcType: arcType\n        };\n\n        var i;\n\n        if (extrude) {\n            options.extrude = true;\n            options.top = closeTop;\n            options.bottom = closeBottom;\n            options.shadowVolume = polygonGeometry._shadowVolume;\n            options.offsetAttribute = polygonGeometry._offsetAttribute;\n            for (i = 0; i < polygons.length; i++) {\n                var splitGeometry = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], granularity, hierarchy[i], perPositionHeight, closeTop, closeBottom, vertexFormat, arcType);\n\n                var topAndBottom;\n                if (closeTop && closeBottom) {\n                    topAndBottom = splitGeometry.topAndBottom;\n                    options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(topAndBottom.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n                } else if (closeTop) {\n                    topAndBottom = splitGeometry.topAndBottom;\n                    topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n                    options.geometry = topAndBottom.geometry;\n                } else if (closeBottom) {\n                    topAndBottom = splitGeometry.topAndBottom;\n                    topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, extrudedHeight, ellipsoid, true);\n                    options.geometry = topAndBottom.geometry;\n                }\n                if (closeTop || closeBottom) {\n                    options.wall = false;\n                    topAndBottom.geometry = computeAttributes(options);\n                    geometries.push(topAndBottom);\n                }\n\n                var walls = splitGeometry.walls;\n                options.wall = true;\n                for ( var k = 0; k < walls.length; k++) {\n                    var wall = walls[k];\n                    options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(wall.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n                    wall.geometry = computeAttributes(options);\n                    geometries.push(wall);\n                }\n            }\n        } else {\n            for (i = 0; i < polygons.length; i++) {\n                var geometryInstance = new GeometryInstance({\n                    geometry : PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygons[i], granularity, perPositionHeight, vertexFormat, arcType)\n                });\n                geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n                options.geometry = geometryInstance.geometry;\n                geometryInstance.geometry = computeAttributes(options);\n\n                if (defined(polygonGeometry._offsetAttribute)) {\n                    var length = geometryInstance.geometry.attributes.position.values.length;\n                    var applyOffset = new Uint8Array(length / 3);\n                    var offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                    arrayFill(applyOffset, offsetValue);\n                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                        componentsPerAttribute : 1,\n                        values: applyOffset\n                    });\n                }\n\n                geometries.push(geometryInstance);\n            }\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);\n        geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);\n\n        var attributes = geometry.attributes;\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values);\n\n        if (!vertexFormat.position) {\n            delete attributes.position;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere,\n            offsetAttribute : polygonGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    PolygonGeometry.createShadowVolume = function(polygonGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = polygonGeometry._granularity;\n        var ellipsoid = polygonGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new PolygonGeometry({\n            polygonHierarchy : polygonGeometry._polygonHierarchy,\n            ellipsoid : ellipsoid,\n            stRotation : polygonGeometry._stRotation,\n            granularity : granularity,\n            perPositionHeight : false,\n            extrudedHeight : minHeight,\n            height : maxHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume: true,\n            arcType : polygonGeometry._arcType\n        });\n    };\n\n    function textureCoordinateRotationPoints(polygonGeometry) {\n        var stRotation = -polygonGeometry._stRotation;\n        if (stRotation === 0.0) {\n            return [0, 0, 0, 1, 1, 0];\n        }\n        var ellipsoid = polygonGeometry._ellipsoid;\n        var positions = polygonGeometry._polygonHierarchy.positions;\n        var boundingRectangle = polygonGeometry.rectangle;\n        return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);\n    }\n\n    defineProperties(PolygonGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rectangle)) {\n                    var positions = this._polygonHierarchy.positions;\n                    this._rectangle = computeRectangle(positions, this._ellipsoid, this._arcType, this._granularity);\n                }\n\n                return this._rectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                if (!defined(this._textureCoordinateRotationPoints)) {\n                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n                }\n                return this._textureCoordinateRotationPoints;\n            }\n        }\n    });\nexport default PolygonGeometry;\n","import ArcType from './ArcType.js';\nimport arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport WindingOrder from './WindingOrder.js';\n    var createGeometryFromPositionsPositions = [];\n    var createGeometryFromPositionsSubdivided = [];\n\n    function createGeometryFromPositions(ellipsoid, positions, minDistance, perPositionHeight, arcType) {\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);\n\n        var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n        if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n            positions2D.reverse();\n            positions = positions.slice().reverse();\n        }\n\n        var subdividedPositions;\n        var i;\n\n        var length = positions.length;\n        var index = 0;\n\n        if (!perPositionHeight) {\n            var numVertices = 0;\n            if (arcType === ArcType.GEODESIC) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n                }\n            } else if (arcType === ArcType.RHUMB) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n                }\n            }\n            subdividedPositions = new Float64Array(numVertices * 3);\n            for (i = 0; i < length; i++) {\n                var tempPositions;\n                if (arcType === ArcType.GEODESIC) {\n                    tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                } else if (arcType === ArcType.RHUMB) {\n                    tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                }\n                var tempPositionsLength = tempPositions.length;\n                for (var j = 0; j < tempPositionsLength; ++j) {\n                    subdividedPositions[index++] = tempPositions[j];\n                }\n            }\n        } else {\n            subdividedPositions = new Float64Array(length * 2 * 3);\n            for (i = 0; i < length; i++) {\n                var p0 = positions[i];\n                var p1 = positions[(i + 1) % length];\n                subdividedPositions[index++] = p0.x;\n                subdividedPositions[index++] = p0.y;\n                subdividedPositions[index++] = p0.z;\n                subdividedPositions[index++] = p1.x;\n                subdividedPositions[index++] = p1.y;\n                subdividedPositions[index++] = p1.z;\n            }\n        }\n\n        length = subdividedPositions.length / 3;\n        var indicesSize = length * 2;\n        var indices = IndexDatatype.createTypedArray(length, indicesSize);\n        index = 0;\n        for (i = 0; i < length - 1; i++) {\n            indices[index++] = i;\n            indices[index++] = i + 1;\n        }\n        indices[index++] = length - 1;\n        indices[index++] = 0;\n\n        return new GeometryInstance({\n            geometry : new Geometry({\n                attributes : new GeometryAttributes({\n                    position : new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.DOUBLE,\n                        componentsPerAttribute : 3,\n                        values : subdividedPositions\n                    })\n                }),\n                indices : indices,\n                primitiveType : PrimitiveType.LINES\n            })\n        });\n    }\n\n    function createGeometryFromPositionsExtruded(ellipsoid, positions, minDistance, perPositionHeight, arcType) {\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);\n\n        var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n        if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n            positions2D.reverse();\n            positions = positions.slice().reverse();\n        }\n\n        var subdividedPositions;\n        var i;\n\n        var length = positions.length;\n        var corners = new Array(length);\n        var index = 0;\n\n        if (!perPositionHeight) {\n            var numVertices = 0;\n            if (arcType === ArcType.GEODESIC) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n                }\n            } else if (arcType === ArcType.RHUMB) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n                }\n            }\n\n            subdividedPositions = new Float64Array(numVertices * 3 * 2);\n            for (i = 0; i < length; ++i) {\n                corners[i] = index / 3;\n                var tempPositions;\n                if (arcType === ArcType.GEODESIC) {\n                    tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                } else if (arcType === ArcType.RHUMB) {\n                    tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                }\n                var tempPositionsLength = tempPositions.length;\n                for (var j = 0; j < tempPositionsLength; ++j) {\n                    subdividedPositions[index++] = tempPositions[j];\n                }\n            }\n        } else {\n            subdividedPositions = new Float64Array(length * 2 * 3 * 2);\n            for (i = 0; i < length; ++i) {\n                corners[i] = index / 3;\n                var p0 = positions[i];\n                var p1 = positions[(i + 1) % length];\n\n                subdividedPositions[index++] = p0.x;\n                subdividedPositions[index++] = p0.y;\n                subdividedPositions[index++] = p0.z;\n                subdividedPositions[index++] = p1.x;\n                subdividedPositions[index++] = p1.y;\n                subdividedPositions[index++] = p1.z;\n            }\n        }\n\n        length = subdividedPositions.length / (3 * 2);\n        var cornersLength = corners.length;\n\n        var indicesSize = ((length * 2) + cornersLength) * 2;\n        var indices = IndexDatatype.createTypedArray(length + cornersLength, indicesSize);\n\n        index = 0;\n        for (i = 0; i < length; ++i) {\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n            indices[index++] = i + length;\n            indices[index++] = ((i + 1) % length) + length;\n        }\n\n        for (i = 0; i < cornersLength; i++) {\n            var corner = corners[i];\n            indices[index++] = corner;\n            indices[index++] = corner + length;\n        }\n\n        return new GeometryInstance({\n            geometry : new Geometry({\n                attributes : new GeometryAttributes({\n                    position : new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.DOUBLE,\n                        componentsPerAttribute : 3,\n                        values : subdividedPositions\n                    })\n                }),\n                indices : indices,\n                primitiveType : PrimitiveType.LINES\n            })\n        });\n    }\n\n    /**\n     * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.\n     *\n     * @alias PolygonOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     *\n     * @see PolygonOutlineGeometry#createGeometry\n     * @see PolygonOutlineGeometry#fromPositions\n     *\n     * @example\n     * // 1. create a polygon outline from points\n     * var polygon = new Cesium.PolygonOutlineGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   )\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n     *\n     * // 2. create a nested polygon with holes outline\n     * var polygonWithHole = new Cesium.PolygonOutlineGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -109.0, 30.0,\n     *       -95.0, 30.0,\n     *       -95.0, 40.0,\n     *       -109.0, 40.0\n     *     ]),\n     *     [new Cesium.PolygonHierarchy(\n     *       Cesium.Cartesian3.fromDegreesArray([\n     *         -107.0, 31.0,\n     *         -107.0, 39.0,\n     *         -97.0, 39.0,\n     *         -97.0, 31.0\n     *       ]),\n     *       [new Cesium.PolygonHierarchy(\n     *         Cesium.Cartesian3.fromDegreesArray([\n     *           -105.0, 33.0,\n     *           -99.0, 33.0,\n     *           -99.0, 37.0,\n     *           -105.0, 37.0\n     *         ]),\n     *         [new Cesium.PolygonHierarchy(\n     *           Cesium.Cartesian3.fromDegreesArray([\n     *             -103.0, 34.0,\n     *             -101.0, 34.0,\n     *             -101.0, 36.0,\n     *             -103.0, 36.0\n     *           ])\n     *         )]\n     *       )]\n     *     )]\n     *   )\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\n     *\n     * // 3. create extruded polygon outline\n     * var extrudedPolygon = new Cesium.PolygonOutlineGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   ),\n     *   extrudedHeight: 300000\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);\n     */\n    function PolygonOutlineGeometry(options) {\n        \n\n        var polygonHierarchy = options.polygonHierarchy;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var perPositionHeight = defaultValue(options.perPositionHeight, false);\n        var perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);\n        var arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        if (!perPositionHeightExtrude) {\n            var h = Math.max(height, extrudedHeight);\n            extrudedHeight = Math.min(height, extrudedHeight);\n            height = h;\n        }\n\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._granularity = granularity;\n        this._height = height;\n        this._extrudedHeight = extrudedHeight;\n        this._arcType = arcType;\n        this._polygonHierarchy = polygonHierarchy;\n        this._perPositionHeight = perPositionHeight;\n        this._perPositionHeightExtrude = perPositionHeightExtrude;\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createPolygonOutlineGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + 8;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolygonOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolygonOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n        array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n        array[startingIndex++] = value._arcType;\n        array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var dummyOptions = {\n        polygonHierarchy : {}\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolygonOutlineGeometry} [result] The object into which to store the result.\n     * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.\n     */\n    PolygonOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var perPositionHeightExtrude = array[startingIndex++] === 1.0;\n        var perPositionHeight = array[startingIndex++] === 1.0;\n        var arcType = array[startingIndex++];\n        var offsetAttribute = array[startingIndex++];\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new PolygonOutlineGeometry(dummyOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._granularity = granularity;\n        result._perPositionHeight = perPositionHeight;\n        result._perPositionHeightExtrude = perPositionHeightExtrude;\n        result._arcType = arcType;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n        result.packedLength = packedLength;\n\n        return result;\n    };\n\n    /**\n     * A description of a polygon outline from an array of positions.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @param {Number} [options.height=0.0] The height of the polygon.\n     * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.\n     * @returns {PolygonOutlineGeometry}\n     *\n     *\n     * @example\n     * // create a polygon from points\n     * var polygon = Cesium.PolygonOutlineGeometry.fromPositions({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0,\n     *     -75.0, 30.0,\n     *     -70.0, 30.0,\n     *     -68.0, 40.0\n     *   ])\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n     *\n     * @see PolygonOutlineGeometry#createGeometry\n     */\n    PolygonOutlineGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            },\n            height : options.height,\n            extrudedHeight : options.extrudedHeight,\n            ellipsoid : options.ellipsoid,\n            granularity : options.granularity,\n            perPositionHeight : options.perPositionHeight,\n            arcType: options.arcType,\n            offsetAttribute : options.offsetAttribute\n        };\n        return new PolygonOutlineGeometry(newOptions);\n    };\n\n    /**\n     * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolygonOutlineGeometry.createGeometry = function(polygonGeometry) {\n        var ellipsoid = polygonGeometry._ellipsoid;\n        var granularity = polygonGeometry._granularity;\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n        var perPositionHeight = polygonGeometry._perPositionHeight;\n        var arcType = polygonGeometry._arcType;\n\n        var polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(polygonHierarchy, !perPositionHeight, ellipsoid);\n\n        if (polygons.length === 0) {\n            return undefined;\n        }\n\n        var geometryInstance;\n        var geometries = [];\n        var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n\n        var height = polygonGeometry._height;\n        var extrudedHeight = polygonGeometry._extrudedHeight;\n        var extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n        var offsetValue;\n        var i;\n        if (extrude) {\n            for (i = 0; i < polygons.length; i++) {\n                geometryInstance = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);\n                geometryInstance.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(geometryInstance.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n                if (defined(polygonGeometry._offsetAttribute)) {\n                    var size = geometryInstance.geometry.attributes.position.values.length / 3;\n                    var offsetAttribute = new Uint8Array(size);\n                    if (polygonGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n                        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n                    } else {\n                        offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                        offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n                    }\n\n                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                        componentsPerAttribute : 1,\n                        values : offsetAttribute\n                    });\n                }\n                geometries.push(geometryInstance);\n            }\n        } else {\n            for (i = 0; i < polygons.length; i++) {\n                geometryInstance = createGeometryFromPositions(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);\n                geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n\n                if (defined(polygonGeometry._offsetAttribute)) {\n                    var length = geometryInstance.geometry.attributes.position.values.length;\n                    var applyOffset = new Uint8Array(length / 3);\n                    offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                    arrayFill(applyOffset, offsetValue);\n                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                        componentsPerAttribute : 1,\n                        values: applyOffset\n                    });\n                }\n\n                geometries.push(geometryInstance);\n            }\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        var boundingSphere = BoundingSphere.fromVertices(geometry.attributes.position.values);\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere,\n            offsetAttribute : polygonGeometry._offsetAttribute\n        });\n    };\nexport default PolygonOutlineGeometry;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport ArcType from '../Core/ArcType.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport CoplanarPolygonGeometry from '../Core/CoplanarPolygonGeometry.js';\nimport CoplanarPolygonOutlineGeometry from '../Core/CoplanarPolygonOutlineGeometry.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport EllipsoidTangentPlane from '../Core/EllipsoidTangentPlane.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport oneTimeWarning from '../Core/oneTimeWarning.js';\nimport PolygonGeometry from '../Core/PolygonGeometry.js';\nimport PolygonOutlineGeometry from '../Core/PolygonOutlineGeometry.js';\nimport Rectangle from '../Core/Rectangle.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport GroundGeometryUpdater from './GroundGeometryUpdater.js';\nimport Property from './Property.js';\n\n    var heightAndPerPositionHeightWarning = 'Entity polygons cannot have both height and perPositionHeight.  height will be ignored';\n    var heightReferenceAndPerPositionHeightWarning = 'heightReference is not supported for entity polygons with perPositionHeight. heightReference will be ignored';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n    var scratch2DPositions = [];\n    var cart2Scratch = new Cartesian2();\n\n    function PolygonGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.polygonHierarchy = undefined;\n        this.perPositionHeight = undefined;\n        this.closeTop = undefined;\n        this.closeBottom = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.stRotation = undefined;\n        this.offsetAttribute = undefined;\n        this.arcType = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for polygons.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PolygonGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PolygonGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new PolygonGeometryOptions(entity),\n            geometryPropertyName : 'polygon',\n            observedPropertyNames : ['availability', 'polygon']\n        });\n\n        this._onEntityPropertyChanged(entity, 'polygon', entity.polygon, undefined);\n    }\n\n    if (defined(Object.create)) {\n        PolygonGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        PolygonGeometryUpdater.prototype.constructor = PolygonGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PolygonGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var options = this._options;\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n        if (defined(options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        var geometry;\n        if (options.perPositionHeight && !defined(options.extrudedHeight)) {\n            geometry = new CoplanarPolygonGeometry(options);\n        } else {\n            geometry = new PolygonGeometry(options);\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : geometry,\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PolygonGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var options = this._options;\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n\n        if (defined(options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        var geometry;\n        if (options.perPositionHeight && !defined(options.extrudedHeight)) {\n            geometry = new CoplanarPolygonOutlineGeometry(options);\n        } else {\n            geometry = new PolygonOutlineGeometry(options);\n        }\n        return new GeometryInstance({\n            id : entity,\n            geometry : geometry,\n            attributes : attributes\n        });\n    };\n\n    PolygonGeometryUpdater.prototype._computeCenter = function(time, result) {\n        var hierarchy = Property.getValueOrUndefined(this._entity.polygon.hierarchy, time);\n        if (!defined(hierarchy)) {\n            return;\n        }\n        var positions = hierarchy.positions;\n        if (positions.length === 0) {\n            return;\n        }\n        var ellipsoid = this._scene.mapProjection.ellipsoid;\n\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(positions, scratch2DPositions);\n\n        var length = positions2D.length;\n        var area = 0;\n        var j = length - 1;\n        var centroid2D = new Cartesian2();\n        for (var i = 0; i < length; j = i++) {\n            var p1 = positions2D[i];\n            var p2 = positions2D[j];\n            var f = p1.x * p2.y - p2.x * p1.y;\n\n            var sum = Cartesian2.add(p1, p2, cart2Scratch);\n            sum = Cartesian2.multiplyByScalar(sum, f, sum);\n            centroid2D = Cartesian2.add(centroid2D, sum, centroid2D);\n\n            area += f;\n        }\n\n        var a = 1.0 / (area * 3.0);\n        centroid2D = Cartesian2.multiplyByScalar(centroid2D, a, centroid2D);\n        return tangentPlane.projectPointOntoEllipsoid(centroid2D, result);\n    };\n\n    PolygonGeometryUpdater.prototype._isHidden = function(entity, polygon) {\n        return !defined(polygon.hierarchy) || GeometryUpdater.prototype._isHidden.call(this, entity, polygon);\n    };\n\n    PolygonGeometryUpdater.prototype._isOnTerrain = function(entity, polygon) {\n        var onTerrain = GroundGeometryUpdater.prototype._isOnTerrain.call(this, entity, polygon);\n        var perPositionHeightProperty = polygon.perPositionHeight;\n        var perPositionHeightEnabled = defined(perPositionHeightProperty) && (perPositionHeightProperty.isConstant ? perPositionHeightProperty.getValue(Iso8601.MINIMUM_VALUE) : true);\n        return onTerrain && !perPositionHeightEnabled;\n    };\n\n    PolygonGeometryUpdater.prototype._isDynamic = function(entity, polygon) {\n        return !polygon.hierarchy.isConstant || //\n               !Property.isConstant(polygon.height) || //\n               !Property.isConstant(polygon.extrudedHeight) || //\n               !Property.isConstant(polygon.granularity) || //\n               !Property.isConstant(polygon.stRotation) || //\n               !Property.isConstant(polygon.outlineWidth) || //\n               !Property.isConstant(polygon.perPositionHeight) || //\n               !Property.isConstant(polygon.closeTop) || //\n               !Property.isConstant(polygon.closeBottom) || //\n               !Property.isConstant(polygon.zIndex) || //\n               !Property.isConstant(polygon.arcType) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    PolygonGeometryUpdater.prototype._setStaticOptions = function(entity, polygon) {\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n\n        var hierarchyValue = polygon.hierarchy.getValue(Iso8601.MINIMUM_VALUE);\n        var heightValue = Property.getValueOrUndefined(polygon.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(polygon.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(polygon.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(polygon.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var perPositionHeightValue = Property.getValueOrDefault(polygon.perPositionHeight, Iso8601.MINIMUM_VALUE, false);\n\n        heightValue = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        var offsetAttribute;\n        if (perPositionHeightValue) {\n            if (defined(heightValue)) {\n                heightValue = undefined;\n                oneTimeWarning(heightAndPerPositionHeightWarning);\n            }\n            if (heightReferenceValue !== HeightReference.NONE && perPositionHeightValue) {\n                heightValue = undefined;\n                oneTimeWarning(heightReferenceAndPerPositionHeightWarning);\n            }\n        } else {\n            if (defined(extrudedHeightValue) && !defined(heightValue)) {\n                heightValue = 0;\n            }\n            offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        }\n\n        options.polygonHierarchy = hierarchyValue;\n        options.granularity = Property.getValueOrUndefined(polygon.granularity, Iso8601.MINIMUM_VALUE);\n        options.stRotation = Property.getValueOrUndefined(polygon.stRotation, Iso8601.MINIMUM_VALUE);\n        options.perPositionHeight = perPositionHeightValue;\n        options.closeTop = Property.getValueOrDefault(polygon.closeTop, Iso8601.MINIMUM_VALUE, true);\n        options.closeBottom = Property.getValueOrDefault(polygon.closeBottom, Iso8601.MINIMUM_VALUE, true);\n        options.offsetAttribute = offsetAttribute;\n        options.height = heightValue;\n        options.arcType = Property.getValueOrDefault(polygon.arcType, Iso8601.MINIMUM_VALUE, ArcType.GEODESIC);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(PolygonGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    PolygonGeometryUpdater.prototype._getIsClosed = function(options) {\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        var isExtruded = defined(extrudedHeight) && extrudedHeight !== height;\n        return !options.perPositionHeight && (!isExtruded && height === 0 || (isExtruded && options.closeTop && options.closeBottom));\n    };\n\n    PolygonGeometryUpdater.DynamicGeometryUpdater = DyanmicPolygonGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DyanmicPolygonGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DyanmicPolygonGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DyanmicPolygonGeometryUpdater.prototype.constructor = DyanmicPolygonGeometryUpdater;\n    }\n\n    DyanmicPolygonGeometryUpdater.prototype._isHidden = function(entity, polygon, time) {\n        return !defined(this._options.polygonHierarchy) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, polygon, time);\n    };\n\n    DyanmicPolygonGeometryUpdater.prototype._setOptions = function(entity, polygon, time) {\n        var options = this._options;\n\n        options.polygonHierarchy = Property.getValueOrUndefined(polygon.hierarchy, time);\n\n        var heightValue = Property.getValueOrUndefined(polygon.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(polygon.heightReference, time, HeightReference.NONE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(polygon.extrudedHeightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(polygon.extrudedHeight, time);\n        var perPositionHeightValue = Property.getValueOrUndefined(polygon.perPositionHeight, time);\n\n        heightValue = GroundGeometryUpdater.getGeometryHeight(heightValue, extrudedHeightReferenceValue);\n\n        var offsetAttribute;\n        if (perPositionHeightValue) {\n            if (defined(heightValue)) {\n                heightValue = undefined;\n                oneTimeWarning(heightAndPerPositionHeightWarning);\n            }\n            if (heightReferenceValue !== HeightReference.NONE && perPositionHeightValue) {\n                heightValue = undefined;\n                oneTimeWarning(heightReferenceAndPerPositionHeightWarning);\n            }\n        } else {\n            if (defined(extrudedHeightValue) && !defined(heightValue)) {\n                heightValue = 0;\n            }\n\n            offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        }\n\n        options.granularity = Property.getValueOrUndefined(polygon.granularity, time);\n        options.stRotation = Property.getValueOrUndefined(polygon.stRotation, time);\n        options.perPositionHeight = Property.getValueOrUndefined(polygon.perPositionHeight, time);\n        options.closeTop = Property.getValueOrDefault(polygon.closeTop, time, true);\n        options.closeBottom = Property.getValueOrDefault(polygon.closeBottom, time, true);\n        options.offsetAttribute = offsetAttribute;\n        options.height = heightValue;\n        options.arcType = Property.getValueOrDefault(polygon.arcType, time, ArcType.GEODESIC);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(PolygonGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\nexport default PolygonGeometryUpdater;\n","import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingRectangle from './BoundingRectangle.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CornerType from './CornerType.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport oneTimeWarning from './oneTimeWarning.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PolylineVolumeGeometryLibrary from './PolylineVolumeGeometryLibrary.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\nimport WindingOrder from './WindingOrder.js';\n\n    function computeAttributes(combinedPositions, shape, boundingRectangle, vertexFormat) {\n        var attributes = new GeometryAttributes();\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : combinedPositions\n            });\n        }\n        var shapeLength = shape.length;\n        var vertexCount = combinedPositions.length / 3;\n        var length = (vertexCount - shapeLength * 2) / (shapeLength * 2);\n        var firstEndIndices = PolygonPipeline.triangulate(shape);\n\n        var indicesCount = (length - 1) * (shapeLength) * 6 + firstEndIndices.length * 2;\n        var indices = IndexDatatype.createTypedArray(vertexCount, indicesCount);\n        var i, j;\n        var ll, ul, ur, lr;\n        var offset = shapeLength * 2;\n        var index = 0;\n        for (i = 0; i < length - 1; i++) {\n            for (j = 0; j < shapeLength - 1; j++) {\n                ll = j * 2 + i * shapeLength * 2;\n                lr = ll + offset;\n                ul = ll + 1;\n                ur = ul + offset;\n\n                indices[index++] = ul;\n                indices[index++] = ll;\n                indices[index++] = ur;\n                indices[index++] = ur;\n                indices[index++] = ll;\n                indices[index++] = lr;\n            }\n            ll = shapeLength * 2 - 2 + i * shapeLength * 2;\n            ul = ll + 1;\n            ur = ul + offset;\n            lr = ll + offset;\n\n            indices[index++] = ul;\n            indices[index++] = ll;\n            indices[index++] = ur;\n            indices[index++] = ur;\n            indices[index++] = ll;\n            indices[index++] = lr;\n        }\n\n        if (vertexFormat.st || vertexFormat.tangent || vertexFormat.bitangent) { // st required for tangent/bitangent calculation\n            var st = new Float32Array(vertexCount * 2);\n            var lengthSt = 1 / (length - 1);\n            var heightSt = 1 / (boundingRectangle.height);\n            var heightOffset = boundingRectangle.height / 2;\n            var s, t;\n            var stindex = 0;\n            for (i = 0; i < length; i++) {\n                s = i * lengthSt;\n                t = heightSt * (shape[0].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n                for (j = 1; j < shapeLength; j++) {\n                    t = heightSt * (shape[j].y + heightOffset);\n                    st[stindex++] = s;\n                    st[stindex++] = t;\n                    st[stindex++] = s;\n                    st[stindex++] = t;\n                }\n                t = heightSt * (shape[0].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n            }\n            for (j = 0; j < shapeLength; j++) {\n                s = 0;\n                t = heightSt * (shape[j].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n            }\n            for (j = 0; j < shapeLength; j++) {\n                s = (length - 1) * lengthSt;\n                t = heightSt * (shape[j].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n            }\n\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : new Float32Array(st)\n            });\n        }\n\n        var endOffset = vertexCount - shapeLength * 2;\n        for (i = 0; i < firstEndIndices.length; i += 3) {\n            var v0 = firstEndIndices[i] + endOffset;\n            var v1 = firstEndIndices[i + 1] + endOffset;\n            var v2 = firstEndIndices[i + 2] + endOffset;\n\n            indices[index++] = v0;\n            indices[index++] = v1;\n            indices[index++] = v2;\n            indices[index++] = v2 + shapeLength;\n            indices[index++] = v1 + shapeLength;\n            indices[index++] = v0 + shapeLength;\n        }\n\n        var geometry = new Geometry({\n            attributes : attributes,\n            indices : indices,\n            boundingSphere : BoundingSphere.fromVertices(combinedPositions),\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        if (vertexFormat.normal) {\n            geometry = GeometryPipeline.computeNormal(geometry);\n        }\n\n        if (vertexFormat.tangent || vertexFormat.bitangent) {\n            try {\n                geometry = GeometryPipeline.computeTangentAndBitangent(geometry);\n            } catch (e) {\n                oneTimeWarning('polyline-volume-tangent-bitangent', 'Unable to compute tangents and bitangents for polyline volume geometry');\n                //TODO https://github.com/AnalyticalGraphicsInc/cesium/issues/3609\n            }\n\n            if (!vertexFormat.tangent) {\n                geometry.attributes.tangent = undefined;\n            }\n            if (!vertexFormat.bitangent) {\n                geometry.attributes.bitangent = undefined;\n            }\n            if (!vertexFormat.st) {\n                geometry.attributes.st = undefined;\n            }\n        }\n\n        return geometry;\n    }\n\n    /**\n     * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n     *\n     * @alias PolylineVolumeGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.polylinePositions An array of {@link Cartesain3} positions that define the center of the polyline volume.\n     * @param {Cartesian2[]} options.shapePositions An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see PolylineVolumeGeometry#createGeometry\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline%20Volume.html|Cesium Sandcastle Polyline Volume Demo}\n     *\n     * @example\n     * function computeCircle(radius) {\n     *   var positions = [];\n     *   for (var i = 0; i < 360; i++) {\n     *     var radians = Cesium.Math.toRadians(i);\n     *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n     *   }\n     *   return positions;\n     * }\n     *\n     * var volume = new Cesium.PolylineVolumeGeometry({\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n     *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0\n     *   ]),\n     *   shapePositions : computeCircle(100000.0)\n     * });\n     */\n    function PolylineVolumeGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.polylinePositions;\n        var shape = options.shapePositions;\n\n        \n\n        this._positions = positions;\n        this._shape = shape;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._workerName = 'createPolylineVolumeGeometry';\n\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\n        numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 2;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolylineVolumeGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolylineVolumeGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var shape = value._shape;\n        length = shape.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            Cartesian2.pack(shape[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        polylinePositions : undefined,\n        shapePositions : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        cornerType : undefined,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolylineVolumeGeometry} [result] The object into which to store the result.\n     * @returns {PolylineVolumeGeometry} The modified result parameter or a new PolylineVolumeGeometry instance if one was not provided.\n     */\n    PolylineVolumeGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var shape = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            shape[i] = Cartesian2.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.polylinePositions = positions;\n            scratchOptions.shapePositions = shape;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            return new PolylineVolumeGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._shape = shape;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    var brScratch = new BoundingRectangle();\n\n    /**\n     * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolylineVolumeGeometry} polylineVolumeGeometry A description of the polyline volume.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolylineVolumeGeometry.createGeometry = function(polylineVolumeGeometry) {\n        var positions = polylineVolumeGeometry._positions;\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n        var shape2D = polylineVolumeGeometry._shape;\n        shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n\n        if (cleanPositions.length < 2 || shape2D.length < 3) {\n            return undefined;\n        }\n\n        if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {\n            shape2D.reverse();\n        }\n        var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n\n        var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeGeometry, true);\n        return computeAttributes(computedPositions, shape2D, boundingRectangle, polylineVolumeGeometry._vertexFormat);\n    };\nexport default PolylineVolumeGeometry;\n","import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingRectangle from './BoundingRectangle.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CornerType from './CornerType.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PolylineVolumeGeometryLibrary from './PolylineVolumeGeometryLibrary.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport WindingOrder from './WindingOrder.js';\n\n    function computeAttributes(positions, shape) {\n        var attributes = new GeometryAttributes();\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : positions\n        });\n\n        var shapeLength = shape.length;\n        var vertexCount = attributes.position.values.length / 3;\n        var positionLength = positions.length / 3;\n        var shapeCount = positionLength / shapeLength;\n        var indices = IndexDatatype.createTypedArray(vertexCount, 2 * shapeLength * (shapeCount + 1));\n        var i, j;\n        var index = 0;\n        i = 0;\n        var offset = i * shapeLength;\n        for (j = 0; j < shapeLength - 1; j++) {\n            indices[index++] = j + offset;\n            indices[index++] = j + offset + 1;\n        }\n        indices[index++] = shapeLength - 1 + offset;\n        indices[index++] = offset;\n\n        i = shapeCount - 1;\n        offset = i * shapeLength;\n        for (j = 0; j < shapeLength - 1; j++) {\n            indices[index++] = j + offset;\n            indices[index++] = j + offset + 1;\n        }\n        indices[index++] = shapeLength - 1 + offset;\n        indices[index++] = offset;\n\n        for (i = 0; i < shapeCount - 1; i++) {\n            var firstOffset = shapeLength * i;\n            var secondOffset = firstOffset + shapeLength;\n            for (j = 0; j < shapeLength; j++) {\n                indices[index++] = j + firstOffset;\n                indices[index++] = j + secondOffset;\n            }\n        }\n\n        var geometry = new Geometry({\n            attributes : attributes,\n            indices : IndexDatatype.createTypedArray(vertexCount, indices),\n            boundingSphere : BoundingSphere.fromVertices(positions),\n            primitiveType : PrimitiveType.LINES\n        });\n\n        return geometry;\n    }\n\n    /**\n     * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n     *\n     * @alias PolylineVolumeOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.polylinePositions An array of positions that define the center of the polyline volume.\n     * @param {Cartesian2[]} options.shapePositions An array of positions that define the shape to be extruded along the polyline\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see PolylineVolumeOutlineGeometry#createGeometry\n     *\n     * @example\n     * function computeCircle(radius) {\n     *   var positions = [];\n     *   for (var i = 0; i < 360; i++) {\n     *     var radians = Cesium.Math.toRadians(i);\n     *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n     *   }\n     *   return positions;\n     * }\n     *\n     * var volumeOutline = new Cesium.PolylineVolumeOutlineGeometry({\n     *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0\n     *   ]),\n     *   shapePositions : computeCircle(100000.0)\n     * });\n     */\n    function PolylineVolumeOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.polylinePositions;\n        var shape = options.shapePositions;\n\n        \n\n        this._positions = positions;\n        this._shape = shape;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._workerName = 'createPolylineVolumeOutlineGeometry';\n\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\n        numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + 2;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolylineVolumeOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolylineVolumeOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var shape = value._shape;\n        length = shape.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            Cartesian2.pack(shape[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        polylinePositions : undefined,\n        shapePositions : undefined,\n        ellipsoid : scratchEllipsoid,\n        height : undefined,\n        cornerType : undefined,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolylineVolumeOutlineGeometry} [result] The object into which to store the result.\n     * @returns {PolylineVolumeOutlineGeometry} The modified result parameter or a new PolylineVolumeOutlineGeometry instance if one was not provided.\n     */\n    PolylineVolumeOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var shape = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            shape[i] = Cartesian2.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.polylinePositions = positions;\n            scratchOptions.shapePositions = shape;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            return new PolylineVolumeOutlineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._shape = shape;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    var brScratch = new BoundingRectangle();\n\n    /**\n     * Computes the geometric representation of the outline of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolylineVolumeOutlineGeometry} polylineVolumeOutlineGeometry A description of the polyline volume outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolylineVolumeOutlineGeometry.createGeometry = function(polylineVolumeOutlineGeometry) {\n        var positions = polylineVolumeOutlineGeometry._positions;\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n        var shape2D = polylineVolumeOutlineGeometry._shape;\n        shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n\n        if (cleanPositions.length < 2 || shape2D.length < 3) {\n            return undefined;\n        }\n\n        if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {\n            shape2D.reverse();\n        }\n        var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n\n        var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeOutlineGeometry, false);\n        return computeAttributes(computedPositions, shape2D);\n    };\nexport default PolylineVolumeOutlineGeometry;\n","import Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport PolylineVolumeGeometry from '../Core/PolylineVolumeGeometry.js';\nimport PolylineVolumeOutlineGeometry from '../Core/PolylineVolumeOutlineGeometry.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n\n    function PolylineVolumeGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.polylinePositions = undefined;\n        this.shapePositions = undefined;\n        this.cornerType = undefined;\n        this.granularity = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for polyline volumes.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PolylineVolumeGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PolylineVolumeGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new PolylineVolumeGeometryOptions(entity),\n            geometryPropertyName : 'polylineVolume',\n            observedPropertyNames : ['availability', 'polylineVolume']\n        });\n\n        this._onEntityPropertyChanged(entity, 'polylineVolume', entity.polylineVolume, undefined);\n    }\n\n    if (defined(Object.create)) {\n        PolylineVolumeGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        PolylineVolumeGeometryUpdater.prototype.constructor = PolylineVolumeGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PolylineVolumeGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes;\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute,\n                color : color\n            };\n        } else {\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute\n            };\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PolylineVolumeGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PolylineVolumeGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PolylineVolumeOutlineGeometry(this._options),\n            attributes : {\n                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n            }\n        });\n    };\n\n    PolylineVolumeGeometryUpdater.prototype._isHidden = function(entity, polylineVolume) {\n        return !defined(polylineVolume.positions) || !defined(polylineVolume.shape) || GeometryUpdater.prototype._isHidden.call(this, entity, polylineVolume);\n    };\n\n    PolylineVolumeGeometryUpdater.prototype._isDynamic = function(entity, polylineVolume) {\n        return !polylineVolume.positions.isConstant || //\n               !polylineVolume.shape.isConstant || //\n               !Property.isConstant(polylineVolume.granularity) || //\n               !Property.isConstant(polylineVolume.outlineWidth) || //\n               !Property.isConstant(polylineVolume.cornerType);\n    };\n\n    PolylineVolumeGeometryUpdater.prototype._setStaticOptions = function(entity, polylineVolume) {\n        var granularity = polylineVolume.granularity;\n        var cornerType = polylineVolume.cornerType;\n\n        var options = this._options;\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.polylinePositions = polylineVolume.positions.getValue(Iso8601.MINIMUM_VALUE, options.polylinePositions);\n        options.shapePositions = polylineVolume.shape.getValue(Iso8601.MINIMUM_VALUE, options.shape);\n        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n        options.cornerType = defined(cornerType) ? cornerType.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    };\n\n    PolylineVolumeGeometryUpdater.DynamicGeometryUpdater = DynamicPolylineVolumeGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicPolylineVolumeGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicPolylineVolumeGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicPolylineVolumeGeometryUpdater.prototype.constructor = DynamicPolylineVolumeGeometryUpdater;\n    }\n\n    DynamicPolylineVolumeGeometryUpdater.prototype._isHidden = function(entity, polylineVolume, time) {\n        var options = this._options;\n        return !defined(options.polylinePositions) || !defined(options.shapePositions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, polylineVolume, time);\n    };\n\n    DynamicPolylineVolumeGeometryUpdater.prototype._setOptions = function(entity, polylineVolume, time) {\n        var options = this._options;\n        options.polylinePositions = Property.getValueOrUndefined(polylineVolume.positions, time, options.polylinePositions);\n        options.shapePositions = Property.getValueOrUndefined(polylineVolume.shape, time);\n        options.granularity = Property.getValueOrUndefined(polylineVolume.granularity, time);\n        options.cornerType = Property.getValueOrUndefined(polylineVolume.cornerType, time);\n    };\nexport default PolylineVolumeGeometryUpdater;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport Matrix2 from './Matrix2.js';\nimport Matrix3 from './Matrix3.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport Quaternion from './Quaternion.js';\nimport Rectangle from './Rectangle.js';\nimport RectangleGeometryLibrary from './RectangleGeometryLibrary.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var positionScratch = new Cartesian3();\n    var normalScratch = new Cartesian3();\n    var tangentScratch = new Cartesian3();\n    var bitangentScratch = new Cartesian3();\n    var rectangleScratch = new Rectangle();\n    var stScratch = new Cartesian2();\n    var bottomBoundingSphere = new BoundingSphere();\n    var topBoundingSphere = new BoundingSphere();\n\n    function createAttributes(vertexFormat, attributes) {\n        var geo = new Geometry({\n            attributes : new GeometryAttributes(),\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        geo.attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : attributes.positions\n        });\n        if (vertexFormat.normal) {\n            geo.attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attributes.normals\n            });\n        }\n        if (vertexFormat.tangent) {\n            geo.attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attributes.tangents\n            });\n        }\n        if (vertexFormat.bitangent) {\n            geo.attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attributes.bitangents\n            });\n        }\n        return geo;\n    }\n\n    function calculateAttributes(positions, vertexFormat, ellipsoid, tangentRotationMatrix) {\n        var length = positions.length;\n\n        var normals = (vertexFormat.normal) ? new Float32Array(length) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(length) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(length) : undefined;\n\n        var attrIndex = 0;\n        var bitangent = bitangentScratch;\n        var tangent = tangentScratch;\n        var normal = normalScratch;\n        if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n            for (var i = 0; i < length; i += 3) {\n                var p = Cartesian3.fromArray(positions, i, positionScratch);\n                var attrIndex1 = attrIndex + 1;\n                var attrIndex2 = attrIndex + 2;\n\n                normal = ellipsoid.geodeticSurfaceNormal(p, normal);\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\n                    Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n                    Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent);\n                    Cartesian3.normalize(tangent, tangent);\n\n                    if (vertexFormat.bitangent) {\n                        Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                    }\n                }\n\n                if (vertexFormat.normal) {\n                    normals[attrIndex] = normal.x;\n                    normals[attrIndex1] = normal.y;\n                    normals[attrIndex2] = normal.z;\n                }\n                if (vertexFormat.tangent) {\n                    tangents[attrIndex] = tangent.x;\n                    tangents[attrIndex1] = tangent.y;\n                    tangents[attrIndex2] = tangent.z;\n                }\n                if (vertexFormat.bitangent) {\n                    bitangents[attrIndex] = bitangent.x;\n                    bitangents[attrIndex1] = bitangent.y;\n                    bitangents[attrIndex2] = bitangent.z;\n                }\n                attrIndex += 3;\n            }\n        }\n        return createAttributes(vertexFormat, {\n            positions : positions,\n            normals : normals,\n            tangents : tangents,\n            bitangents : bitangents\n        });\n    }\n\n    var v1Scratch = new Cartesian3();\n    var v2Scratch = new Cartesian3();\n\n    function calculateAttributesWall(positions, vertexFormat, ellipsoid) {\n        var length = positions.length;\n\n        var normals = (vertexFormat.normal) ? new Float32Array(length) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(length) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(length) : undefined;\n\n        var normalIndex = 0;\n        var tangentIndex = 0;\n        var bitangentIndex = 0;\n        var recomputeNormal = true;\n\n        var bitangent = bitangentScratch;\n        var tangent = tangentScratch;\n        var normal = normalScratch;\n        if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n            for (var i = 0; i < length; i += 6) {\n                var p = Cartesian3.fromArray(positions, i, positionScratch);\n                var p1 = Cartesian3.fromArray(positions, (i + 6) % length, v1Scratch);\n                if (recomputeNormal) {\n                    var p2 = Cartesian3.fromArray(positions, (i + 3) % length, v2Scratch);\n                    Cartesian3.subtract(p1, p, p1);\n                    Cartesian3.subtract(p2, p, p2);\n                    normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n                    recomputeNormal = false;\n                }\n\n                if (Cartesian3.equalsEpsilon(p1, p, CesiumMath.EPSILON10)) { // if we've reached a corner\n                    recomputeNormal = true;\n                }\n\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\n                    bitangent = ellipsoid.geodeticSurfaceNormal(p, bitangent);\n                    if (vertexFormat.tangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                    }\n                }\n\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n                }\n\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n                }\n\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n                }\n            }\n        }\n\n        return createAttributes(vertexFormat, {\n            positions : positions,\n            normals : normals,\n            tangents : tangents,\n            bitangents : bitangents\n        });\n    }\n\n    function constructRectangle(rectangleGeometry, computedOptions) {\n        var vertexFormat = rectangleGeometry._vertexFormat;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n        var height = computedOptions.height;\n        var width = computedOptions.width;\n        var northCap = computedOptions.northCap;\n        var southCap = computedOptions.southCap;\n\n        var rowStart = 0;\n        var rowEnd = height;\n        var rowHeight = height;\n        var size = 0;\n        if (northCap) {\n            rowStart = 1;\n            rowHeight -= 1;\n            size += 1;\n        }\n        if (southCap) {\n            rowEnd -= 1;\n            rowHeight -= 1;\n            size += 1;\n        }\n        size += (width * rowHeight);\n\n        var positions = (vertexFormat.position) ? new Float64Array(size * 3) : undefined;\n        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;\n\n        var posIndex = 0;\n        var stIndex = 0;\n\n        var position = positionScratch;\n        var st = stScratch;\n\n        var minX = Number.MAX_VALUE;\n        var minY = Number.MAX_VALUE;\n        var maxX = -Number.MAX_VALUE;\n        var maxY = -Number.MAX_VALUE;\n\n        for (var row = rowStart; row < rowEnd; ++row) {\n            for (var col = 0; col < width; ++col) {\n                RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, row, col, position, st);\n\n                positions[posIndex++] = position.x;\n                positions[posIndex++] = position.y;\n                positions[posIndex++] = position.z;\n\n                if (vertexFormat.st) {\n                    textureCoordinates[stIndex++] = st.x;\n                    textureCoordinates[stIndex++] = st.y;\n\n                    minX = Math.min(minX, st.x);\n                    minY = Math.min(minY, st.y);\n                    maxX = Math.max(maxX, st.x);\n                    maxY = Math.max(maxY, st.y);\n                }\n            }\n        }\n        if (northCap) {\n            RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, 0, 0, position, st);\n\n            positions[posIndex++] = position.x;\n            positions[posIndex++] = position.y;\n            positions[posIndex++] = position.z;\n\n            if (vertexFormat.st) {\n                textureCoordinates[stIndex++] = st.x;\n                textureCoordinates[stIndex++] = st.y;\n\n                minX = st.x;\n                minY = st.y;\n                maxX = st.x;\n                maxY = st.y;\n            }\n        }\n        if (southCap) {\n            RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, height - 1, 0, position, st);\n\n            positions[posIndex++] = position.x;\n            positions[posIndex++] = position.y;\n            positions[posIndex] = position.z;\n\n            if (vertexFormat.st) {\n                textureCoordinates[stIndex++] = st.x;\n                textureCoordinates[stIndex] = st.y;\n\n                minX = Math.min(minX, st.x);\n                minY = Math.min(minY, st.y);\n                maxX = Math.max(maxX, st.x);\n                maxY = Math.max(maxY, st.y);\n            }\n        }\n\n        if (vertexFormat.st && (minX < 0.0 || minY < 0.0 || maxX > 1.0 || maxY > 1.0)) {\n            for (var k = 0; k < textureCoordinates.length; k += 2) {\n                textureCoordinates[k] = (textureCoordinates[k] - minX) / (maxX - minX);\n                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minY) / (maxY - minY);\n            }\n        }\n\n        var geo = calculateAttributes(positions, vertexFormat, ellipsoid, computedOptions.tangentRotationMatrix);\n\n        var indicesSize = 6 * (width - 1) * (rowHeight - 1);\n        if (northCap) {\n            indicesSize += 3 * (width - 1);\n        }\n        if (southCap) {\n            indicesSize += 3 * (width - 1);\n        }\n        var indices = IndexDatatype.createTypedArray(size, indicesSize);\n        var index = 0;\n        var indicesIndex = 0;\n        var i;\n        for (i = 0; i < rowHeight - 1; ++i) {\n            for (var j = 0; j < width - 1; ++j) {\n                var upperLeft = index;\n                var lowerLeft = upperLeft + width;\n                var lowerRight = lowerLeft + 1;\n                var upperRight = upperLeft + 1;\n                indices[indicesIndex++] = upperLeft;\n                indices[indicesIndex++] = lowerLeft;\n                indices[indicesIndex++] = upperRight;\n                indices[indicesIndex++] = upperRight;\n                indices[indicesIndex++] = lowerLeft;\n                indices[indicesIndex++] = lowerRight;\n                ++index;\n            }\n            ++index;\n        }\n        if (northCap || southCap) {\n            var northIndex = size - 1;\n            var southIndex = size - 1;\n            if (northCap && southCap) {\n                northIndex = size - 2;\n            }\n\n            var p1;\n            var p2;\n            index = 0;\n\n            if (northCap) {\n                for (i = 0; i < width - 1; i++) {\n                    p1 = index;\n                    p2 = p1 + 1;\n                    indices[indicesIndex++] = northIndex;\n                    indices[indicesIndex++] = p1;\n                    indices[indicesIndex++] = p2;\n                    ++index;\n                }\n            }\n            if (southCap) {\n                index = (rowHeight - 1) * (width);\n                for (i = 0; i < width - 1; i++) {\n                    p1 = index;\n                    p2 = p1 + 1;\n                    indices[indicesIndex++] = p1;\n                    indices[indicesIndex++] = southIndex;\n                    indices[indicesIndex++] = p2;\n                    ++index;\n                }\n            }\n        }\n\n        geo.indices = indices;\n        if (vertexFormat.st) {\n            geo.attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        return geo;\n    }\n\n    function addWallPositions(wallPositions, posIndex, i, topPositions, bottomPositions) {\n        wallPositions[posIndex++] = topPositions[i];\n        wallPositions[posIndex++] = topPositions[i + 1];\n        wallPositions[posIndex++] = topPositions[i + 2];\n        wallPositions[posIndex++] = bottomPositions[i];\n        wallPositions[posIndex++] = bottomPositions[i + 1];\n        wallPositions[posIndex] = bottomPositions[i + 2];\n        return wallPositions;\n    }\n\n    function addWallTextureCoordinates(wallTextures, stIndex, i, st) {\n        wallTextures[stIndex++] = st[i];\n        wallTextures[stIndex++] = st[i + 1];\n        wallTextures[stIndex++] = st[i];\n        wallTextures[stIndex] = st[i + 1];\n        return wallTextures;\n    }\n\n    var scratchVertexFormat = new VertexFormat();\n\n    function constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n        var shadowVolume = rectangleGeometry._shadowVolume;\n        var offsetAttributeValue = rectangleGeometry._offsetAttribute;\n        var vertexFormat = rectangleGeometry._vertexFormat;\n        var minHeight = rectangleGeometry._extrudedHeight;\n        var maxHeight = rectangleGeometry._surfaceHeight;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n\n        var height = computedOptions.height;\n        var width = computedOptions.width;\n\n        var i;\n\n        if (shadowVolume) {\n            var newVertexFormat = VertexFormat.clone(vertexFormat, scratchVertexFormat);\n            newVertexFormat.normal = true;\n            rectangleGeometry._vertexFormat = newVertexFormat;\n        }\n\n        var topBottomGeo = constructRectangle(rectangleGeometry, computedOptions);\n\n        if (shadowVolume) {\n            rectangleGeometry._vertexFormat = vertexFormat;\n        }\n\n        var topPositions = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo.attributes.position.values, maxHeight, ellipsoid, false);\n        topPositions = new Float64Array(topPositions);\n        var length = topPositions.length;\n        var newLength = length * 2;\n        var positions = new Float64Array(newLength);\n        positions.set(topPositions);\n        var bottomPositions = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo.attributes.position.values, minHeight, ellipsoid);\n        positions.set(bottomPositions, length);\n        topBottomGeo.attributes.position.values = positions;\n\n        var normals = (vertexFormat.normal) ? new Float32Array(newLength) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(newLength) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(newLength) : undefined;\n        var textures = (vertexFormat.st) ? new Float32Array(newLength / 3 * 2) : undefined;\n        var topSt;\n        var topNormals;\n        if (vertexFormat.normal) {\n            topNormals = topBottomGeo.attributes.normal.values;\n            normals.set(topNormals);\n            for (i = 0; i < length; i++) {\n                topNormals[i] = -topNormals[i];\n            }\n            normals.set(topNormals, length);\n            topBottomGeo.attributes.normal.values = normals;\n        }\n        if (shadowVolume) {\n            topNormals = topBottomGeo.attributes.normal.values;\n            if (!vertexFormat.normal) {\n                topBottomGeo.attributes.normal = undefined;\n            }\n            var extrudeNormals = new Float32Array(newLength);\n            for (i = 0; i < length; i++) {\n                topNormals[i] = -topNormals[i];\n            }\n            extrudeNormals.set(topNormals, length); //only get normals for bottom layer that's going to be pushed down\n            topBottomGeo.attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n        }\n\n        var offsetValue;\n        var hasOffsets = defined(offsetAttributeValue);\n        if (hasOffsets) {\n            var size = length / 3 * 2;\n            var offsetAttribute = new Uint8Array(size);\n            if (offsetAttributeValue === GeometryOffsetAttribute.TOP) {\n                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n            } else {\n                offsetValue = offsetAttributeValue === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n\n            topBottomGeo.attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            var topTangents = topBottomGeo.attributes.tangent.values;\n            tangents.set(topTangents);\n            for (i = 0; i < length; i++) {\n                topTangents[i] = -topTangents[i];\n            }\n            tangents.set(topTangents, length);\n            topBottomGeo.attributes.tangent.values = tangents;\n        }\n        if (vertexFormat.bitangent) {\n            var topBitangents = topBottomGeo.attributes.bitangent.values;\n            bitangents.set(topBitangents);\n            bitangents.set(topBitangents, length);\n            topBottomGeo.attributes.bitangent.values = bitangents;\n        }\n        if (vertexFormat.st) {\n            topSt = topBottomGeo.attributes.st.values;\n            textures.set(topSt);\n            textures.set(topSt, length / 3 * 2);\n            topBottomGeo.attributes.st.values = textures;\n        }\n\n        var indices = topBottomGeo.indices;\n        var indicesLength = indices.length;\n        var posLength = length / 3;\n        var newIndices = IndexDatatype.createTypedArray(newLength / 3, indicesLength * 2);\n        newIndices.set(indices);\n        for (i = 0; i < indicesLength; i += 3) {\n            newIndices[i + indicesLength] = indices[i + 2] + posLength;\n            newIndices[i + 1 + indicesLength] = indices[i + 1] + posLength;\n            newIndices[i + 2 + indicesLength] = indices[i] + posLength;\n        }\n        topBottomGeo.indices = newIndices;\n\n        var northCap = computedOptions.northCap;\n        var southCap = computedOptions.southCap;\n\n        var rowHeight = height;\n        var widthMultiplier = 2;\n        var perimeterPositions = 0;\n        var corners = 4;\n        var dupliateCorners = 4;\n        if (northCap) {\n            widthMultiplier -= 1;\n            rowHeight -= 1;\n            perimeterPositions += 1;\n            corners -= 2;\n            dupliateCorners -= 1;\n        }\n        if (southCap) {\n            widthMultiplier -= 1;\n            rowHeight -= 1;\n            perimeterPositions += 1;\n            corners -= 2;\n            dupliateCorners -= 1;\n        }\n        perimeterPositions += (widthMultiplier * width + 2 * rowHeight - corners);\n\n        var wallCount = (perimeterPositions + dupliateCorners) * 2;\n\n        var wallPositions = new Float64Array(wallCount * 3);\n        var wallExtrudeNormals = shadowVolume ? new Float32Array(wallCount * 3) : undefined;\n        var wallOffsetAttribute = hasOffsets ? new Uint8Array(wallCount) : undefined;\n        var wallTextures = (vertexFormat.st) ? new Float32Array(wallCount * 2) : undefined;\n\n        var computeTopOffsets = offsetAttributeValue === GeometryOffsetAttribute.TOP;\n        if (hasOffsets && !computeTopOffsets) {\n            offsetValue = offsetAttributeValue === GeometryOffsetAttribute.ALL ? 1 : 0;\n            wallOffsetAttribute = arrayFill(wallOffsetAttribute, offsetValue);\n        }\n\n        var posIndex = 0;\n        var stIndex = 0;\n        var extrudeNormalIndex = 0;\n        var wallOffsetIndex = 0;\n        var area = width * rowHeight;\n        var threeI;\n        for (i = 0; i < area; i += width) {\n            threeI = i * 3;\n            wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n            posIndex += 6;\n            if (vertexFormat.st) {\n                wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n                stIndex += 4;\n            }\n            if (shadowVolume) {\n                extrudeNormalIndex += 3;\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n            }\n            if (computeTopOffsets) {\n                wallOffsetAttribute[wallOffsetIndex++] = 1;\n                wallOffsetIndex += 1;\n            }\n        }\n\n        if (!southCap) {\n            for (i = area - width; i < area; i++) {\n                threeI = i * 3;\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n                posIndex += 6;\n                if (vertexFormat.st) {\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n                    stIndex += 4;\n                }\n                if (shadowVolume) {\n                    extrudeNormalIndex += 3;\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n                }\n                if (computeTopOffsets) {\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\n                    wallOffsetIndex += 1;\n                }\n            }\n        } else {\n            var southIndex = northCap ? area + 1 : area;\n            threeI = southIndex * 3;\n\n            for (i = 0; i < 2; i++) { // duplicate corner points\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n                posIndex += 6;\n                if (vertexFormat.st) {\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, southIndex * 2, topSt);\n                    stIndex += 4;\n                }\n                if (shadowVolume) {\n                    extrudeNormalIndex += 3;\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n                }\n                if (computeTopOffsets) {\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\n                    wallOffsetIndex += 1;\n                }\n            }\n        }\n\n        for (i = area - 1; i > 0; i -= width) {\n            threeI = i * 3;\n            wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n            posIndex += 6;\n            if (vertexFormat.st) {\n                wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n                stIndex += 4;\n            }\n            if (shadowVolume) {\n                extrudeNormalIndex += 3;\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n            }\n            if (computeTopOffsets) {\n                wallOffsetAttribute[wallOffsetIndex++] = 1;\n                wallOffsetIndex += 1;\n            }\n\n        }\n\n        if (!northCap) {\n            for (i = width - 1; i >= 0; i--) {\n                threeI = i * 3;\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n                posIndex += 6;\n                if (vertexFormat.st) {\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n                    stIndex += 4;\n                }\n                if (shadowVolume) {\n                    extrudeNormalIndex += 3;\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n                }\n                if (computeTopOffsets) {\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\n                    wallOffsetIndex += 1;\n                }\n            }\n        } else {\n            var northIndex = area;\n            threeI = northIndex * 3;\n\n            for (i = 0; i < 2; i++) { // duplicate corner points\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n                posIndex += 6;\n                if (vertexFormat.st) {\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, northIndex * 2, topSt);\n                    stIndex += 4;\n                }\n                if (shadowVolume) {\n                    extrudeNormalIndex += 3;\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n                }\n                if (computeTopOffsets) {\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\n                    wallOffsetIndex += 1;\n                }\n            }\n        }\n\n        var geo = calculateAttributesWall(wallPositions, vertexFormat, ellipsoid);\n\n        if (vertexFormat.st) {\n            geo.attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : wallTextures\n            });\n        }\n        if (shadowVolume) {\n            geo.attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : wallExtrudeNormals\n            });\n        }\n        if (hasOffsets) {\n            geo.attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : wallOffsetAttribute\n            });\n        }\n\n        var wallIndices = IndexDatatype.createTypedArray(wallCount, perimeterPositions * 6);\n\n        var upperLeft;\n        var lowerLeft;\n        var lowerRight;\n        var upperRight;\n        length = wallPositions.length / 3;\n        var index = 0;\n        for (i = 0; i < length - 1; i += 2) {\n            upperLeft = i;\n            upperRight = (upperLeft + 2) % length;\n            var p1 = Cartesian3.fromArray(wallPositions, upperLeft * 3, v1Scratch);\n            var p2 = Cartesian3.fromArray(wallPositions, upperRight * 3, v2Scratch);\n            if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10)) {\n                continue;\n            }\n            lowerLeft = (upperLeft + 1) % length;\n            lowerRight = (lowerLeft + 2) % length;\n            wallIndices[index++] = upperLeft;\n            wallIndices[index++] = lowerLeft;\n            wallIndices[index++] = upperRight;\n            wallIndices[index++] = upperRight;\n            wallIndices[index++] = lowerLeft;\n            wallIndices[index++] = lowerRight;\n        }\n\n        geo.indices = wallIndices;\n\n        geo = GeometryPipeline.combineInstances([\n            new GeometryInstance({\n                geometry : topBottomGeo\n            }),\n            new GeometryInstance({\n                geometry : geo\n            })\n        ]);\n\n        return geo[0];\n    }\n\n    var scratchRectanglePoints = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\n    var nwScratch = new Cartographic();\n    var stNwScratch = new Cartographic();\n    function computeRectangle(rectangle, granularity, rotation, ellipsoid, result) {\n        if (rotation === 0.0) {\n            return Rectangle.clone(rectangle, result);\n        }\n\n        var computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, granularity, rotation, 0, rectangleScratch, nwScratch);\n\n        var height = computedOptions.height;\n        var width = computedOptions.width;\n\n        var positions = scratchRectanglePoints;\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, 0, positions[0]);\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, width - 1, positions[1]);\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, height - 1, 0, positions[2]);\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, height - 1, width - 1, positions[3]);\n\n        return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n    }\n\n    /**\n     * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias RectangleGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n     * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n     *\n     * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n     * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n     * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n     * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n     * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>options.rectangle.south</code>.\n     *\n     * @see RectangleGeometry#createGeometry\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}\n     *\n     * @example\n     * // 1. create a rectangle\n     * var rectangle = new Cesium.RectangleGeometry({\n     *   ellipsoid : Cesium.Ellipsoid.WGS84,\n     *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n     *   height : 10000.0\n     * });\n     * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n     *\n     * // 2. create an extruded rectangle without a top\n     * var rectangle = new Cesium.RectangleGeometry({\n     *   ellipsoid : Cesium.Ellipsoid.WGS84,\n     *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n     *   height : 10000.0,\n     *   extrudedHeight: 300000\n     * });\n     * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n     */\n    function RectangleGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var rectangle = options.rectangle;\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._rectangle = Rectangle.clone(rectangle);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._surfaceHeight = Math.max(height, extrudedHeight);\n        this._rotation = defaultValue(options.rotation, 0.0);\n        this._stRotation = defaultValue(options.stRotation, 0.0);\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n        this._extrudedHeight = Math.min(height, extrudedHeight);\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createRectangleGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n        this._rotatedRectangle = undefined;\n\n        this._textureCoordinateRotationPoints = undefined;\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    RectangleGeometry.packedLength = Rectangle.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {RectangleGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    RectangleGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        Rectangle.pack(value._rectangle, array, startingIndex);\n        startingIndex += Rectangle.packedLength;\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._surfaceHeight;\n        array[startingIndex++] = value._rotation;\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchRectangle = new Rectangle();\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        rectangle : scratchRectangle,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        granularity : undefined,\n        height : undefined,\n        rotation : undefined,\n        stRotation : undefined,\n        extrudedHeight : undefined,\n        shadowVolume : undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {RectangleGeometry} [result] The object into which to store the result.\n     * @returns {RectangleGeometry} The modified result parameter or a new RectangleGeometry instance if one was not provided.\n     */\n    RectangleGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n        startingIndex += Rectangle.packedLength;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var granularity = array[startingIndex++];\n        var surfaceHeight = array[startingIndex++];\n        var rotation = array[startingIndex++];\n        var stRotation = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.granularity = granularity;\n            scratchOptions.height = surfaceHeight;\n            scratchOptions.rotation = rotation;\n            scratchOptions.stRotation = stRotation;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.shadowVolume = shadowVolume;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new RectangleGeometry(scratchOptions);\n        }\n\n        result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._granularity = granularity;\n        result._surfaceHeight = surfaceHeight;\n        result._rotation = rotation;\n        result._stRotation = stRotation;\n        result._extrudedHeight = extrudedHeight;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the bounding rectangle based on the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n     * @param {Rectangle} [result] An object in which to store the result.\n     *\n     * @returns {Rectangle} The result rectangle\n     */\n    RectangleGeometry.computeRectangle = function(options, result) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var rectangle = options.rectangle;\n\n        \n\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var rotation = defaultValue(options.rotation, 0.0);\n\n        return computeRectangle(rectangle, granularity, rotation, ellipsoid, result);\n    };\n\n    var tangentRotationMatrixScratch = new Matrix3();\n    var quaternionScratch = new Quaternion();\n    var centerScratch = new Cartographic();\n    /**\n     * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {RectangleGeometry} rectangleGeometry A description of the rectangle.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     *\n     * @exception {DeveloperError} Rotated rectangle is invalid.\n     */\n    RectangleGeometry.createGeometry = function(rectangleGeometry) {\n        if ((CesiumMath.equalsEpsilon(rectangleGeometry._rectangle.north, rectangleGeometry._rectangle.south, CesiumMath.EPSILON10) ||\n             (CesiumMath.equalsEpsilon(rectangleGeometry._rectangle.east, rectangleGeometry._rectangle.west, CesiumMath.EPSILON10)))) {\n            return undefined;\n        }\n\n        var rectangle = rectangleGeometry._rectangle;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n        var rotation = rectangleGeometry._rotation;\n        var stRotation = rectangleGeometry._stRotation;\n        var vertexFormat = rectangleGeometry._vertexFormat;\n\n        var computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, rectangleGeometry._granularity, rotation, stRotation, rectangleScratch, nwScratch, stNwScratch);\n\n        var tangentRotationMatrix = tangentRotationMatrixScratch;\n        if (stRotation !== 0 || rotation !== 0) {\n            var center = Rectangle.center(rectangle, centerScratch);\n            var axis = ellipsoid.geodeticSurfaceNormalCartographic(center, v1Scratch);\n            Quaternion.fromAxisAngle(axis, -stRotation, quaternionScratch);\n            Matrix3.fromQuaternion(quaternionScratch, tangentRotationMatrix);\n        } else {\n            Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n        }\n\n        var surfaceHeight = rectangleGeometry._surfaceHeight;\n        var extrudedHeight = rectangleGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(surfaceHeight, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        computedOptions.lonScalar = 1.0 / rectangleGeometry._rectangle.width;\n        computedOptions.latScalar = 1.0 / rectangleGeometry._rectangle.height;\n        computedOptions.tangentRotationMatrix = tangentRotationMatrix;\n\n        var geometry;\n        var boundingSphere;\n        rectangle = rectangleGeometry._rectangle;\n        if (extrude) {\n            geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n            var topBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight, topBoundingSphere);\n            var bottomBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, extrudedHeight, bottomBoundingSphere);\n            boundingSphere = BoundingSphere.union(topBS, bottomBS);\n        } else {\n            geometry = constructRectangle(rectangleGeometry, computedOptions);\n            geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometry.attributes.position.values, surfaceHeight, ellipsoid, false);\n\n            if (defined(rectangleGeometry._offsetAttribute)) {\n                var length = geometry.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                geometry.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n\n            boundingSphere = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight);\n        }\n\n        if (!vertexFormat.position) {\n            delete geometry.attributes.position;\n        }\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere,\n            offsetAttribute : rectangleGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    RectangleGeometry.createShadowVolume = function(rectangleGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = rectangleGeometry._granularity;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new RectangleGeometry({\n            rectangle : rectangleGeometry._rectangle,\n            rotation : rectangleGeometry._rotation,\n            ellipsoid : ellipsoid,\n            stRotation : rectangleGeometry._stRotation,\n            granularity : granularity,\n            extrudedHeight : maxHeight,\n            height : minHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume : true\n        });\n    };\n\n    var unrotatedTextureRectangleScratch = new Rectangle();\n    var points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\n    var rotation2DScratch = new Matrix2();\n    var rectangleCenterScratch = new Cartographic();\n\n    function textureCoordinateRotationPoints(rectangleGeometry) {\n        if (rectangleGeometry._stRotation === 0.0) {\n            return [0, 0, 0, 1, 1, 0];\n        }\n\n        var rectangle = Rectangle.clone(rectangleGeometry._rectangle, unrotatedTextureRectangleScratch);\n        var granularity = rectangleGeometry._granularity;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n\n        // Rotate to align the texture coordinates with ENU\n        var rotation = rectangleGeometry._rotation - rectangleGeometry._stRotation;\n\n        var unrotatedTextureRectangle = computeRectangle(rectangle, granularity, rotation, ellipsoid, unrotatedTextureRectangleScratch);\n\n        // Assume a computed \"east-north\" texture coordinate system based on spherical or planar tricks, bounded by `boundingRectangle`.\n        // The \"desired\" texture coordinate system forms an oriented rectangle (un-oriented computed) around the geometry that completely and tightly bounds it.\n        // We want to map from the \"east-north\" texture coordinate system into the \"desired\" system using a pair of lines (analagous planes in 2D)\n        // Compute 3 corners of the \"desired\" texture coordinate system in \"east-north\" texture space by the following in cartographic space:\n        // - rotate 3 of the corners in unrotatedTextureRectangle by stRotation around the center of the bounding rectangle\n        // - apply the \"east-north\" system's normalization formula to the rotated cartographics, even though this is likely to produce values outside [0-1].\n        // This gives us a set of points in the \"east-north\" texture coordinate system that can be used to map \"east-north\" texture coordinates to \"desired.\"\n\n        var points2D = points2DScratch;\n        points2D[0].x = unrotatedTextureRectangle.west;\n        points2D[0].y = unrotatedTextureRectangle.south;\n\n        points2D[1].x = unrotatedTextureRectangle.west;\n        points2D[1].y = unrotatedTextureRectangle.north;\n\n        points2D[2].x = unrotatedTextureRectangle.east;\n        points2D[2].y = unrotatedTextureRectangle.south;\n\n        var boundingRectangle = rectangleGeometry.rectangle;\n        var toDesiredInComputed = Matrix2.fromRotation(rectangleGeometry._stRotation, rotation2DScratch);\n        var boundingRectangleCenter = Rectangle.center(boundingRectangle, rectangleCenterScratch);\n\n        for (var i = 0; i < 3; ++i) {\n            var point2D = points2D[i];\n            point2D.x -= boundingRectangleCenter.longitude;\n            point2D.y -= boundingRectangleCenter.latitude;\n            Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\n            point2D.x += boundingRectangleCenter.longitude;\n            point2D.y += boundingRectangleCenter.latitude;\n\n            // Convert point into east-north texture coordinate space\n            point2D.x = (point2D.x - boundingRectangle.west) / boundingRectangle.width;\n            point2D.y = (point2D.y - boundingRectangle.south) / boundingRectangle.height;\n        }\n\n        var minXYCorner = points2D[0];\n        var maxYCorner = points2D[1];\n        var maxXCorner = points2D[2];\n        var result = new Array(6);\n        Cartesian2.pack(minXYCorner, result);\n        Cartesian2.pack(maxYCorner, result, 2);\n        Cartesian2.pack(maxXCorner, result, 4);\n        return result;\n    }\n\n    defineProperties(RectangleGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rotatedRectangle)) {\n                    this._rotatedRectangle = computeRectangle(this._rectangle, this._granularity, this._rotation, this._ellipsoid);\n                }\n                return this._rotatedRectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering RectangleGeometries as GroundPrimitives.\n         * This version permits skew in textures by computing offsets directly in cartographic space and\n         * more accurately approximates rendering RectangleGeometries with height as standard Primitives.\n         * @see Geometry#_textureCoordinateRotationPoints\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                if (!defined(this._textureCoordinateRotationPoints)) {\n                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n                }\n                return this._textureCoordinateRotationPoints;\n            }\n        }\n    });\nexport default RectangleGeometry;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Cartographic from '../Core/Cartographic.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport Ellipsoid from '../Core/Ellipsoid.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport Rectangle from '../Core/Rectangle.js';\nimport RectangleGeometry from '../Core/RectangleGeometry.js';\nimport RectangleOutlineGeometry from '../Core/RectangleOutlineGeometry.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport GroundGeometryUpdater from './GroundGeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n    var scratchCenterRect = new Rectangle();\n    var scratchCarto = new Cartographic();\n\n    function RectangleGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.rectangle = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.stRotation = undefined;\n        this.rotation = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for rectangles.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias RectangleGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function RectangleGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new RectangleGeometryOptions(entity),\n            geometryPropertyName : 'rectangle',\n            observedPropertyNames : ['availability', 'rectangle']\n        });\n\n        this._onEntityPropertyChanged(entity, 'rectangle', entity.rectangle, undefined);\n    }\n\n    if (defined(Object.create)) {\n        RectangleGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        RectangleGeometryUpdater.prototype.constructor = RectangleGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    RectangleGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new RectangleGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    RectangleGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new RectangleOutlineGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    RectangleGeometryUpdater.prototype._computeCenter = function(time, result) {\n        var rect = Property.getValueOrUndefined(this._entity.rectangle.coordinates, time, scratchCenterRect);\n        if (!defined(rect)) {\n            return;\n        }\n        var center = Rectangle.center(rect, scratchCarto);\n        return Cartographic.toCartesian(center, Ellipsoid.WGS84, result);\n    };\n\n    RectangleGeometryUpdater.prototype._isHidden = function(entity, rectangle) {\n        return !defined(rectangle.coordinates) || GeometryUpdater.prototype._isHidden.call(this, entity, rectangle);\n    };\n\n    RectangleGeometryUpdater.prototype._isDynamic = function(entity, rectangle) {\n        return !rectangle.coordinates.isConstant || //\n               !Property.isConstant(rectangle.height) || //\n               !Property.isConstant(rectangle.extrudedHeight) || //\n               !Property.isConstant(rectangle.granularity) || //\n               !Property.isConstant(rectangle.stRotation) || //\n               !Property.isConstant(rectangle.rotation) || //\n               !Property.isConstant(rectangle.outlineWidth) || //\n               !Property.isConstant(rectangle.zIndex) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    RectangleGeometryUpdater.prototype._setStaticOptions = function(entity, rectangle) {\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var heightValue = Property.getValueOrUndefined(rectangle.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(rectangle.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(rectangle.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(rectangle.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.rectangle = rectangle.coordinates.getValue(Iso8601.MINIMUM_VALUE, options.rectangle);\n        options.granularity = Property.getValueOrUndefined(rectangle.granularity, Iso8601.MINIMUM_VALUE);\n        options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, Iso8601.MINIMUM_VALUE);\n        options.rotation = Property.getValueOrUndefined(rectangle.rotation, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    RectangleGeometryUpdater.DynamicGeometryUpdater = DynamicRectangleGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicRectangleGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicRectangleGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicRectangleGeometryUpdater.prototype.constructor = DynamicRectangleGeometryUpdater;\n    }\n\n    DynamicRectangleGeometryUpdater.prototype._isHidden = function(entity, rectangle, time) {\n        return  !defined(this._options.rectangle) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, rectangle, time);\n    };\n\n    DynamicRectangleGeometryUpdater.prototype._setOptions = function(entity, rectangle, time) {\n        var options = this._options;\n        var heightValue = Property.getValueOrUndefined(rectangle.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(rectangle.heightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(rectangle.extrudedHeight, time);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(rectangle.extrudedHeightReference, time, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        options.rectangle = Property.getValueOrUndefined(rectangle.coordinates, time, options.rectangle);\n        options.granularity = Property.getValueOrUndefined(rectangle.granularity, time);\n        options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, time);\n        options.rotation = Property.getValueOrUndefined(rectangle.rotation, time);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\nexport default RectangleGeometryUpdater;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport Primitive from '../Scene/Primitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var colorScratch = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n\n    function Batch(primitives, translucent, appearanceType, depthFailAppearanceType, depthFailMaterialProperty, closed, shadows) {\n        this.translucent = translucent;\n        this.appearanceType = appearanceType;\n        this.depthFailAppearanceType = depthFailAppearanceType;\n        this.depthFailMaterialProperty = depthFailMaterialProperty;\n        this.depthFailMaterial = undefined;\n        this.closed = closed;\n        this.shadows = shadows;\n        this.primitives = primitives;\n        this.createPrimitive = false;\n        this.waitingOnCreate = false;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.updaters = new AssociativeArray();\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.itemsToRemove = [];\n        this.invalidated = false;\n\n        var removeMaterialSubscription;\n        if (defined(depthFailMaterialProperty)) {\n            removeMaterialSubscription = depthFailMaterialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        }\n        this.removeMaterialSubscription = removeMaterialSubscription;\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.depthFailMaterialProperty;\n        var updaterMaterial = updater.depthFailMaterialProperty;\n        if (updaterMaterial === material) {\n            return true;\n        }\n        if (defined(material)) {\n            return material.equals(updaterMaterial);\n        }\n        return false;\n    };\n\n    Batch.prototype.add = function(updater, instance) {\n        var id = updater.id;\n        this.createPrimitive = true;\n        this.geometry.set(id, instance);\n        this.updaters.set(id, updater);\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty) || !Property.isConstant(updater.terrainOffsetProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var removedCount = 0;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometries = this.geometry.values;\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                var depthFailAppearance;\n                if (defined(this.depthFailAppearanceType)) {\n                    if (defined(this.depthFailMaterialProperty)) {\n                        this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                    }\n                    depthFailAppearance = new this.depthFailAppearanceType({\n                        material : this.depthFailMaterial,\n                        translucent : this.translucent,\n                        closed : this.closed\n                    });\n                }\n\n                primitive = new Primitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    appearance : new this.appearanceType({\n                        translucent : this.translucent,\n                        closed : this.closed\n                    }),\n                    depthFailAppearance : depthFailAppearance,\n                    shadows : this.shadows\n                });\n                primitives.add(primitive);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n            this.waitingOnCreate = true;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            if (defined(this.depthFailAppearanceType) && !(this.depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n                this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                this.primitive.depthFailAppearance.material = this.depthFailMaterial;\n            }\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            var waitingOnCreate = this.waitingOnCreate;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.fillMaterialProperty.isConstant || waitingOnCreate) {\n                    var colorProperty = updater.fillMaterialProperty.color;\n                    var resultColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastColor, resultColor)) {\n                        attributes._lastColor = Color.clone(resultColor, attributes._lastColor);\n                        attributes.color = ColorGeometryInstanceAttribute.toValue(resultColor, attributes.color);\n                        if ((this.translucent && attributes.color[3] === 255) || (!this.translucent && attributes.color[3] !== 255)) {\n                            this.itemsToRemove[removedCount++] = updater;\n                        }\n                    }\n                }\n\n                if (defined(this.depthFailAppearanceType) && updater.depthFailMaterialProperty instanceof ColorMaterialProperty && (!updater.depthFailMaterialProperty.isConstant || waitingOnCreate)) {\n                    var depthFailColorProperty = updater.depthFailMaterialProperty.color;\n                    var depthColor = Property.getValueOrDefault(depthFailColorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastDepthFailColor, depthColor)) {\n                        attributes._lastDepthFailColor = Color.clone(depthColor, attributes._lastDepthFailColor);\n                        attributes.depthFailColor = ColorGeometryInstanceAttribute.toValue(depthColor, attributes.depthFailColor);\n                    }\n                }\n\n                var show = updater.entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n\n                var offsetProperty = updater.terrainOffsetProperty;\n                if (!Property.isConstant(offsetProperty)) {\n                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);\n                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);\n                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n            this.waitingOnCreate = false;\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        this.itemsToRemove.length = removedCount;\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = updater.entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||//\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n        }\n        if (defined(this.removeMaterialSubscription)) {\n            this.removeMaterialSubscription();\n        }\n    };\n\n    /**\n     * @private\n     */\n    function StaticGeometryColorBatch(primitives, appearanceType, depthFailAppearanceType, closed, shadows) {\n        this._solidItems = [];\n        this._translucentItems = [];\n        this._primitives = primitives;\n        this._appearanceType = appearanceType;\n        this._depthFailAppearanceType = depthFailAppearanceType;\n        this._closed = closed;\n        this._shadows = shadows;\n    }\n\n    StaticGeometryColorBatch.prototype.add = function(time, updater) {\n        var items;\n        var translucent;\n        var instance = updater.createFillGeometryInstance(time);\n        if (instance.attributes.color.value[3] === 255) {\n            items = this._solidItems;\n            translucent = false;\n        } else {\n            items = this._translucentItems;\n            translucent = true;\n        }\n\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.isMaterial(updater)) {\n                item.add(updater, instance);\n                return;\n            }\n        }\n        var batch = new Batch(this._primitives, translucent, this._appearanceType, this._depthFailAppearanceType, updater.depthFailMaterialProperty, this._closed, this._shadows);\n        batch.add(updater, instance);\n        items.push(batch);\n    };\n\n    function removeItem(items, updater) {\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    StaticGeometryColorBatch.prototype.remove = function(updater) {\n        if (!removeItem(this._solidItems, updater)) {\n            removeItem(this._translucentItems, updater);\n        }\n    };\n\n    function moveItems(batch, items, time) {\n        var itemsMoved = false;\n        var length = items.length;\n        for (var i = 0; i < length; ++i) {\n            var item = items[i];\n            var itemsToRemove = item.itemsToRemove;\n            var itemsToMoveLength = itemsToRemove.length;\n            if (itemsToMoveLength > 0) {\n                for (i = 0; i < itemsToMoveLength; i++) {\n                    var updater = itemsToRemove[i];\n                    item.remove(updater);\n                    batch.add(time, updater);\n                    itemsMoved = true;\n                }\n            }\n        }\n        return itemsMoved;\n    }\n\n    function updateItems(batch, items, time, isUpdated) {\n        var length = items.length;\n        var i;\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    batch.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        length = items.length;\n        for (i = 0; i < length; ++i) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    }\n\n    StaticGeometryColorBatch.prototype.update = function(time) {\n        //Perform initial update\n        var isUpdated = updateItems(this, this._solidItems, time, true);\n        isUpdated = updateItems(this, this._translucentItems, time, isUpdated) && isUpdated;\n\n        //If any items swapped between solid/translucent, we need to\n        //move them between batches\n        var solidsMoved = moveItems(this, this._solidItems, time);\n        var translucentsMoved = moveItems(this, this._translucentItems, time);\n\n        //If we moved anything around, we need to re-build the primitive\n        if (solidsMoved || translucentsMoved) {\n            isUpdated = updateItems(this, this._solidItems, time, isUpdated) && isUpdated;\n            isUpdated = updateItems(this, this._translucentItems, time, isUpdated)&& isUpdated;\n        }\n\n        return isUpdated;\n    };\n\n    function getBoundingSphere(items, updater, result) {\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    }\n\n    StaticGeometryColorBatch.prototype.getBoundingSphere = function(updater, result) {\n        var boundingSphere = getBoundingSphere(this._solidItems, updater, result);\n        if (boundingSphere === BoundingSphereState.FAILED) {\n            return getBoundingSphere(this._translucentItems, updater, result);\n        }\n        return boundingSphere;\n    };\n\n    function removeAllPrimitives(items) {\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        items.length = 0;\n    }\n\n    StaticGeometryColorBatch.prototype.removeAllPrimitives = function() {\n        removeAllPrimitives(this._solidItems);\n        removeAllPrimitives(this._translucentItems);\n    };\nexport default StaticGeometryColorBatch;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport Primitive from '../Scene/Primitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n\n    function Batch(primitives, appearanceType, materialProperty, depthFailAppearanceType, depthFailMaterialProperty, closed, shadows) {\n        this.primitives = primitives;\n        this.appearanceType = appearanceType;\n        this.materialProperty = materialProperty;\n        this.depthFailAppearanceType = depthFailAppearanceType;\n        this.depthFailMaterialProperty = depthFailMaterialProperty;\n        this.closed = closed;\n        this.shadows = shadows;\n        this.updaters = new AssociativeArray();\n        this.createPrimitive = true;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.material = undefined;\n        this.depthFailMaterial = undefined;\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.invalidated = false;\n        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.materialProperty;\n        var updaterMaterial = updater.fillMaterialProperty;\n        var depthFailMaterial = this.depthFailMaterialProperty;\n        var updaterDepthFailMaterial = updater.depthFailMaterialProperty;\n\n        if (updaterMaterial === material && updaterDepthFailMaterial === depthFailMaterial) {\n            return true;\n        }\n        var equals = defined(material) && material.equals(updaterMaterial);\n        equals = ((!defined(depthFailMaterial) && !defined(updaterDepthFailMaterial)) || (defined(depthFailMaterial) && depthFailMaterial.equals(updaterDepthFailMaterial))) && equals;\n        return equals;\n    };\n\n    Batch.prototype.add = function(time, updater) {\n        var id = updater.id;\n        this.updaters.set(id, updater);\n        this.geometry.set(id, updater.createFillGeometryInstance(time));\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)  || !Property.isConstant(updater.terrainOffsetProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n        this.createPrimitive = true;\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    var colorScratch = new Color();\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var geometries = this.geometry.values;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n\n                var depthFailAppearance;\n                if (defined(this.depthFailMaterialProperty)) {\n                    this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                    depthFailAppearance = new this.depthFailAppearanceType({\n                        material : this.depthFailMaterial,\n                        translucent : this.depthFailMaterial.isTranslucent(),\n                        closed : this.closed\n                    });\n                }\n\n                primitive = new Primitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    appearance : new this.appearanceType({\n                        material : this.material,\n                        translucent : this.material.isTranslucent(),\n                        closed : this.closed\n                    }),\n                    depthFailAppearance : depthFailAppearance,\n                    shadows : this.shadows\n                });\n\n                primitives.add(primitive);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n            this.primitive.appearance.material = this.material;\n\n            if (defined(this.depthFailAppearanceType) && !(this.depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n                this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                this.primitive.depthFailAppearance.material = this.depthFailMaterial;\n            }\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var entity = updater.entity;\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (defined(this.depthFailAppearanceType) && this.depthFailMaterialProperty instanceof ColorMaterialProperty && !updater.depthFailMaterialProperty.isConstant) {\n                    var depthFailColorProperty = updater.depthFailMaterialProperty.color;\n                    var depthFailColor = Property.getValueOrDefault(depthFailColorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastDepthFailColor, depthFailColor)) {\n                        attributes._lastDepthFailColor = Color.clone(depthFailColor, attributes._lastDepthFailColor);\n                        attributes.depthFailColor = ColorGeometryInstanceAttribute.toValue(depthFailColor, attributes.depthFailColor);\n                    }\n                }\n\n                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n\n                var offsetProperty = updater.terrainOffsetProperty;\n                if (!Property.isConstant(offsetProperty)) {\n                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);\n                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);\n                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var entity = updater.entity;\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n        }\n        this.removeMaterialSubscription();\n    };\n\n    /**\n     * @private\n     */\n    function StaticGeometryPerMaterialBatch(primitives, appearanceType, depthFailAppearanceType, closed, shadows) {\n        this._items = [];\n        this._primitives = primitives;\n        this._appearanceType = appearanceType;\n        this._depthFailAppearanceType = depthFailAppearanceType;\n        this._closed = closed;\n        this._shadows = shadows;\n    }\n\n    StaticGeometryPerMaterialBatch.prototype.add = function(time, updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.isMaterial(updater)) {\n                item.add(time, updater);\n                return;\n            }\n        }\n        var batch = new Batch(this._primitives, this._appearanceType, updater.fillMaterialProperty, this._depthFailAppearanceType, updater.depthFailMaterialProperty, this._closed, this._shadows);\n        batch.add(time, updater);\n        items.push(batch);\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.remove = function(updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                break;\n            }\n        }\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.update = function(time) {\n        var i;\n        var items = this._items;\n        var length = items.length;\n\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    this.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        var isUpdated = true;\n        for (i = 0; i < items.length; i++) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.removeAllPrimitives = function() {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        this._items.length = 0;\n    };\nexport default StaticGeometryPerMaterialBatch;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var colorScratch = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n    function Batch(primitives, classificationType, color, key, zIndex) {\n        this.primitives = primitives;\n        this.zIndex = zIndex;\n        this.classificationType = classificationType;\n        this.color = color;\n        this.key = key;\n        this.createPrimitive = false;\n        this.waitingOnCreate = false;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.updaters = new AssociativeArray();\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.itemsToRemove = [];\n        this.isDirty = false;\n    }\n\n    Batch.prototype.add = function(updater, instance) {\n        var id = updater.id;\n        this.createPrimitive = true;\n        this.geometry.set(id, instance);\n        this.updaters.set(id, updater);\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    var scratchArray = new Array(4);\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var removedCount = 0;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometries = this.geometry.values;\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                primitive = new GroundPrimitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    classificationType : this.classificationType\n                });\n                primitives.add(primitive, this.zIndex);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n            this.waitingOnCreate = true;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            var waitingOnCreate = this.waitingOnCreate;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.fillMaterialProperty.isConstant || waitingOnCreate) {\n                    var colorProperty = updater.fillMaterialProperty.color;\n                    var fillColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, colorScratch);\n\n                    if (!Color.equals(attributes._lastColor, fillColor)) {\n                        attributes._lastColor = Color.clone(fillColor, attributes._lastColor);\n                        var color = this.color;\n                        var newColor = fillColor.toBytes(scratchArray);\n                        if (color[0] !== newColor[0] || color[1] !== newColor[1] ||\n                            color[2] !== newColor[2] || color[3] !== newColor[3]) {\n                           this.itemsToRemove[removedCount++] = updater;\n                        }\n                    }\n                }\n\n                var show = updater.entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n            this.waitingOnCreate = false;\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        this.itemsToRemove.length = removedCount;\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = updater.entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n\n        var bs = primitive.getBoundingSphere(updater.entity);\n        if (!defined(bs)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        bs.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.removeAllPrimitives = function() {\n        var primitives = this.primitives;\n\n        var primitive = this.primitive;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n            this.primitive = undefined;\n            this.geometry.removeAll();\n            this.updaters.removeAll();\n        }\n\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n            this.oldPrimitive = undefined;\n        }\n    };\n\n    /**\n     * @private\n     */\n    function StaticGroundGeometryColorBatch(primitives, classificationType) {\n        this._batches = new AssociativeArray();\n        this._primitives = primitives;\n        this._classificationType = classificationType;\n    }\n\n    StaticGroundGeometryColorBatch.prototype.add = function(time, updater) {\n        var instance = updater.createFillGeometryInstance(time);\n        var batches = this._batches;\n        // color and zIndex are batch breakers, so we'll use that for the key\n        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n        var batchKey = new Uint32Array(instance.attributes.color.value.buffer)[0] + ':' + zIndex;\n        var batch;\n        if (batches.contains(batchKey)) {\n            batch = batches.get(batchKey);\n        } else {\n            batch = new Batch(this._primitives, this._classificationType, instance.attributes.color.value, batchKey, zIndex);\n            batches.set(batchKey, batch);\n        }\n        batch.add(updater, instance);\n        return batch;\n    };\n\n    StaticGroundGeometryColorBatch.prototype.remove = function(updater) {\n        var batchesArray = this._batches.values;\n        var count = batchesArray.length;\n        for (var i = 0; i < count; ++i) {\n            if (batchesArray[i].remove(updater)) {\n                return;\n            }\n        }\n    };\n\n    StaticGroundGeometryColorBatch.prototype.update = function(time) {\n        var i;\n        var updater;\n\n        //Perform initial update\n        var isUpdated = true;\n        var batches = this._batches;\n        var batchesArray = batches.values;\n        var batchCount = batchesArray.length;\n        for (i = 0; i < batchCount; ++i) {\n            isUpdated = batchesArray[i].update(time) && isUpdated;\n        }\n\n        //If any items swapped between batches we need to move them\n        for (i = 0; i < batchCount; ++i) {\n            var oldBatch = batchesArray[i];\n            var itemsToRemove = oldBatch.itemsToRemove;\n            var itemsToMoveLength = itemsToRemove.length;\n            for (var j = 0; j < itemsToMoveLength; j++) {\n                updater = itemsToRemove[j];\n                oldBatch.remove(updater);\n                var newBatch = this.add(time, updater);\n                oldBatch.isDirty = true;\n                newBatch.isDirty = true;\n            }\n        }\n\n        //If we moved anything around, we need to re-build the primitive and remove empty batches\n        var batchesArrayCopy = batchesArray.slice();\n        var batchesCopyCount = batchesArrayCopy.length;\n        for (i = 0; i < batchesCopyCount; ++i) {\n            var batch = batchesArrayCopy[i];\n            if (batch.isDirty) {\n                isUpdated = batchesArrayCopy[i].update(time) && isUpdated;\n                batch.isDirty = false;\n            }\n            if (batch.geometry.length === 0) {\n                batches.remove(batch.key);\n            }\n        }\n\n        return isUpdated;\n    };\n\n    StaticGroundGeometryColorBatch.prototype.getBoundingSphere = function(updater, result) {\n        var batchesArray = this._batches.values;\n        var batchCount = batchesArray.length;\n        for (var i = 0; i < batchCount; ++i) {\n            var batch = batchesArray[i];\n            if (batch.contains(updater)) {\n                return batch.getBoundingSphere(updater, result);\n            }\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGroundGeometryColorBatch.prototype.removeAllPrimitives = function() {\n        var batchesArray = this._batches.values;\n        var batchCount = batchesArray.length;\n        for (var i = 0; i < batchCount; ++i) {\n            batchesArray[i].removeAllPrimitives();\n        }\n    };\nexport default StaticGroundGeometryColorBatch;\n","\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n};\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nexport default quickselect;\n","import quickselect from './quickselect.js';\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nexport default rbush;\n","import rbush from '../ThirdParty/rbush.js';\nimport Check from './Check.js';\n\n    /**\n     * Wrapper around rbush for use with Rectangle types.\n     * @private\n     */\n    function RectangleCollisionChecker() {\n        this._tree = rbush();\n    }\n\n    function RectangleWithId() {\n        this.minX = 0.0;\n        this.minY = 0.0;\n        this.maxX = 0.0;\n        this.maxY = 0.0;\n        this.id = '';\n    }\n\n    RectangleWithId.fromRectangleAndId = function(id, rectangle, result) {\n        result.minX = rectangle.west;\n        result.minY = rectangle.south;\n        result.maxX = rectangle.east;\n        result.maxY = rectangle.north;\n        result.id = id;\n        return result;\n    };\n\n    /**\n     * Insert a rectangle into the collision checker.\n     *\n     * @param {String} id Unique string ID for the rectangle being inserted.\n     * @param {Rectangle} rectangle A Rectangle\n     * @private\n     */\n    RectangleCollisionChecker.prototype.insert = function(id, rectangle) {\n        \n\n        var withId = RectangleWithId.fromRectangleAndId(id, rectangle, new RectangleWithId());\n        this._tree.insert(withId);\n    };\n\n    function idCompare(a, b) {\n        return a.id === b.id;\n    }\n\n    var removalScratch = new RectangleWithId();\n    /**\n     * Remove a rectangle from the collision checker.\n     *\n     * @param {String} id Unique string ID for the rectangle being removed.\n     * @param {Rectangle} rectangle A Rectangle\n     * @private\n     */\n    RectangleCollisionChecker.prototype.remove = function(id, rectangle) {\n        \n\n        var withId = RectangleWithId.fromRectangleAndId(id, rectangle, removalScratch);\n        this._tree.remove(withId, idCompare);\n    };\n\n    var collisionScratch = new RectangleWithId();\n    /**\n     * Checks if a given rectangle collides with any of the rectangles in the collection.\n     *\n     * @param {Rectangle} rectangle A Rectangle that should be checked against the rectangles in the collision checker.\n     * @returns {Boolean} Whether the rectangle collides with any of the rectangles in the collision checker.\n     */\n    RectangleCollisionChecker.prototype.collides = function(rectangle) {\n        \n\n        var withId = RectangleWithId.fromRectangleAndId('', rectangle, collisionScratch);\n        return this._tree.collides(withId);\n    };\nexport default RectangleCollisionChecker;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport RectangleCollisionChecker from '../Core/RectangleCollisionChecker.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport ShadowVolumeAppearance from '../Scene/ShadowVolumeAppearance.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n    // Encapsulates a Primitive and all the entities that it represents.\n    function Batch(primitives, classificationType, appearanceType, materialProperty, usingSphericalTextureCoordinates, zIndex) {\n        this.primitives = primitives; // scene level primitive collection\n        this.classificationType = classificationType;\n        this.appearanceType = appearanceType;\n        this.materialProperty = materialProperty;\n        this.updaters = new AssociativeArray();\n        this.createPrimitive = true;\n        this.primitive = undefined; // a GroundPrimitive encapsulating all the entities\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.material = undefined;\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.invalidated = false;\n        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.usingSphericalTextureCoordinates = usingSphericalTextureCoordinates;\n        this.zIndex = zIndex;\n        this.rectangleCollisionCheck = new RectangleCollisionChecker();\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    Batch.prototype.overlapping = function(rectangle) {\n        return this.rectangleCollisionCheck.collides(rectangle);\n    };\n\n    // Check if the given updater's material is compatible with this batch\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.materialProperty;\n        var updaterMaterial = updater.fillMaterialProperty;\n\n        if (updaterMaterial === material ||\n            (updaterMaterial instanceof ColorMaterialProperty && material instanceof ColorMaterialProperty)) {\n            return true;\n        }\n        return defined(material) && material.equals(updaterMaterial);\n    };\n\n    Batch.prototype.add = function(time, updater, geometryInstance) {\n        var id = updater.id;\n        this.updaters.set(id, updater);\n        this.geometry.set(id, geometryInstance);\n        this.rectangleCollisionCheck.insert(id, geometryInstance.geometry.rectangle);\n        // Updaters with dynamic attributes must be tracked separately, may exit the batch\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            // Listen for show changes. These will be synchronized in updateShows.\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n        this.createPrimitive = true;\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        var geometryInstance = this.geometry.get(id);\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.rectangleCollisionCheck.remove(id, geometryInstance.geometry.rectangle);\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var geometries = this.geometry.values;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        // For if the new primitive changes again before it is ready.\n                        primitives.remove(primitive);\n                    }\n                }\n\n                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n\n                primitive = new GroundPrimitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    appearance : new this.appearanceType({\n                        material : this.material\n                        // translucent and closed properties overridden\n                    }),\n                    classificationType : this.classificationType\n                });\n\n                primitives.add(primitive, this.zIndex);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n            this.primitive.appearance.material = this.material;\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var entity = updater.entity;\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var entity = updater.entity;\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n        }\n        this.removeMaterialSubscription();\n    };\n\n    /**\n     * @private\n     */\n    function StaticGroundGeometryPerMaterialBatch(primitives, classificationType, appearanceType) {\n        this._items = [];\n        this._primitives = primitives;\n        this._classificationType = classificationType;\n        this._appearanceType = appearanceType;\n    }\n\n    StaticGroundGeometryPerMaterialBatch.prototype.add = function(time, updater) {\n        var items = this._items;\n        var length = items.length;\n        var geometryInstance = updater.createFillGeometryInstance(time);\n        var usingSphericalTextureCoordinates = ShadowVolumeAppearance.shouldUseSphericalCoordinates(geometryInstance.geometry.rectangle);\n        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n        // Check if the Entity represented by the updater can be placed in an existing batch. Requirements:\n        // * compatible material (same material or same color)\n        // * same type of texture coordinates (spherical vs. planar)\n        // * conservatively non-overlapping with any entities in the existing batch\n        for (var i = 0; i < length; ++i) {\n            var item = items[i];\n            if (item.isMaterial(updater) &&\n                item.usingSphericalTextureCoordinates === usingSphericalTextureCoordinates &&\n                item.zIndex === zIndex &&\n                !item.overlapping(geometryInstance.geometry.rectangle)) {\n                item.add(time, updater, geometryInstance);\n                return;\n            }\n        }\n        // If a compatible batch wasn't found, create a new batch.\n        var batch = new Batch(this._primitives, this._classificationType, this._appearanceType, updater.fillMaterialProperty, usingSphericalTextureCoordinates, zIndex);\n        batch.add(time, updater, geometryInstance);\n        items.push(batch);\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.remove = function(updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                break;\n            }\n        }\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.update = function(time) {\n        var i;\n        var items = this._items;\n        var length = items.length;\n\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    this.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        var isUpdated = true;\n        for (i = 0; i < items.length; i++) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.removeAllPrimitives = function() {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        this._items.length = 0;\n    };\nexport default StaticGroundGeometryPerMaterialBatch;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport Primitive from '../Scene/Primitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var colorScratch = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n\n    function Batch(primitives, translucent, width, shadows) {\n        this.translucent = translucent;\n        this.width = width;\n        this.shadows = shadows;\n        this.primitives = primitives;\n        this.createPrimitive = false;\n        this.waitingOnCreate = false;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.updaters = new AssociativeArray();\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.itemsToRemove = [];\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n    }\n    Batch.prototype.add = function(updater, instance) {\n        var id = updater.id;\n        this.createPrimitive = true;\n        this.geometry.set(id, instance);\n        this.updaters.set(id, updater);\n        if (!updater.hasConstantOutline || !updater.outlineColorProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty) || !Property.isConstant(updater.terrainOffsetProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var removedCount = 0;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometries = this.geometry.values;\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                primitive = new Primitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    appearance : new PerInstanceColorAppearance({\n                        flat : true,\n                        translucent : this.translucent,\n                        renderState : {\n                            lineWidth : this.width\n                        }\n                    }),\n                    shadows : this.shadows\n                });\n\n                primitives.add(primitive);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n            this.waitingOnCreate = true;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            var waitingOnCreate = this.waitingOnCreate;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.outlineColorProperty.isConstant || waitingOnCreate) {\n                    var outlineColorProperty = updater.outlineColorProperty;\n                    var outlineColor = Property.getValueOrDefault(outlineColorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastColor, outlineColor)) {\n                        attributes._lastColor = Color.clone(outlineColor, attributes._lastColor);\n                        attributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, attributes.color);\n                        if ((this.translucent && attributes.color[3] === 255) || (!this.translucent && attributes.color[3] !== 255)) {\n                            this.itemsToRemove[removedCount++] = updater;\n                        }\n                    }\n                }\n\n                var show = updater.entity.isShowing && (updater.hasConstantOutline || updater.isOutlineVisible(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n\n                var offsetProperty = updater.terrainOffsetProperty;\n                if (!Property.isConstant(offsetProperty)) {\n                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);\n                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);\n                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n            this.waitingOnCreate = false;\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n\n        this.itemsToRemove.length = removedCount;\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = updater.entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||//\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.removeAllPrimitives = function() {\n        var primitives = this.primitives;\n\n        var primitive = this.primitive;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n            this.primitive = undefined;\n            this.geometry.removeAll();\n            this.updaters.removeAll();\n        }\n\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n            this.oldPrimitive = undefined;\n        }\n    };\n\n    /**\n     * @private\n     */\n    function StaticOutlineGeometryBatch(primitives, scene, shadows) {\n        this._primitives = primitives;\n        this._scene = scene;\n        this._shadows = shadows;\n        this._solidBatches = new AssociativeArray();\n        this._translucentBatches = new AssociativeArray();\n    }\n    StaticOutlineGeometryBatch.prototype.add = function(time, updater) {\n        var instance = updater.createOutlineGeometryInstance(time);\n        var width = this._scene.clampLineWidth(updater.outlineWidth);\n        var batches;\n        var batch;\n        if (instance.attributes.color.value[3] === 255) {\n            batches = this._solidBatches;\n            batch = batches.get(width);\n            if (!defined(batch)) {\n                batch = new Batch(this._primitives, false, width, this._shadows);\n                batches.set(width, batch);\n            }\n            batch.add(updater, instance);\n        } else {\n            batches = this._translucentBatches;\n            batch = batches.get(width);\n            if (!defined(batch)) {\n                batch = new Batch(this._primitives, true, width, this._shadows);\n                batches.set(width, batch);\n            }\n            batch.add(updater, instance);\n        }\n    };\n\n    StaticOutlineGeometryBatch.prototype.remove = function(updater) {\n        var i;\n\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        for (i = 0; i < solidBatchesLength; i++) {\n            if (solidBatches[i].remove(updater)) {\n                return;\n            }\n        }\n\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        for (i = 0; i < translucentBatchesLength; i++) {\n            if (translucentBatches[i].remove(updater)) {\n                return;\n            }\n        }\n    };\n\n    StaticOutlineGeometryBatch.prototype.update = function(time) {\n        var i;\n        var x;\n        var updater;\n        var batch;\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        var itemsToRemove;\n        var isUpdated = true;\n        var needUpdate = false;\n\n        do {\n            needUpdate = false;\n            for (x = 0; x < solidBatchesLength; x++) {\n                batch = solidBatches[x];\n                //Perform initial update\n                isUpdated = batch.update(time);\n\n                //If any items swapped between solid/translucent, we need to\n                //move them between batches\n                itemsToRemove = batch.itemsToRemove;\n                var solidsToMoveLength = itemsToRemove.length;\n                if (solidsToMoveLength > 0) {\n                    needUpdate = true;\n                    for (i = 0; i < solidsToMoveLength; i++) {\n                        updater = itemsToRemove[i];\n                        batch.remove(updater);\n                        this.add(time, updater);\n                    }\n                }\n            }\n            for (x = 0; x < translucentBatchesLength; x++) {\n                batch = translucentBatches[x];\n                //Perform initial update\n                isUpdated = batch.update(time);\n\n                //If any items swapped between solid/translucent, we need to\n                //move them between batches\n                itemsToRemove = batch.itemsToRemove;\n                var translucentToMoveLength = itemsToRemove.length;\n                if (translucentToMoveLength > 0) {\n                    needUpdate = true;\n                    for (i = 0; i < translucentToMoveLength; i++) {\n                        updater = itemsToRemove[i];\n                        batch.remove(updater);\n                        this.add(time, updater);\n                    }\n                }\n            }\n        } while (needUpdate);\n\n        return isUpdated;\n    };\n\n    StaticOutlineGeometryBatch.prototype.getBoundingSphere = function(updater, result) {\n        var i;\n\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        for (i = 0; i < solidBatchesLength; i++) {\n            var solidBatch = solidBatches[i];\n            if (solidBatch.contains(updater)){\n                return solidBatch.getBoundingSphere(updater, result);\n            }\n        }\n\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        for (i = 0; i < translucentBatchesLength; i++) {\n            var translucentBatch = translucentBatches[i];\n            if (translucentBatch.contains(updater)){\n                return translucentBatch.getBoundingSphere(updater, result);\n            }\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticOutlineGeometryBatch.prototype.removeAllPrimitives = function() {\n        var i;\n\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        for (i = 0; i < solidBatchesLength; i++) {\n            solidBatches[i].removeAllPrimitives();\n        }\n\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        for (i = 0; i < translucentBatchesLength; i++) {\n            translucentBatches[i].removeAllPrimitives();\n        }\n    };\nexport default StaticOutlineGeometryBatch;\n","import Cartographic from './Cartographic.js';\nimport defined from './defined.js';\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\nimport CesiumMath from './Math.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PolylinePipeline from './PolylinePipeline.js';\nimport WindingOrder from './WindingOrder.js';\n\n    /**\n     * private\n     */\n    var WallGeometryLibrary = {};\n\n    function latLonEquals(c0, c1) {\n        return ((CesiumMath.equalsEpsilon(c0.latitude, c1.latitude, CesiumMath.EPSILON14)) && (CesiumMath.equalsEpsilon(c0.longitude, c1.longitude, CesiumMath.EPSILON14)));\n    }\n\n    var scratchCartographic1 = new Cartographic();\n    var scratchCartographic2 = new Cartographic();\n    function removeDuplicates(ellipsoid, positions, topHeights, bottomHeights) {\n        var length = positions.length;\n        if (length < 2) {\n            return;\n        }\n\n        var hasBottomHeights = defined(bottomHeights);\n        var hasTopHeights = defined(topHeights);\n        var hasAllZeroHeights = true;\n\n        var cleanedPositions = new Array(length);\n        var cleanedTopHeights = new Array(length);\n        var cleanedBottomHeights = new Array(length);\n\n        var v0 = positions[0];\n        cleanedPositions[0] = v0;\n\n        var c0 = ellipsoid.cartesianToCartographic(v0, scratchCartographic1);\n        if (hasTopHeights) {\n            c0.height = topHeights[0];\n        }\n\n        hasAllZeroHeights = hasAllZeroHeights && c0.height <= 0;\n\n        cleanedTopHeights[0] = c0.height;\n\n        if (hasBottomHeights) {\n            cleanedBottomHeights[0] = bottomHeights[0];\n        } else {\n            cleanedBottomHeights[0] = 0.0;\n        }\n\n        var index = 1;\n        for (var i = 1; i < length; ++i) {\n            var v1 = positions[i];\n            var c1 = ellipsoid.cartesianToCartographic(v1, scratchCartographic2);\n            if (hasTopHeights) {\n                c1.height = topHeights[i];\n            }\n            hasAllZeroHeights = hasAllZeroHeights && c1.height <= 0;\n\n            if (!latLonEquals(c0, c1)) {\n                cleanedPositions[index] = v1; // Shallow copy!\n                cleanedTopHeights[index] = c1.height;\n\n                if (hasBottomHeights) {\n                    cleanedBottomHeights[index] = bottomHeights[i];\n                } else {\n                    cleanedBottomHeights[index] = 0.0;\n                }\n\n                Cartographic.clone(c1, c0);\n                ++index;\n            } else if (c0.height < c1.height) {\n                cleanedTopHeights[index - 1] = c1.height;\n            }\n        }\n\n        if (hasAllZeroHeights || index < 2) {\n            return;\n        }\n\n        cleanedPositions.length = index;\n        cleanedTopHeights.length = index;\n        cleanedBottomHeights.length = index;\n\n        return {\n            positions: cleanedPositions,\n            topHeights: cleanedTopHeights,\n            bottomHeights: cleanedBottomHeights\n        };\n    }\n\n    var positionsArrayScratch = new Array(2);\n    var heightsArrayScratch = new Array(2);\n    var generateArcOptionsScratch = {\n        positions : undefined,\n        height : undefined,\n        granularity : undefined,\n        ellipsoid : undefined\n    };\n\n    /**\n     * @private\n     */\n    WallGeometryLibrary.computePositions = function(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, duplicateCorners) {\n        var o = removeDuplicates(ellipsoid, wallPositions, maximumHeights, minimumHeights);\n\n        if (!defined(o)) {\n            return;\n        }\n\n        wallPositions = o.positions;\n        maximumHeights = o.topHeights;\n        minimumHeights = o.bottomHeights;\n\n        if (wallPositions.length >= 3) {\n            // Order positions counter-clockwise\n            var tangentPlane = EllipsoidTangentPlane.fromPoints(wallPositions, ellipsoid);\n            var positions2D = tangentPlane.projectPointsOntoPlane(wallPositions);\n\n            if (PolygonPipeline.computeWindingOrder2D(positions2D) === WindingOrder.CLOCKWISE) {\n                wallPositions.reverse();\n                maximumHeights.reverse();\n                minimumHeights.reverse();\n            }\n        }\n\n        var length = wallPositions.length;\n        var numCorners = length - 2;\n        var topPositions;\n        var bottomPositions;\n\n        var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n\n        var generateArcOptions = generateArcOptionsScratch;\n        generateArcOptions.minDistance = minDistance;\n        generateArcOptions.ellipsoid = ellipsoid;\n\n        if (duplicateCorners) {\n            var count = 0;\n            var i;\n\n            for (i = 0; i < length - 1; i++) {\n                count += PolylinePipeline.numberOfPoints(wallPositions[i], wallPositions[i+1], minDistance) + 1;\n            }\n\n            topPositions = new Float64Array(count * 3);\n            bottomPositions = new Float64Array(count * 3);\n\n            var generateArcPositions = positionsArrayScratch;\n            var generateArcHeights = heightsArrayScratch;\n            generateArcOptions.positions = generateArcPositions;\n            generateArcOptions.height = generateArcHeights;\n\n            var offset = 0;\n            for (i = 0; i < length - 1; i++) {\n                generateArcPositions[0] = wallPositions[i];\n                generateArcPositions[1] = wallPositions[i + 1];\n\n                generateArcHeights[0] = maximumHeights[i];\n                generateArcHeights[1] = maximumHeights[i + 1];\n\n                var pos = PolylinePipeline.generateArc(generateArcOptions);\n                topPositions.set(pos, offset);\n\n                generateArcHeights[0] = minimumHeights[i];\n                generateArcHeights[1] = minimumHeights[i + 1];\n\n                bottomPositions.set(PolylinePipeline.generateArc(generateArcOptions), offset);\n\n                offset += pos.length;\n            }\n        } else {\n            generateArcOptions.positions = wallPositions;\n            generateArcOptions.height = maximumHeights;\n            topPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));\n\n            generateArcOptions.height = minimumHeights;\n            bottomPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));\n        }\n\n        return {\n            bottomPositions: bottomPositions,\n            topPositions: topPositions,\n            numCorners: numCorners\n        };\n    };\nexport default WallGeometryLibrary;\n","import BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\nimport WallGeometryLibrary from './WallGeometryLibrary.js';\n\n    var scratchCartesian3Position1 = new Cartesian3();\n    var scratchCartesian3Position2 = new Cartesian3();\n    var scratchCartesian3Position3 = new Cartesian3();\n    var scratchCartesian3Position4 = new Cartesian3();\n    var scratchCartesian3Position5 = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n\n    /**\n     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @alias WallGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @exception {DeveloperError} positions length must be greater than or equal to 2.\n     * @exception {DeveloperError} positions and maximumHeights must have the same length.\n     * @exception {DeveloperError} positions and minimumHeights must have the same length.\n     *\n     * @see WallGeometry#createGeometry\n     * @see WallGeometry#fromConstantHeight\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Wall.html|Cesium Sandcastle Wall Demo}\n     *\n     * @example\n     * // create a wall that spans from ground level to 10000 meters\n     * var wall = new Cesium.WallGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *     19.0, 47.0, 10000.0,\n     *     19.0, 48.0, 10000.0,\n     *     20.0, 48.0, 10000.0,\n     *     20.0, 47.0, 10000.0,\n     *     19.0, 47.0, 10000.0\n     *   ])\n     * });\n     * var geometry = Cesium.WallGeometry.createGeometry(wall);\n     */\n    function WallGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var wallPositions = options.positions;\n        var maximumHeights = options.maximumHeights;\n        var minimumHeights = options.minimumHeights;\n\n        \n\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n        this._positions = wallPositions;\n        this._minimumHeights = minimumHeights;\n        this._maximumHeights = maximumHeights;\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._granularity = granularity;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._workerName = 'createWallGeometry';\n\n        var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n        if (defined(minimumHeights)) {\n            numComponents += minimumHeights.length;\n        }\n        if (defined(maximumHeights)) {\n            numComponents += maximumHeights.length;\n        }\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 1;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {WallGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    WallGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var minimumHeights = value._minimumHeights;\n        length = defined(minimumHeights) ? minimumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(minimumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = minimumHeights[i];\n            }\n        }\n\n        var maximumHeights = value._maximumHeights;\n        length = defined(maximumHeights) ? maximumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(maximumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = maximumHeights[i];\n            }\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex] = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        positions : undefined,\n        minimumHeights : undefined,\n        maximumHeights : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {WallGeometry} [result] The object into which to store the result.\n     * @returns {WallGeometry} The modified result parameter or a new WallGeometry instance if one was not provided.\n     */\n    WallGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var minimumHeights;\n\n        if (length > 0) {\n            minimumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                minimumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        length = array[startingIndex++];\n        var maximumHeights;\n\n        if (length > 0) {\n            maximumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                maximumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.minimumHeights = minimumHeights;\n            scratchOptions.maximumHeights = maximumHeights;\n            scratchOptions.granularity = granularity;\n            return new WallGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._minimumHeights = minimumHeights;\n        result._maximumHeights = maximumHeights;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    /**\n     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @returns {WallGeometry}\n     *\n     *\n     * @example\n     * // create a wall that spans from 10000 meters to 20000 meters\n     * var wall = Cesium.WallGeometry.fromConstantHeights({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     19.0, 47.0,\n     *     19.0, 48.0,\n     *     20.0, 48.0,\n     *     20.0, 47.0,\n     *     19.0, 47.0,\n     *   ]),\n     *   minimumHeight : 20000.0,\n     *   maximumHeight : 10000.0\n     * });\n     * var geometry = Cesium.WallGeometry.createGeometry(wall);\n     *\n     * @see WallGeometry#createGeometry\n     */\n    WallGeometry.fromConstantHeights = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n\n        \n\n        var minHeights;\n        var maxHeights;\n\n        var min = options.minimumHeight;\n        var max = options.maximumHeight;\n\n        var doMin = defined(min);\n        var doMax = defined(max);\n        if (doMin || doMax) {\n            var length = positions.length;\n            minHeights = (doMin) ? new Array(length) : undefined;\n            maxHeights = (doMax) ? new Array(length) : undefined;\n\n            for (var i = 0; i < length; ++i) {\n                if (doMin) {\n                    minHeights[i] = min;\n                }\n\n                if (doMax) {\n                    maxHeights[i] = max;\n                }\n            }\n        }\n\n        var newOptions = {\n            positions : positions,\n            maximumHeights : maxHeights,\n            minimumHeights : minHeights,\n            ellipsoid : options.ellipsoid,\n            vertexFormat : options.vertexFormat\n        };\n        return new WallGeometry(newOptions);\n    };\n\n    /**\n     * Computes the geometric representation of a wall, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {WallGeometry} wallGeometry A description of the wall.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    WallGeometry.createGeometry = function(wallGeometry) {\n        var wallPositions = wallGeometry._positions;\n        var minimumHeights = wallGeometry._minimumHeights;\n        var maximumHeights = wallGeometry._maximumHeights;\n        var vertexFormat = wallGeometry._vertexFormat;\n        var granularity = wallGeometry._granularity;\n        var ellipsoid = wallGeometry._ellipsoid;\n\n        var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, true);\n        if (!defined(pos)) {\n            return;\n        }\n\n        var bottomPositions = pos.bottomPositions;\n        var topPositions = pos.topPositions;\n        var numCorners = pos.numCorners;\n\n        var length = topPositions.length;\n        var size = length * 2;\n\n        var positions = vertexFormat.position ? new Float64Array(size) : undefined;\n        var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n        var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n        var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n        var textureCoordinates = vertexFormat.st ? new Float32Array(size / 3 * 2) : undefined;\n\n        var positionIndex = 0;\n        var normalIndex = 0;\n        var bitangentIndex = 0;\n        var tangentIndex = 0;\n        var stIndex = 0;\n\n        // add lower and upper points one after the other, lower\n        // points being even and upper points being odd\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n        var recomputeNormal = true;\n        length /= 3;\n        var i;\n        var s = 0;\n        var ds = 1/(length - wallPositions.length + 1);\n        for (i = 0; i < length; ++i) {\n            var i3 = i * 3;\n            var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);\n            var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);\n            if (vertexFormat.position) {\n                // insert the lower point\n                positions[positionIndex++] = bottomPosition.x;\n                positions[positionIndex++] = bottomPosition.y;\n                positions[positionIndex++] = bottomPosition.z;\n\n                // insert the upper point\n                positions[positionIndex++] = topPosition.x;\n                positions[positionIndex++] = topPosition.y;\n                positions[positionIndex++] = topPosition.z;\n            }\n\n            if (vertexFormat.st) {\n                textureCoordinates[stIndex++] = s;\n                textureCoordinates[stIndex++] = 0.0;\n\n                textureCoordinates[stIndex++] = s;\n                textureCoordinates[stIndex++] = 1.0;\n            }\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n                var nextPosition;\n                var nextTop = Cartesian3.clone(Cartesian3.ZERO, scratchCartesian3Position5);\n                var groundPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position2), scratchCartesian3Position2);\n                if (i + 1 < length) {\n                    nextPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position3), scratchCartesian3Position3);\n                    nextTop = Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position5);\n                }\n\n                if (recomputeNormal) {\n                    var scalednextPosition = Cartesian3.subtract(nextTop, topPosition, scratchCartesian3Position4);\n                    var scaledGroundPosition = Cartesian3.subtract(groundPosition, topPosition, scratchCartesian3Position1);\n                    normal = Cartesian3.normalize(Cartesian3.cross(scaledGroundPosition, scalednextPosition, normal), normal);\n                    recomputeNormal = false;\n                }\n\n                if (Cartesian3.equalsEpsilon(nextPosition, groundPosition, CesiumMath.EPSILON10)) {\n                    recomputeNormal = true;\n                } else {\n                    s += ds;\n                    if (vertexFormat.tangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.subtract(nextPosition, groundPosition, tangent), tangent);\n                    }\n                    if (vertexFormat.bitangent) {\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                    }\n                }\n\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n                }\n\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n                }\n\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n                }\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : positions\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        // prepare the side walls, two triangles for each wall\n        //\n        //    A (i+1)  B (i+3) E\n        //    +--------+-------+\n        //    |      / |      /|    triangles:  A C B\n        //    |     /  |     / |                B C D\n        //    |    /   |    /  |\n        //    |   /    |   /   |\n        //    |  /     |  /    |\n        //    | /      | /     |\n        //    +--------+-------+\n        //    C (i)    D (i+2) F\n        //\n\n        var numVertices = size / 3;\n        size -= 6 * (numCorners + 1);\n        var indices = IndexDatatype.createTypedArray(numVertices, size);\n\n        var edgeIndex = 0;\n        for (i = 0; i < numVertices - 2; i += 2) {\n            var LL = i;\n            var LR = i + 2;\n            var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);\n            var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);\n            if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n                continue;\n            }\n            var UL = i + 1;\n            var UR = i + 3;\n\n            indices[edgeIndex++] = UL;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = UR;\n            indices[edgeIndex++] = UR;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = LR;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : new BoundingSphere.fromVertices(positions)\n        });\n    };\nexport default WallGeometry;\n","import BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport WallGeometryLibrary from './WallGeometryLibrary.js';\n\n    var scratchCartesian3Position1 = new Cartesian3();\n    var scratchCartesian3Position2 = new Cartesian3();\n\n    /**\n     * A description of a wall outline. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @alias WallOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     *\n     * @exception {DeveloperError} positions length must be greater than or equal to 2.\n     * @exception {DeveloperError} positions and maximumHeights must have the same length.\n     * @exception {DeveloperError} positions and minimumHeights must have the same length.\n     *\n     * @see WallGeometry#createGeometry\n     * @see WallGeometry#fromConstantHeight\n     *\n     * @example\n     * // create a wall outline that spans from ground level to 10000 meters\n     * var wall = new Cesium.WallOutlineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *     19.0, 47.0, 10000.0,\n     *     19.0, 48.0, 10000.0,\n     *     20.0, 48.0, 10000.0,\n     *     20.0, 47.0, 10000.0,\n     *     19.0, 47.0, 10000.0\n     *   ])\n     * });\n     * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n     */\n    function WallOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var wallPositions = options.positions;\n        var maximumHeights = options.maximumHeights;\n        var minimumHeights = options.minimumHeights;\n\n        \n\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n        this._positions = wallPositions;\n        this._minimumHeights = minimumHeights;\n        this._maximumHeights = maximumHeights;\n        this._granularity = granularity;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._workerName = 'createWallOutlineGeometry';\n\n        var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n        if (defined(minimumHeights)) {\n            numComponents += minimumHeights.length;\n        }\n        if (defined(maximumHeights)) {\n            numComponents += maximumHeights.length;\n        }\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + 1;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {WallOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    WallOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var minimumHeights = value._minimumHeights;\n        length = defined(minimumHeights) ? minimumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(minimumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = minimumHeights[i];\n            }\n        }\n\n        var maximumHeights = value._maximumHeights;\n        length = defined(maximumHeights) ? maximumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(maximumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = maximumHeights[i];\n            }\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        positions : undefined,\n        minimumHeights : undefined,\n        maximumHeights : undefined,\n        ellipsoid : scratchEllipsoid,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {WallOutlineGeometry} [result] The object into which to store the result.\n     * @returns {WallOutlineGeometry} The modified result parameter or a new WallOutlineGeometry instance if one was not provided.\n     */\n    WallOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var minimumHeights;\n\n        if (length > 0) {\n            minimumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                minimumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        length = array[startingIndex++];\n        var maximumHeights;\n\n        if (length > 0) {\n            maximumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                maximumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.minimumHeights = minimumHeights;\n            scratchOptions.maximumHeights = maximumHeights;\n            scratchOptions.granularity = granularity;\n            return new WallOutlineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._minimumHeights = minimumHeights;\n        result._maximumHeights = maximumHeights;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    /**\n     * A description of a walloutline. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     * @returns {WallOutlineGeometry}\n     *\n     *\n     * @example\n     * // create a wall that spans from 10000 meters to 20000 meters\n     * var wall = Cesium.WallOutlineGeometry.fromConstantHeights({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     19.0, 47.0,\n     *     19.0, 48.0,\n     *     20.0, 48.0,\n     *     20.0, 47.0,\n     *     19.0, 47.0,\n     *   ]),\n     *   minimumHeight : 20000.0,\n     *   maximumHeight : 10000.0\n     * });\n     * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n     *\n     * @see WallOutlineGeometry#createGeometry\n     */\n    WallOutlineGeometry.fromConstantHeights = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n\n        \n\n        var minHeights;\n        var maxHeights;\n\n        var min = options.minimumHeight;\n        var max = options.maximumHeight;\n\n        var doMin = defined(min);\n        var doMax = defined(max);\n        if (doMin || doMax) {\n            var length = positions.length;\n            minHeights = (doMin) ? new Array(length) : undefined;\n            maxHeights = (doMax) ? new Array(length) : undefined;\n\n            for (var i = 0; i < length; ++i) {\n                if (doMin) {\n                    minHeights[i] = min;\n                }\n\n                if (doMax) {\n                    maxHeights[i] = max;\n                }\n            }\n        }\n\n        var newOptions = {\n            positions : positions,\n            maximumHeights : maxHeights,\n            minimumHeights : minHeights,\n            ellipsoid : options.ellipsoid\n        };\n        return new WallOutlineGeometry(newOptions);\n    };\n\n    /**\n     * Computes the geometric representation of a wall outline, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {WallOutlineGeometry} wallGeometry A description of the wall outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    WallOutlineGeometry.createGeometry = function(wallGeometry) {\n        var wallPositions = wallGeometry._positions;\n        var minimumHeights = wallGeometry._minimumHeights;\n        var maximumHeights = wallGeometry._maximumHeights;\n        var granularity = wallGeometry._granularity;\n        var ellipsoid = wallGeometry._ellipsoid;\n\n        var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, false);\n        if (!defined(pos)) {\n            return;\n        }\n\n        var bottomPositions = pos.bottomPositions;\n        var topPositions = pos.topPositions;\n\n        var length = topPositions.length;\n        var size = length * 2;\n\n        var positions = new Float64Array(size);\n        var positionIndex = 0;\n\n        // add lower and upper points one after the other, lower\n        // points being even and upper points being odd\n        length /= 3;\n        var i;\n        for (i = 0; i < length; ++i) {\n            var i3 = i * 3;\n            var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);\n            var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);\n\n            // insert the lower point\n            positions[positionIndex++] = bottomPosition.x;\n            positions[positionIndex++] = bottomPosition.y;\n            positions[positionIndex++] = bottomPosition.z;\n\n            // insert the upper point\n            positions[positionIndex++] = topPosition.x;\n            positions[positionIndex++] = topPosition.y;\n            positions[positionIndex++] = topPosition.z;\n        }\n\n        var attributes = new GeometryAttributes({\n            position : new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : positions\n            })\n        });\n\n        var numVertices = size / 3;\n        size = 2 * numVertices - 4 + numVertices;\n        var indices = IndexDatatype.createTypedArray(numVertices, size);\n\n        var edgeIndex = 0;\n        for (i = 0; i < numVertices - 2; i += 2) {\n            var LL = i;\n            var LR = i + 2;\n            var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);\n            var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);\n            if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n                continue;\n            }\n            var UL = i + 1;\n            var UR = i + 3;\n\n            indices[edgeIndex++] = UL;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = UL;\n            indices[edgeIndex++] = UR;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = LR;\n        }\n\n        indices[edgeIndex++] = numVertices - 2;\n        indices[edgeIndex++] = numVertices - 1;\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : new BoundingSphere.fromVertices(positions)\n        });\n    };\nexport default WallOutlineGeometry;\n","import Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport WallGeometry from '../Core/WallGeometry.js';\nimport WallOutlineGeometry from '../Core/WallOutlineGeometry.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n\n    function WallGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.positions = undefined;\n        this.minimumHeights = undefined;\n        this.maximumHeights = undefined;\n        this.granularity = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for walls.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias WallGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function WallGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new WallGeometryOptions(entity),\n            geometryPropertyName : 'wall',\n            observedPropertyNames : ['availability', 'wall']\n        });\n\n        this._onEntityPropertyChanged(entity, 'wall', entity.wall, undefined);\n    }\n\n    if (defined(Object.create)) {\n        WallGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        WallGeometryUpdater.prototype.constructor = WallGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    WallGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes;\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute,\n                color : color\n            };\n        } else {\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute\n            };\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new WallGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    WallGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new WallOutlineGeometry(this._options),\n            attributes : {\n                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n            }\n        });\n    };\n\n    WallGeometryUpdater.prototype._isHidden = function(entity, wall) {\n        return !defined(wall.positions) || GeometryUpdater.prototype._isHidden.call(this, entity, wall);\n    };\n\n    WallGeometryUpdater.prototype._getIsClosed = function(options) {\n        return false;\n    };\n\n    WallGeometryUpdater.prototype._isDynamic = function(entity, wall) {\n        return !wall.positions.isConstant || //\n               !Property.isConstant(wall.minimumHeights) || //\n               !Property.isConstant(wall.maximumHeights) || //\n               !Property.isConstant(wall.outlineWidth) || //\n               !Property.isConstant(wall.granularity);\n    };\n\n    WallGeometryUpdater.prototype._setStaticOptions = function(entity, wall) {\n        var minimumHeights = wall.minimumHeights;\n        var maximumHeights = wall.maximumHeights;\n        var granularity = wall.granularity;\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.positions = wall.positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);\n        options.minimumHeights = defined(minimumHeights) ? minimumHeights.getValue(Iso8601.MINIMUM_VALUE, options.minimumHeights) : undefined;\n        options.maximumHeights = defined(maximumHeights) ? maximumHeights.getValue(Iso8601.MINIMUM_VALUE, options.maximumHeights) : undefined;\n        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    };\n\n    WallGeometryUpdater.DynamicGeometryUpdater = DynamicWallGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicWallGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicWallGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicWallGeometryUpdater.prototype.constructor = DynamicWallGeometryUpdater;\n    }\n\n    DynamicWallGeometryUpdater.prototype._isHidden = function(entity, wall, time) {\n        return  !defined(this._options.positions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, wall, time);\n    };\n\n    DynamicWallGeometryUpdater.prototype._setOptions = function(entity, wall, time) {\n        var options = this._options;\n        options.positions = Property.getValueOrUndefined(wall.positions, time, options.positions);\n        options.minimumHeights = Property.getValueOrUndefined(wall.minimumHeights, time, options.minimumHeights);\n        options.maximumHeights = Property.getValueOrUndefined(wall.maximumHeights, time, options.maximumHeights);\n        options.granularity = Property.getValueOrUndefined(wall.granularity, time);\n    };\nexport default WallGeometryUpdater;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport Event from '../Core/Event.js';\nimport EventHelper from '../Core/EventHelper.js';\nimport ClassificationType from '../Scene/ClassificationType.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport BoxGeometryUpdater from './BoxGeometryUpdater.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport CorridorGeometryUpdater from './CorridorGeometryUpdater.js';\nimport CylinderGeometryUpdater from './CylinderGeometryUpdater.js';\nimport DynamicGeometryBatch from './DynamicGeometryBatch.js';\nimport EllipseGeometryUpdater from './EllipseGeometryUpdater.js';\nimport EllipsoidGeometryUpdater from './EllipsoidGeometryUpdater.js';\nimport Entity from './Entity.js';\nimport PlaneGeometryUpdater from './PlaneGeometryUpdater.js';\nimport PolygonGeometryUpdater from './PolygonGeometryUpdater.js';\nimport PolylineVolumeGeometryUpdater from './PolylineVolumeGeometryUpdater.js';\nimport RectangleGeometryUpdater from './RectangleGeometryUpdater.js';\nimport StaticGeometryColorBatch from './StaticGeometryColorBatch.js';\nimport StaticGeometryPerMaterialBatch from './StaticGeometryPerMaterialBatch.js';\nimport StaticGroundGeometryColorBatch from './StaticGroundGeometryColorBatch.js';\nimport StaticGroundGeometryPerMaterialBatch from './StaticGroundGeometryPerMaterialBatch.js';\nimport StaticOutlineGeometryBatch from './StaticOutlineGeometryBatch.js';\nimport WallGeometryUpdater from './WallGeometryUpdater.js';\n\n    var emptyArray = [];\n\n    var geometryUpdaters = [BoxGeometryUpdater, CylinderGeometryUpdater, CorridorGeometryUpdater, EllipseGeometryUpdater, EllipsoidGeometryUpdater, PlaneGeometryUpdater,\n                            PolygonGeometryUpdater, PolylineVolumeGeometryUpdater, RectangleGeometryUpdater, WallGeometryUpdater];\n\n    function GeometryUpdaterSet(entity, scene) {\n        this.entity = entity;\n        this.scene = scene;\n        var updaters = new Array(geometryUpdaters.length);\n        var geometryChanged = new Event();\n        function raiseEvent(geometry) {\n            geometryChanged.raiseEvent(geometry);\n        }\n        var eventHelper = new EventHelper();\n        for (var i = 0; i < updaters.length; i++) {\n            var updater = new geometryUpdaters[i](entity, scene);\n            eventHelper.add(updater.geometryChanged, raiseEvent);\n            updaters[i] = updater;\n        }\n        this.updaters = updaters;\n        this.geometryChanged = geometryChanged;\n        this.eventHelper = eventHelper;\n\n        this._removeEntitySubscription = entity.definitionChanged.addEventListener(GeometryUpdaterSet.prototype._onEntityPropertyChanged, this);\n    }\n\n    GeometryUpdaterSet.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        var updaters = this.updaters;\n        for (var i = 0; i < updaters.length; i++) {\n            updaters[i]._onEntityPropertyChanged(entity, propertyName, newValue, oldValue);\n        }\n    };\n\n    GeometryUpdaterSet.prototype.forEach = function (callback) {\n        var updaters = this.updaters;\n        for (var i = 0; i < updaters.length; i++) {\n            callback(updaters[i]);\n        }\n    };\n\n    GeometryUpdaterSet.prototype.destroy = function() {\n        this.eventHelper.removeAll();\n        var updaters = this.updaters;\n        for (var i = 0; i < updaters.length; i++) {\n            updaters[i].destroy();\n        }\n        this._removeEntitySubscription();\n        destroyObject(this);\n    };\n\n    /**\n     * A general purpose visualizer for geometry represented by {@link Primitive} instances.\n     * @alias GeometryVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n     * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n     */\n    function GeometryVisualizer(scene, entityCollection, primitives, groundPrimitives) {\n        \n\n        primitives = defaultValue(primitives, scene.primitives);\n        groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);\n\n        this._scene = scene;\n        this._primitives = primitives;\n        this._groundPrimitives = groundPrimitives;\n        this._entityCollection = undefined;\n        this._addedObjects = new AssociativeArray();\n        this._removedObjects = new AssociativeArray();\n        this._changedObjects = new AssociativeArray();\n\n        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n        this._outlineBatches = new Array(numberOfShadowModes*2);\n        this._closedColorBatches = new Array(numberOfShadowModes*2);\n        this._closedMaterialBatches = new Array(numberOfShadowModes*2);\n        this._openColorBatches = new Array(numberOfShadowModes*2);\n        this._openMaterialBatches = new Array(numberOfShadowModes*2);\n\n        var supportsMaterialsforEntitiesOnTerrain = Entity.supportsMaterialsforEntitiesOnTerrain(scene);\n        this._supportsMaterialsforEntitiesOnTerrain = supportsMaterialsforEntitiesOnTerrain;\n\n        var i;\n        for (i = 0; i < numberOfShadowModes; ++i) {\n            this._outlineBatches[i] = new StaticOutlineGeometryBatch(primitives, scene, i, false);\n            this._outlineBatches[numberOfShadowModes + i] = new StaticOutlineGeometryBatch(primitives, scene, i, true);\n\n            this._closedColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, true);\n            this._closedColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, false);\n\n            this._closedMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, true);\n            this._closedMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, false);\n\n            this._openColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, true);\n            this._openColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, false);\n\n            this._openMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, true);\n            this._openMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, false);\n        }\n\n        var numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n        var groundColorBatches = new Array(numberOfClassificationTypes);\n        var groundMaterialBatches = [];\n        if (supportsMaterialsforEntitiesOnTerrain) {\n            for (i = 0; i < numberOfClassificationTypes; ++i) {\n                groundMaterialBatches.push(new StaticGroundGeometryPerMaterialBatch(groundPrimitives, i, MaterialAppearance));\n                groundColorBatches[i] = new StaticGroundGeometryPerMaterialBatch(groundPrimitives, i, PerInstanceColorAppearance);\n            }\n        } else {\n            for (i = 0; i < numberOfClassificationTypes; ++i) {\n                groundColorBatches[i] = new StaticGroundGeometryColorBatch(groundPrimitives, i);\n            }\n        }\n\n        this._groundColorBatches = groundColorBatches;\n        this._groundMaterialBatches = groundMaterialBatches;\n\n        this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n\n        this._batches = this._outlineBatches.concat(this._closedColorBatches, this._closedMaterialBatches, this._openColorBatches, this._openMaterialBatches, this._groundColorBatches, this._groundMaterialBatches, this._dynamicBatch);\n\n        this._subscriptions = new AssociativeArray();\n        this._updaterSets = new AssociativeArray();\n\n        this._entityCollection = entityCollection;\n        entityCollection.collectionChanged.addEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);\n        this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);\n    }\n\n    /**\n     * Updates all of the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} True if the visualizer successfully updated to the provided time,\n     * false if the visualizer is waiting for asynchronous primitives to be created.\n     */\n    GeometryVisualizer.prototype.update = function(time) {\n        \n\n        var addedObjects = this._addedObjects;\n        var added = addedObjects.values;\n        var removedObjects = this._removedObjects;\n        var removed = removedObjects.values;\n        var changedObjects = this._changedObjects;\n        var changed = changedObjects.values;\n\n        var i;\n        var entity;\n        var id;\n        var updaterSet;\n        var that = this;\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            id = entity.id;\n            updaterSet = this._updaterSets.get(id);\n\n            //If in a single update, an entity gets removed and a new instance\n            //re-added with the same id, the updater no longer tracks the\n            //correct entity, we need to both remove the old one and\n            //add the new one, which is done by pushing the entity\n            //onto the removed/added lists.\n            if (updaterSet.entity === entity) {\n                updaterSet.forEach(function(updater) {\n                    that._removeUpdater(updater);\n                    that._insertUpdaterIntoBatch(time, updater);\n                });\n            } else {\n                removed.push(entity);\n                added.push(entity);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            updaterSet = this._updaterSets.get(id);\n            updaterSet.forEach(this._removeUpdater.bind(this));\n            updaterSet.destroy();\n            this._updaterSets.remove(id);\n            this._subscriptions.get(id)();\n            this._subscriptions.remove(id);\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            updaterSet = new GeometryUpdaterSet(entity, this._scene);\n            this._updaterSets.set(id, updaterSet);\n            updaterSet.forEach(function(updater) {\n                that._insertUpdaterIntoBatch(time, updater);\n            });\n            this._subscriptions.set(id, updaterSet.geometryChanged.addEventListener(GeometryVisualizer._onGeometryChanged, this));\n        }\n\n        addedObjects.removeAll();\n        removedObjects.removeAll();\n        changedObjects.removeAll();\n\n        var isUpdated = true;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            isUpdated = batches[i].update(time) && isUpdated;\n        }\n\n        return isUpdated;\n    };\n\n    var getBoundingSphereArrayScratch = [];\n    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    GeometryVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var boundingSpheres = getBoundingSphereArrayScratch;\n        var tmp = getBoundingSphereBoundingSphereScratch;\n\n        var count = 0;\n        var state = BoundingSphereState.DONE;\n        var batches = this._batches;\n        var batchesLength = batches.length;\n\n        var id = entity.id;\n        var updaters = this._updaterSets.get(id).updaters;\n\n        for (var j = 0; j < updaters.length; j++) {\n            var updater = updaters[j];\n            for (var i = 0; i < batchesLength; i++) {\n                state = batches[i].getBoundingSphere(updater, tmp);\n                if (state === BoundingSphereState.PENDING) {\n                    return BoundingSphereState.PENDING;\n                } else if (state === BoundingSphereState.DONE) {\n                    boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n                    count++;\n                }\n            }\n        }\n\n        if (count === 0) {\n            return BoundingSphereState.FAILED;\n        }\n\n        boundingSpheres.length = count;\n        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    GeometryVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    GeometryVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);\n        this._addedObjects.removeAll();\n        this._removedObjects.removeAll();\n\n        var i;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            batches[i].removeAllPrimitives();\n        }\n\n        var subscriptions = this._subscriptions.values;\n        length = subscriptions.length;\n        for (i = 0; i < length; i++) {\n            subscriptions[i]();\n        }\n        this._subscriptions.removeAll();\n\n        var updaterSets = this._updaterSets.values;\n        length = updaterSets.length;\n        for (i = 0; i < length; i++) {\n            updaterSets[i].destroy();\n        }\n        this._updaterSets.removeAll();\n        return destroyObject(this);\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer.prototype._removeUpdater = function(updater) {\n        //We don't keep track of which batch an updater is in, so just remove it from all of them.\n        var batches = this._batches;\n        var length = batches.length;\n        for (var i = 0; i < length; i++) {\n            batches[i].remove(updater);\n        }\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer.prototype._insertUpdaterIntoBatch = function(time, updater) {\n        if (updater.isDynamic) {\n            this._dynamicBatch.add(time, updater);\n            return;\n        }\n\n        var shadows;\n        if (updater.outlineEnabled || updater.fillEnabled) {\n            shadows = updater.shadowsProperty.getValue(time);\n        }\n\n        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n        if (updater.outlineEnabled) {\n            if (defined(updater.terrainOffsetProperty)) {\n                this._outlineBatches[numberOfShadowModes + shadows].add(time, updater);\n            } else {\n                this._outlineBatches[shadows].add(time, updater);\n            }\n        }\n\n        if (updater.fillEnabled) {\n            if (updater.onTerrain) {\n                var classificationType = updater.classificationTypeProperty.getValue(time);\n                if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                    this._groundColorBatches[classificationType].add(time, updater);\n                } else {\n                    // If unsupported, updater will not be on terrain.\n                    this._groundMaterialBatches[classificationType].add(time, updater);\n                }\n            } else if (updater.isClosed) {\n                if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                    if (defined(updater.terrainOffsetProperty)) {\n                        this._closedColorBatches[numberOfShadowModes + shadows].add(time, updater);\n                    } else {\n                        this._closedColorBatches[shadows].add(time, updater);\n                    }\n                } else if (defined(updater.terrainOffsetProperty)) {\n                    this._closedMaterialBatches[numberOfShadowModes + shadows].add(time, updater);\n                } else {\n                    this._closedMaterialBatches[shadows].add(time, updater);\n                }\n            } else if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                if (defined(updater.terrainOffsetProperty)) {\n                    this._openColorBatches[numberOfShadowModes + shadows].add(time, updater);\n                } else {\n                    this._openColorBatches[shadows].add(time, updater);\n                }\n            } else if (defined(updater.terrainOffsetProperty)) {\n                this._openMaterialBatches[numberOfShadowModes + shadows].add(time, updater);\n            } else {\n                this._openMaterialBatches[shadows].add(time, updater);\n            }\n        }\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer._onGeometryChanged = function(updater) {\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var entity = updater.entity;\n        var id = entity.id;\n\n        if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n            changedObjects.set(id, entity);\n        }\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed) {\n        var addedObjects = this._addedObjects;\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var i;\n        var id;\n        var entity;\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            if (!addedObjects.remove(id)) {\n                removedObjects.set(id, entity);\n                changedObjects.remove(id);\n            }\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            if (removedObjects.remove(id)) {\n                changedObjects.set(id, entity);\n            } else {\n                addedObjects.set(id, entity);\n            }\n        }\n    };\nexport default GeometryVisualizer;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport NearFarScalar from '../Core/NearFarScalar.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport HorizontalOrigin from '../Scene/HorizontalOrigin.js';\nimport LabelStyle from '../Scene/LabelStyle.js';\nimport VerticalOrigin from '../Scene/VerticalOrigin.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var defaultScale = 1.0;\n    var defaultFont = '30px sans-serif';\n    var defaultStyle = LabelStyle.FILL;\n    var defaultFillColor = Color.WHITE;\n    var defaultOutlineColor = Color.BLACK;\n    var defaultOutlineWidth = 1.0;\n    var defaultShowBackground = false;\n    var defaultBackgroundColor = new Color(0.165, 0.165, 0.165, 0.8);\n    var defaultBackgroundPadding = new Cartesian2(7, 5);\n    var defaultPixelOffset = Cartesian2.ZERO;\n    var defaultEyeOffset = Cartesian3.ZERO;\n    var defaultHeightReference = HeightReference.NONE;\n    var defaultHorizontalOrigin = HorizontalOrigin.CENTER;\n    var defaultVerticalOrigin = VerticalOrigin.CENTER;\n\n    var positionScratch = new Cartesian3();\n    var fillColorScratch = new Color();\n    var outlineColorScratch = new Color();\n    var backgroundColorScratch = new Color();\n    var backgroundPaddingScratch = new Cartesian2();\n    var eyeOffsetScratch = new Cartesian3();\n    var pixelOffsetScratch = new Cartesian2();\n    var translucencyByDistanceScratch = new NearFarScalar();\n    var pixelOffsetScaleByDistanceScratch = new NearFarScalar();\n    var scaleByDistanceScratch = new NearFarScalar();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.label = undefined;\n        this.index = undefined;\n    }\n\n    /**\n     * A {@link Visualizer} which maps the {@link LabelGraphics} instance\n     * in {@link Entity#label} to a {@link Label}.\n     * @alias LabelVisualizer\n     * @constructor\n     *\n     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function LabelVisualizer(entityCluster, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(LabelVisualizer.prototype._onCollectionChanged, this);\n\n        this._cluster = entityCluster;\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    LabelVisualizer.prototype.update = function(time) {\n        \n\n        var items = this._items.values;\n        var cluster = this._cluster;\n\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var labelGraphics = entity._label;\n            var text;\n            var label = item.label;\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(labelGraphics._show, time, true);\n            var position;\n            if (show) {\n                position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n                text = Property.getValueOrUndefined(labelGraphics._text, time);\n                show = defined(position) && defined(text);\n            }\n\n            if (!show) {\n                //don't bother creating or updating anything else\n                returnPrimitive(item, entity, cluster);\n                continue;\n            }\n\n            if (!Property.isConstant(entity._position)) {\n                cluster._clusterDirty = true;\n            }\n\n            var updateClamping = false;\n            var heightReference = Property.getValueOrDefault(labelGraphics._heightReference, time, defaultHeightReference);\n\n            if (!defined(label)) {\n                label = cluster.getLabel(entity);\n                label.id = entity;\n                item.label = label;\n\n                // If this new label happens to have a position and height reference that match our new values,\n                // label._updateClamping will not be called automatically. That's a problem because the clamped\n                // height may be based on different terrain than is now loaded. So we'll manually call\n                // _updateClamping below.\n                updateClamping = Cartesian3.equals(label.position, position) && label.heightReference === heightReference;\n            }\n\n            label.show = true;\n            label.position = position;\n            label.text = text;\n            label.scale = Property.getValueOrDefault(labelGraphics._scale, time, defaultScale);\n            label.font = Property.getValueOrDefault(labelGraphics._font, time, defaultFont);\n            label.style = Property.getValueOrDefault(labelGraphics._style, time, defaultStyle);\n            label.fillColor = Property.getValueOrDefault(labelGraphics._fillColor, time, defaultFillColor, fillColorScratch);\n            label.outlineColor = Property.getValueOrDefault(labelGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n            label.outlineWidth = Property.getValueOrDefault(labelGraphics._outlineWidth, time, defaultOutlineWidth);\n            label.showBackground = Property.getValueOrDefault(labelGraphics._showBackground, time, defaultShowBackground);\n            label.backgroundColor = Property.getValueOrDefault(labelGraphics._backgroundColor, time, defaultBackgroundColor, backgroundColorScratch);\n            label.backgroundPadding = Property.getValueOrDefault(labelGraphics._backgroundPadding, time, defaultBackgroundPadding, backgroundPaddingScratch);\n            label.pixelOffset = Property.getValueOrDefault(labelGraphics._pixelOffset, time, defaultPixelOffset, pixelOffsetScratch);\n            label.eyeOffset = Property.getValueOrDefault(labelGraphics._eyeOffset, time, defaultEyeOffset, eyeOffsetScratch);\n            label.heightReference = heightReference;\n            label.horizontalOrigin = Property.getValueOrDefault(labelGraphics._horizontalOrigin, time, defaultHorizontalOrigin);\n            label.verticalOrigin = Property.getValueOrDefault(labelGraphics._verticalOrigin, time, defaultVerticalOrigin);\n            label.translucencyByDistance = Property.getValueOrUndefined(labelGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n            label.pixelOffsetScaleByDistance = Property.getValueOrUndefined(labelGraphics._pixelOffsetScaleByDistance, time, pixelOffsetScaleByDistanceScratch);\n            label.scaleByDistance = Property.getValueOrUndefined(labelGraphics._scaleByDistance, time, scaleByDistanceScratch);\n            label.distanceDisplayCondition = Property.getValueOrUndefined(labelGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n            label.disableDepthTestDistance = Property.getValueOrUndefined(labelGraphics._disableDepthTestDistance, time);\n\n            if (updateClamping) {\n                label._updateClamping();\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    LabelVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var item = this._items.get(entity.id);\n        if (!defined(item) || !defined(item.label)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var label = item.label;\n        result.center = Cartesian3.clone(defaultValue(label._clampedPosition, label.position), result.center);\n        result.radius = 0;\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    LabelVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    LabelVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(LabelVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entityCollection.values;\n        for (var i = 0; i < entities.length; i++) {\n            this._cluster.removeLabel(entities[i]);\n        }\n        return destroyObject(this);\n    };\n\n    LabelVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var items = this._items;\n        var cluster = this._cluster;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._label) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._label) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                returnPrimitive(items.get(entity.id), entity, cluster);\n                items.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            returnPrimitive(items.get(entity.id), entity, cluster);\n            items.remove(entity.id);\n        }\n    };\n\n    function returnPrimitive(item, entity, cluster) {\n        if (defined(item)) {\n            item.label = undefined;\n            cluster.removeLabel(entity);\n        }\n    }\nexport default LabelVisualizer;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Axis from '../Scene/Axis.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport Resource from '../Core/Resource.js';\nimport ColorBlendMode from '../Scene/ColorBlendMode.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport Model from '../Scene/Model.js';\nimport ModelAnimationLoop from '../Scene/ModelAnimationLoop.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var defaultScale = 1.0;\n    var defaultMinimumPixelSize = 0.0;\n    var defaultIncrementallyLoadTextures = true;\n    var defaultClampAnimations = true;\n    var defaultShadows = ShadowMode.ENABLED;\n    var defaultHeightReference = HeightReference.NONE;\n    var defaultSilhouetteColor = Color.RED;\n    var defaultSilhouetteSize = 0.0;\n    var defaultColor = Color.WHITE;\n    var defaultColorBlendMode = ColorBlendMode.HIGHLIGHT;\n    var defaultColorBlendAmount = 0.5;\n    var defaultImageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n    var defaultUpAxis = Axis.Y;\n\n    var modelMatrixScratch = new Matrix4();\n    var nodeMatrixScratch = new Matrix4();\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#model} to a {@link Model}.\n     * @alias ModelVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function ModelVisualizer(scene, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(ModelVisualizer.prototype._onCollectionChanged, this);\n\n        this._scene = scene;\n        this._primitives = scene.primitives;\n        this._entityCollection = entityCollection;\n        this._modelHash = {};\n        this._entitiesToVisualize = new AssociativeArray();\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates models created this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    ModelVisualizer.prototype.update = function(time) {\n        \n\n        var entities = this._entitiesToVisualize.values;\n        var modelHash = this._modelHash;\n        var primitives = this._primitives;\n\n        for (var i = 0, len = entities.length; i < len; i++) {\n            var entity = entities[i];\n            var modelGraphics = entity._model;\n\n            var resource;\n            var modelData = modelHash[entity.id];\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(modelGraphics._show, time, true);\n\n            var modelMatrix;\n            if (show) {\n                modelMatrix = entity.computeModelMatrix(time, modelMatrixScratch);\n                resource = Resource.createIfNeeded(Property.getValueOrUndefined(modelGraphics._uri, time));\n                show = defined(modelMatrix) && defined(resource);\n            }\n\n            if (!show) {\n                if (defined(modelData)) {\n                    modelData.modelPrimitive.show = false;\n                }\n                continue;\n            }\n\n            var model = defined(modelData) ? modelData.modelPrimitive : undefined;\n            if (!defined(model) || resource.url !== modelData.url) {\n                if (defined(model)) {\n                    primitives.removeAndDestroy(model);\n                    delete modelHash[entity.id];\n                }\n                model = Model.fromGltf({\n                    url : resource,\n                    incrementallyLoadTextures : Property.getValueOrDefault(modelGraphics._incrementallyLoadTextures, time, defaultIncrementallyLoadTextures),\n                    scene : this._scene\n                });\n                model.id = entity;\n                primitives.add(model);\n\n                modelData = {\n                    modelPrimitive : model,\n                    url : resource.url,\n                    animationsRunning : false,\n                    nodeTransformationsScratch : {},\n                    articulationsScratch : {},\n                    loadFail : false\n                };\n                modelHash[entity.id] = modelData;\n\n                checkModelLoad(model, entity, modelHash);\n            }\n\n            model.show = true;\n            model.scale = Property.getValueOrDefault(modelGraphics._scale, time, defaultScale);\n            model.minimumPixelSize = Property.getValueOrDefault(modelGraphics._minimumPixelSize, time, defaultMinimumPixelSize);\n            model.maximumScale = Property.getValueOrUndefined(modelGraphics._maximumScale, time);\n            model.modelMatrix = Matrix4.clone(modelMatrix, model.modelMatrix);\n            model.shadows = Property.getValueOrDefault(modelGraphics._shadows, time, defaultShadows);\n            model.heightReference = Property.getValueOrDefault(modelGraphics._heightReference, time, defaultHeightReference);\n            model.distanceDisplayCondition = Property.getValueOrUndefined(modelGraphics._distanceDisplayCondition, time);\n            model.silhouetteColor = Property.getValueOrDefault(modelGraphics._silhouetteColor, time, defaultSilhouetteColor, model._silhouetteColor);\n            model.silhouetteSize = Property.getValueOrDefault(modelGraphics._silhouetteSize, time, defaultSilhouetteSize);\n            model.color = Property.getValueOrDefault(modelGraphics._color, time, defaultColor, model._color);\n            model.colorBlendMode = Property.getValueOrDefault(modelGraphics._colorBlendMode, time, defaultColorBlendMode);\n            model.colorBlendAmount = Property.getValueOrDefault(modelGraphics._colorBlendAmount, time, defaultColorBlendAmount);\n            model.clippingPlanes = Property.getValueOrUndefined(modelGraphics._clippingPlanes, time);\n            model.clampAnimations = Property.getValueOrDefault(modelGraphics._clampAnimations, time, defaultClampAnimations);\n            model.imageBasedLightingFactor = Property.getValueOrDefault(modelGraphics._imageBasedLightingFactor, time, defaultImageBasedLightingFactor);\n            model.lightColor = Property.getValueOrUndefined(modelGraphics._lightColor, time);\n            model._upAxis = Property.getValueOrDefault(modelGraphics._upAxis, time, defaultUpAxis);\n            model._forwardAxis = Property.getValueOrUndefined(modelGraphics._forwardAxis, time);\n\n            if (model.ready) {\n                var runAnimations = Property.getValueOrDefault(modelGraphics._runAnimations, time, true);\n                if (modelData.animationsRunning !== runAnimations) {\n                    if (runAnimations) {\n                        model.activeAnimations.addAll({\n                            loop : ModelAnimationLoop.REPEAT\n                        });\n                    } else {\n                        model.activeAnimations.removeAll();\n                    }\n                    modelData.animationsRunning = runAnimations;\n                }\n\n                // Apply node transformations\n                var nodeTransformations = Property.getValueOrUndefined(modelGraphics._nodeTransformations, time, modelData.nodeTransformationsScratch);\n                if (defined(nodeTransformations)) {\n                    var nodeNames = Object.keys(nodeTransformations);\n                    for (var nodeIndex = 0, nodeLength = nodeNames.length; nodeIndex < nodeLength; ++nodeIndex) {\n                        var nodeName = nodeNames[nodeIndex];\n\n                        var nodeTransformation = nodeTransformations[nodeName];\n                        if (!defined(nodeTransformation)) {\n                            continue;\n                        }\n\n                        var modelNode = model.getNode(nodeName);\n                        if (!defined(modelNode)) {\n                            continue;\n                        }\n\n                        var transformationMatrix = Matrix4.fromTranslationRotationScale(nodeTransformation, nodeMatrixScratch);\n                        modelNode.matrix = Matrix4.multiply(modelNode.originalMatrix, transformationMatrix, transformationMatrix);\n                    }\n                }\n\n                // Apply articulations\n                var anyArticulationUpdated = false;\n                var articulations = Property.getValueOrUndefined(modelGraphics._articulations, time, modelData.articulationsScratch);\n                if (defined(articulations)) {\n                    var articulationStageKeys = Object.keys(articulations);\n                    for (var s = 0, numKeys = articulationStageKeys.length; s < numKeys; ++s) {\n                        var key = articulationStageKeys[s];\n\n                        var articulationStageValue = articulations[key];\n                        if (!defined(articulationStageValue)) {\n                            continue;\n                        }\n\n                        anyArticulationUpdated = true;\n                        model.setArticulationStage(key, articulationStageValue);\n                    }\n                }\n\n                if (anyArticulationUpdated) {\n                    model.applyArticulations();\n                }\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    ModelVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    ModelVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(ModelVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entitiesToVisualize.values;\n        var modelHash = this._modelHash;\n        var primitives = this._primitives;\n        for (var i = entities.length - 1; i > -1; i--) {\n            removeModel(this, entities[i], modelHash, primitives);\n        }\n        return destroyObject(this);\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    ModelVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var modelData = this._modelHash[entity.id];\n        if (!defined(modelData) || modelData.loadFail) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var model = modelData.modelPrimitive;\n        if (!defined(model) || !model.show) {\n            return BoundingSphereState.FAILED;\n        }\n\n        if (!model.ready) {\n            return BoundingSphereState.PENDING;\n        }\n\n        if (model.heightReference === HeightReference.NONE) {\n            BoundingSphere.transform(model.boundingSphere, model.modelMatrix, result);\n        } else {\n            if (!defined(model._clampedModelMatrix) || model._heightChanged) {\n                return BoundingSphereState.PENDING;\n            }\n            BoundingSphere.transform(model.boundingSphere, model._clampedModelMatrix, result);\n        }\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * @private\n     */\n    ModelVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var entities = this._entitiesToVisualize;\n        var modelHash = this._modelHash;\n        var primitives = this._primitives;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._model) && defined(entity._position)) {\n                entities.set(entity.id, entity);\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._model) && defined(entity._position)) {\n                clearNodeTransformationsArticulationsScratch(entity, modelHash);\n                entities.set(entity.id, entity);\n            } else {\n                removeModel(this, entity, modelHash, primitives);\n                entities.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            removeModel(this, entity, modelHash, primitives);\n            entities.remove(entity.id);\n        }\n    };\n\n    function removeModel(visualizer, entity, modelHash, primitives) {\n        var modelData = modelHash[entity.id];\n        if (defined(modelData)) {\n            primitives.removeAndDestroy(modelData.modelPrimitive);\n            delete modelHash[entity.id];\n        }\n    }\n\n    function clearNodeTransformationsArticulationsScratch(entity, modelHash) {\n        var modelData = modelHash[entity.id];\n        if (defined(modelData)) {\n            modelData.nodeTransformationsScratch = {};\n            modelData.articulationsScratch = {};\n        }\n    }\n\n    function checkModelLoad(model, entity, modelHash){\n        model.readyPromise.otherwise(function(error){\n            console.error(error);\n            modelHash[entity.id].loadFail = true;\n        });\n    }\nexport default ModelVisualizer;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport JulianDate from '../Core/JulianDate.js';\nimport Matrix3 from '../Core/Matrix3.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport ReferenceFrame from '../Core/ReferenceFrame.js';\nimport TimeInterval from '../Core/TimeInterval.js';\nimport Transforms from '../Core/Transforms.js';\nimport PolylineCollection from '../Scene/PolylineCollection.js';\nimport SceneMode from '../Scene/SceneMode.js';\nimport CompositePositionProperty from './CompositePositionProperty.js';\nimport ConstantPositionProperty from './ConstantPositionProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\nimport ReferenceProperty from './ReferenceProperty.js';\nimport SampledPositionProperty from './SampledPositionProperty.js';\nimport ScaledPositionProperty from './ScaledPositionProperty.js';\nimport TimeIntervalCollectionPositionProperty from './TimeIntervalCollectionPositionProperty.js';\n\n    var defaultResolution = 60.0;\n    var defaultWidth = 1.0;\n\n    var scratchTimeInterval = new TimeInterval();\n    var subSampleCompositePropertyScratch = new TimeInterval();\n    var subSampleIntervalPropertyScratch = new TimeInterval();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.polyline = undefined;\n        this.index = undefined;\n        this.updater = undefined;\n    }\n\n    function subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        var r = startingIndex;\n        //Always step exactly on start (but only use it if it exists.)\n        var tmp;\n        tmp = property.getValueInReferenceFrame(start, referenceFrame, result[r]);\n        if (defined(tmp)) {\n            result[r++] = tmp;\n        }\n\n        var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);\n\n        //Iterate over all interval times and add the ones that fall in our\n        //time range.  Note that times can contain data outside of\n        //the intervals range.  This is by design for use with interpolation.\n        var t = 0;\n        var len = times.length;\n        var current = times[t];\n        var loopStop = stop;\n        var sampling = false;\n        var sampleStepsToTake;\n        var sampleStepsTaken;\n        var sampleStepSize;\n\n        while (t < len) {\n            if (!steppedOnNow && JulianDate.greaterThanOrEquals(current, updateTime)) {\n                tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[r]);\n                if (defined(tmp)) {\n                    result[r++] = tmp;\n                }\n                steppedOnNow = true;\n            }\n            if (JulianDate.greaterThan(current, start) && JulianDate.lessThan(current, loopStop) && !current.equals(updateTime)) {\n                tmp = property.getValueInReferenceFrame(current, referenceFrame, result[r]);\n                if (defined(tmp)) {\n                    result[r++] = tmp;\n                }\n            }\n\n            if (t < (len - 1)) {\n                if (maximumStep > 0 && !sampling) {\n                    var next = times[t + 1];\n                    var secondsUntilNext = JulianDate.secondsDifference(next, current);\n                    sampling = secondsUntilNext > maximumStep;\n\n                    if (sampling) {\n                        sampleStepsToTake = Math.ceil(secondsUntilNext / maximumStep);\n                        sampleStepsTaken = 0;\n                        sampleStepSize = secondsUntilNext / Math.max(sampleStepsToTake, 2);\n                        sampleStepsToTake = Math.max(sampleStepsToTake - 1, 1);\n                    }\n                }\n\n                if (sampling && sampleStepsTaken < sampleStepsToTake) {\n                    current = JulianDate.addSeconds(current, sampleStepSize, new JulianDate());\n                    sampleStepsTaken++;\n                    continue;\n                }\n            }\n            sampling = false;\n            t++;\n            current = times[t];\n        }\n\n        //Always step exactly on stop (but only use it if it exists.)\n        tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[r]);\n        if (defined(tmp)) {\n            result[r++] = tmp;\n        }\n\n        return r;\n    }\n\n    function subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        var tmp;\n        var i = 0;\n        var index = startingIndex;\n        var time = start;\n        var stepSize = Math.max(maximumStep, 60);\n        var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);\n        while (JulianDate.lessThan(time, stop)) {\n            if (!steppedOnNow && JulianDate.greaterThanOrEquals(time, updateTime)) {\n                steppedOnNow = true;\n                tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[index]);\n                if (defined(tmp)) {\n                    result[index] = tmp;\n                    index++;\n                }\n            }\n            tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);\n            if (defined(tmp)) {\n                result[index] = tmp;\n                index++;\n            }\n            i++;\n            time = JulianDate.addSeconds(start, stepSize * i, new JulianDate());\n        }\n        //Always sample stop.\n        tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[index]);\n        if (defined(tmp)) {\n            result[index] = tmp;\n            index++;\n        }\n        return index;\n    }\n\n    function subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        subSampleIntervalPropertyScratch.start = start;\n        subSampleIntervalPropertyScratch.stop = stop;\n\n        var index = startingIndex;\n        var intervals = property.intervals;\n        for (var i = 0; i < intervals.length; i++) {\n            var interval = intervals.get(i);\n            if (!TimeInterval.intersect(interval, subSampleIntervalPropertyScratch, scratchTimeInterval).isEmpty) {\n                var time = interval.start;\n                if (!interval.isStartIncluded) {\n                    if (interval.isStopIncluded) {\n                        time = interval.stop;\n                    } else {\n                        time = JulianDate.addSeconds(interval.start, JulianDate.secondsDifference(interval.stop, interval.start) / 2, new JulianDate());\n                    }\n                }\n                var tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);\n                if (defined(tmp)) {\n                    result[index] = tmp;\n                    index++;\n                }\n            }\n        }\n        return index;\n    }\n\n    function subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        var tmp = property.getValueInReferenceFrame(start, referenceFrame, result[startingIndex]);\n        if (defined(tmp)) {\n            result[startingIndex++] = tmp;\n        }\n        return startingIndex;\n    }\n\n    function subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        subSampleCompositePropertyScratch.start = start;\n        subSampleCompositePropertyScratch.stop = stop;\n\n        var index = startingIndex;\n        var intervals = property.intervals;\n        for (var i = 0; i < intervals.length; i++) {\n            var interval = intervals.get(i);\n            if (!TimeInterval.intersect(interval, subSampleCompositePropertyScratch, scratchTimeInterval).isEmpty) {\n                var intervalStart = interval.start;\n                var intervalStop = interval.stop;\n\n                var sampleStart = start;\n                if (JulianDate.greaterThan(intervalStart, sampleStart)) {\n                    sampleStart = intervalStart;\n                }\n\n                var sampleStop = stop;\n                if (JulianDate.lessThan(intervalStop, sampleStop)) {\n                    sampleStop = intervalStop;\n                }\n\n                index = reallySubSample(interval.data, sampleStart, sampleStop, updateTime, referenceFrame, maximumStep, index, result);\n            }\n        }\n        return index;\n    }\n\n    function reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, index, result) {\n        //Unwrap any references until we have the actual property.\n        while (property instanceof ReferenceProperty) {\n            property = property.resolvedProperty;\n        }\n\n        if (property instanceof SampledPositionProperty) {\n            var times = property._property._times;\n            index = subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, index, result);\n        } else if (property instanceof CompositePositionProperty) {\n            index = subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        } else if (property instanceof TimeIntervalCollectionPositionProperty) {\n            index = subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        } else if (property instanceof ConstantPositionProperty ||\n                   (property instanceof ScaledPositionProperty && Property.isConstant(property))) {\n            index = subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        } else {\n            //Fallback to generic sampling.\n            index = subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        }\n        return index;\n    }\n\n    function subSample(property, start, stop, updateTime, referenceFrame, maximumStep, result) {\n        if (!defined(result)) {\n            result = [];\n        }\n\n        var length = reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, 0, result);\n        result.length = length;\n        return result;\n    }\n\n    var toFixedScratch = new Matrix3();\n    function PolylineUpdater(scene, referenceFrame) {\n        this._unusedIndexes = [];\n        this._polylineCollection = new PolylineCollection();\n        this._scene = scene;\n        this._referenceFrame = referenceFrame;\n        scene.primitives.add(this._polylineCollection);\n    }\n\n    PolylineUpdater.prototype.update = function(time) {\n        if (this._referenceFrame === ReferenceFrame.INERTIAL) {\n            var toFixed = Transforms.computeIcrfToFixedMatrix(time, toFixedScratch);\n            if (!defined(toFixed)) {\n                toFixed = Transforms.computeTemeToPseudoFixedMatrix(time, toFixedScratch);\n            }\n            Matrix4.fromRotationTranslation(toFixed, Cartesian3.ZERO, this._polylineCollection.modelMatrix);\n        }\n    };\n\n    PolylineUpdater.prototype.updateObject = function(time, item) {\n        var entity = item.entity;\n        var pathGraphics = entity._path;\n        var positionProperty = entity._position;\n\n        var sampleStart;\n        var sampleStop;\n        var showProperty = pathGraphics._show;\n        var polyline = item.polyline;\n        var show = entity.isShowing && (!defined(showProperty) || showProperty.getValue(time));\n\n        //While we want to show the path, there may not actually be anything to show\n        //depending on lead/trail settings.  Compute the interval of the path to\n        //show and check against actual availability.\n        if (show) {\n            var leadTime = Property.getValueOrUndefined(pathGraphics._leadTime, time);\n            var trailTime = Property.getValueOrUndefined(pathGraphics._trailTime, time);\n            var availability = entity._availability;\n            var hasAvailability = defined(availability);\n            var hasLeadTime = defined(leadTime);\n            var hasTrailTime = defined(trailTime);\n\n            //Objects need to have either defined availability or both a lead and trail time in order to\n            //draw a path (since we can't draw \"infinite\" paths.\n            show = hasAvailability || (hasLeadTime && hasTrailTime);\n\n            //The final step is to compute the actual start/stop times of the path to show.\n            //If current time is outside of the availability interval, there's a chance that\n            //we won't have to draw anything anyway.\n            if (show) {\n                if (hasTrailTime) {\n                    sampleStart = JulianDate.addSeconds(time, -trailTime, new JulianDate());\n                }\n                if (hasLeadTime) {\n                    sampleStop = JulianDate.addSeconds(time, leadTime, new JulianDate());\n                }\n\n                if (hasAvailability) {\n                    var start = availability.start;\n                    var stop = availability.stop;\n\n                    if (!hasTrailTime || JulianDate.greaterThan(start, sampleStart)) {\n                        sampleStart = start;\n                    }\n\n                    if (!hasLeadTime || JulianDate.lessThan(stop, sampleStop)) {\n                        sampleStop = stop;\n                    }\n                }\n                show = JulianDate.lessThan(sampleStart, sampleStop);\n            }\n        }\n\n        if (!show) {\n            //don't bother creating or updating anything else\n            if (defined(polyline)) {\n                this._unusedIndexes.push(item.index);\n                item.polyline = undefined;\n                polyline.show = false;\n                item.index = undefined;\n            }\n            return;\n        }\n\n        if (!defined(polyline)) {\n            var unusedIndexes = this._unusedIndexes;\n            var length = unusedIndexes.length;\n            if (length > 0) {\n                var index = unusedIndexes.pop();\n                polyline = this._polylineCollection.get(index);\n                item.index = index;\n            } else {\n                item.index = this._polylineCollection.length;\n                polyline = this._polylineCollection.add();\n            }\n            polyline.id = entity;\n            item.polyline = polyline;\n        }\n\n        var resolution = Property.getValueOrDefault(pathGraphics._resolution, time, defaultResolution);\n\n        polyline.show = true;\n        polyline.positions = subSample(positionProperty, sampleStart, sampleStop, time, this._referenceFrame, resolution, polyline.positions.slice());\n        polyline.material = MaterialProperty.getValue(time, pathGraphics._material, polyline.material);\n        polyline.width = Property.getValueOrDefault(pathGraphics._width, time, defaultWidth);\n        polyline.distanceDisplayCondition = Property.getValueOrUndefined(pathGraphics._distanceDisplayCondition, time, polyline.distanceDisplayCondition);\n    };\n\n    PolylineUpdater.prototype.removeObject = function(item) {\n        var polyline = item.polyline;\n        if (defined(polyline)) {\n            this._unusedIndexes.push(item.index);\n            item.polyline = undefined;\n            polyline.show = false;\n            polyline.id = undefined;\n            item.index = undefined;\n        }\n    };\n\n    PolylineUpdater.prototype.destroy = function() {\n        this._scene.primitives.remove(this._polylineCollection);\n        return destroyObject(this);\n    };\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#path} to a {@link Polyline}.\n     * @alias PathVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function PathVisualizer(scene, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(PathVisualizer.prototype._onCollectionChanged, this);\n\n        this._scene = scene;\n        this._updaters = {};\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates all of the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    PathVisualizer.prototype.update = function(time) {\n        \n\n        var updaters = this._updaters;\n        for (var key in updaters) {\n            if (updaters.hasOwnProperty(key)) {\n                updaters[key].update(time);\n            }\n        }\n\n        var items = this._items.values;\n        if (items.length === 0 && defined(this._updaters) && Object.keys(this._updaters).length > 0) {\n            for (var u in updaters) {\n                if (updaters.hasOwnProperty(u)) {\n                    updaters[u].destroy();\n                }\n            }\n            this._updaters = {};\n        }\n\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var positionProperty = entity._position;\n\n            var lastUpdater = item.updater;\n\n            var frameToVisualize = ReferenceFrame.FIXED;\n            if (this._scene.mode === SceneMode.SCENE3D) {\n                frameToVisualize = positionProperty.referenceFrame;\n            }\n\n            var currentUpdater = this._updaters[frameToVisualize];\n\n            if ((lastUpdater === currentUpdater) && (defined(currentUpdater))) {\n                currentUpdater.updateObject(time, item);\n                continue;\n            }\n\n            if (defined(lastUpdater)) {\n                lastUpdater.removeObject(item);\n            }\n\n            if (!defined(currentUpdater)) {\n                currentUpdater = new PolylineUpdater(this._scene, frameToVisualize);\n                currentUpdater.update(time);\n                this._updaters[frameToVisualize] = currentUpdater;\n            }\n\n            item.updater = currentUpdater;\n            if (defined(currentUpdater)) {\n                currentUpdater.updateObject(time, item);\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PathVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    PathVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(PathVisualizer.prototype._onCollectionChanged, this);\n\n        var updaters = this._updaters;\n        for ( var key in updaters) {\n            if (updaters.hasOwnProperty(key)) {\n                updaters[key].destroy();\n            }\n        }\n\n        return destroyObject(this);\n    };\n\n    PathVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var item;\n        var items = this._items;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._path) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._path) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                item = items.get(entity.id);\n                if (defined(item)) {\n                    if (defined(item.updater)) {\n                        item.updater.removeObject(item);\n                    }\n                    items.remove(entity.id);\n                }\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            item = items.get(entity.id);\n            if (defined(item)) {\n                if (defined(item.updater)) {\n                    item.updater.removeObject(item);\n                }\n                items.remove(entity.id);\n            }\n        }\n    };\n\n    //for testing\n    PathVisualizer._subSample = subSample;\nexport default PathVisualizer;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport NearFarScalar from '../Core/NearFarScalar.js';\nimport createBillboardPointCallback from '../Scene/createBillboardPointCallback.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var defaultColor = Color.WHITE;\n    var defaultOutlineColor = Color.BLACK;\n    var defaultOutlineWidth = 0.0;\n    var defaultPixelSize = 1.0;\n    var defaultDisableDepthTestDistance = 0.0;\n\n    var colorScratch = new Color();\n    var positionScratch = new Cartesian3();\n    var outlineColorScratch = new Color();\n    var scaleByDistanceScratch = new NearFarScalar();\n    var translucencyByDistanceScratch = new NearFarScalar();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.pointPrimitive = undefined;\n        this.billboard = undefined;\n        this.color = undefined;\n        this.outlineColor = undefined;\n        this.pixelSize = undefined;\n        this.outlineWidth = undefined;\n    }\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.\n     * @alias PointVisualizer\n     * @constructor\n     *\n     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function PointVisualizer(entityCluster, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(PointVisualizer.prototype._onCollectionChanged, this);\n\n        this._cluster = entityCluster;\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    PointVisualizer.prototype.update = function(time) {\n        \n\n        var items = this._items.values;\n        var cluster = this._cluster;\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var pointGraphics = entity._point;\n            var pointPrimitive = item.pointPrimitive;\n            var billboard = item.billboard;\n            var heightReference = Property.getValueOrDefault(pointGraphics._heightReference, time, HeightReference.NONE);\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(pointGraphics._show, time, true);\n            var position;\n            if (show) {\n                position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n                show = defined(position);\n            }\n            if (!show) {\n                returnPrimitive(item, entity, cluster);\n                continue;\n            }\n\n            if (!Property.isConstant(entity._position)) {\n                cluster._clusterDirty = true;\n            }\n\n            var needsRedraw = false;\n            var updateClamping = false;\n            if ((heightReference !== HeightReference.NONE) && !defined(billboard)) {\n                if (defined(pointPrimitive)) {\n                    returnPrimitive(item, entity, cluster);\n                    pointPrimitive = undefined;\n                }\n\n                billboard = cluster.getBillboard(entity);\n                billboard.id = entity;\n                billboard.image = undefined;\n                item.billboard = billboard;\n                needsRedraw = true;\n\n                // If this new billboard happens to have a position and height reference that match our new values,\n                // billboard._updateClamping will not be called automatically. That's a problem because the clamped\n                // height may be based on different terrain than is now loaded. So we'll manually call\n                // _updateClamping below.\n                updateClamping = Cartesian3.equals(billboard.position, position) && billboard.heightReference === heightReference;\n            } else if ((heightReference === HeightReference.NONE) && !defined(pointPrimitive)) {\n                if (defined(billboard)) {\n                    returnPrimitive(item, entity, cluster);\n                    billboard = undefined;\n                }\n\n                pointPrimitive = cluster.getPoint(entity);\n                pointPrimitive.id = entity;\n                item.pointPrimitive = pointPrimitive;\n            }\n\n            if (defined(pointPrimitive)) {\n                pointPrimitive.show = true;\n                pointPrimitive.position = position;\n                pointPrimitive.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);\n                pointPrimitive.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n                pointPrimitive.color = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);\n                pointPrimitive.outlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n                pointPrimitive.outlineWidth = Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth);\n                pointPrimitive.pixelSize = Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize);\n                pointPrimitive.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n                pointPrimitive.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);\n            } else if (defined(billboard)) {\n                billboard.show = true;\n                billboard.position = position;\n                billboard.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);\n                billboard.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n                billboard.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n                billboard.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);\n                billboard.heightReference = heightReference;\n\n                var newColor = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);\n                var newOutlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n                var newOutlineWidth = Math.round(Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth));\n                var newPixelSize = Math.max(1, Math.round(Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize)));\n\n                if (newOutlineWidth > 0) {\n                    billboard.scale = 1.0;\n                    needsRedraw = needsRedraw || //\n                                 newOutlineWidth !== item.outlineWidth || //\n                                 newPixelSize !== item.pixelSize || //\n                                 !Color.equals(newColor, item.color) || //\n                                 !Color.equals(newOutlineColor, item.outlineColor);\n                } else {\n                    billboard.scale = newPixelSize / 50.0;\n                    newPixelSize = 50.0;\n                    needsRedraw = needsRedraw || //\n                                 newOutlineWidth !== item.outlineWidth || //\n                                 !Color.equals(newColor, item.color) || //\n                                 !Color.equals(newOutlineColor, item.outlineColor);\n                }\n\n                if (needsRedraw) {\n                    item.color = Color.clone(newColor, item.color);\n                    item.outlineColor = Color.clone(newOutlineColor, item.outlineColor);\n                    item.pixelSize = newPixelSize;\n                    item.outlineWidth = newOutlineWidth;\n\n                    var centerAlpha = newColor.alpha;\n                    var cssColor = newColor.toCssColorString();\n                    var cssOutlineColor = newOutlineColor.toCssColorString();\n                    var textureId = JSON.stringify([cssColor, newPixelSize, cssOutlineColor, newOutlineWidth]);\n\n                    billboard.setImage(textureId, createBillboardPointCallback(centerAlpha, cssColor, cssOutlineColor, newOutlineWidth, newPixelSize));\n                }\n\n                if (updateClamping) {\n                    billboard._updateClamping();\n                }\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    PointVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var item = this._items.get(entity.id);\n        if (!defined(item) || !(defined(item.pointPrimitive) || defined(item.billboard))) {\n            return BoundingSphereState.FAILED;\n        }\n\n        if (defined(item.pointPrimitive)) {\n            result.center = Cartesian3.clone(item.pointPrimitive.position, result.center);\n        } else {\n            var billboard = item.billboard;\n            if (!defined(billboard._clampedPosition)) {\n                return BoundingSphereState.PENDING;\n            }\n            result.center = Cartesian3.clone(billboard._clampedPosition, result.center);\n        }\n\n        result.radius = 0;\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PointVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    PointVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(PointVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entityCollection.values;\n        for (var i = 0; i < entities.length; i++) {\n            this._cluster.removePoint(entities[i]);\n        }\n        return destroyObject(this);\n    };\n\n    PointVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var items = this._items;\n        var cluster = this._cluster;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._point) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._point) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                returnPrimitive(items.get(entity.id), entity, cluster);\n                items.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            returnPrimitive(items.get(entity.id), entity, cluster);\n            items.remove(entity.id);\n        }\n    };\n\n    function returnPrimitive(item, entity, cluster) {\n        if (defined(item)) {\n            var pointPrimitive = item.pointPrimitive;\n            if (defined(pointPrimitive)) {\n                item.pointPrimitive = undefined;\n                cluster.removePoint(entity);\n                return;\n            }\n            var billboard = item.billboard;\n            if (defined(billboard)) {\n                item.billboard = undefined;\n                cluster.removeBillboard(entity);\n            }\n        }\n    }\nexport default PointVisualizer;\n","import ArcType from './ArcType.js';\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Color from './Color.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryType from './GeometryType.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolylinePipeline from './PolylinePipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var scratchInterpolateColorsArray = [];\n\n    function interpolateColors(p0, p1, color0, color1, numPoints) {\n        var colors = scratchInterpolateColorsArray;\n        colors.length = numPoints;\n        var i;\n\n        var r0 = color0.red;\n        var g0 = color0.green;\n        var b0 = color0.blue;\n        var a0 = color0.alpha;\n\n        var r1 = color1.red;\n        var g1 = color1.green;\n        var b1 = color1.blue;\n        var a1 = color1.alpha;\n\n        if (Color.equals(color0, color1)) {\n            for (i = 0; i < numPoints; i++) {\n                colors[i] = Color.clone(color0);\n            }\n            return colors;\n        }\n\n        var redPerVertex = (r1 - r0) / numPoints;\n        var greenPerVertex = (g1 - g0) / numPoints;\n        var bluePerVertex = (b1 - b0) / numPoints;\n        var alphaPerVertex = (a1 - a0) / numPoints;\n\n        for (i = 0; i < numPoints; i++) {\n            colors[i] = new Color(r0 + i * redPerVertex, g0 + i * greenPerVertex, b0 + i * bluePerVertex, a0 + i * alphaPerVertex);\n        }\n\n        return colors;\n    }\n\n    /**\n     * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n     * and each additional position defines a line segment from the previous position. The polyline is capable of\n     * displaying with a material.\n     *\n     * @alias PolylineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n     * @param {Number} [options.width=1.0] The width in pixels.\n     * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n     * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     *\n     * @exception {DeveloperError} At least two positions are required.\n     * @exception {DeveloperError} width must be greater than or equal to one.\n     * @exception {DeveloperError} colors has an invalid length.\n     *\n     * @see PolylineGeometry#createGeometry\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}\n     *\n     * @example\n     * // A polyline with two connected line segments\n     * var polyline = new Cesium.PolylineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     0.0, 0.0,\n     *     5.0, 0.0,\n     *     5.0, 5.0\n     *   ]),\n     *   width : 10.0\n     * });\n     * var geometry = Cesium.PolylineGeometry.createGeometry(polyline);\n     */\n    function PolylineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var colors = options.colors;\n        var width = defaultValue(options.width, 1.0);\n        var colorsPerVertex = defaultValue(options.colorsPerVertex, false);\n\n        \n\n        this._positions = positions;\n        this._colors = colors;\n        this._width = width;\n        this._colorsPerVertex = colorsPerVertex;\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n\n        this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._workerName = 'createPolylineGeometry';\n\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\n        numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 4;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolylineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolylineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var colors = value._colors;\n        length = defined(colors) ? colors.length : 0.0;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n            Color.pack(colors[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._width;\n        array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n        array[startingIndex++] = value._arcType;\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        positions : undefined,\n        colors : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        width : undefined,\n        colorsPerVertex : undefined,\n        arcType : undefined,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolylineGeometry} [result] The object into which to store the result.\n     * @returns {PolylineGeometry} The modified result parameter or a new PolylineGeometry instance if one was not provided.\n     */\n    PolylineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var colors = length > 0 ? new Array(length) : undefined;\n\n        for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n            colors[i] = Color.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var width = array[startingIndex++];\n        var colorsPerVertex = array[startingIndex++] === 1.0;\n        var arcType = array[startingIndex++];\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.colors = colors;\n            scratchOptions.width = width;\n            scratchOptions.colorsPerVertex = colorsPerVertex;\n            scratchOptions.arcType = arcType;\n            scratchOptions.granularity = granularity;\n            return new PolylineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._colors = colors;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._width = width;\n        result._colorsPerVertex = colorsPerVertex;\n        result._arcType = arcType;\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    var scratchCartesian3 = new Cartesian3();\n    var scratchPosition = new Cartesian3();\n    var scratchPrevPosition = new Cartesian3();\n    var scratchNextPosition = new Cartesian3();\n\n    /**\n     * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolylineGeometry} polylineGeometry A description of the polyline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolylineGeometry.createGeometry = function(polylineGeometry) {\n        var width = polylineGeometry._width;\n        var vertexFormat = polylineGeometry._vertexFormat;\n        var colors = polylineGeometry._colors;\n        var colorsPerVertex = polylineGeometry._colorsPerVertex;\n        var arcType = polylineGeometry._arcType;\n        var granularity = polylineGeometry._granularity;\n        var ellipsoid = polylineGeometry._ellipsoid;\n\n        var i;\n        var j;\n        var k;\n\n        var positions = arrayRemoveDuplicates(polylineGeometry._positions, Cartesian3.equalsEpsilon);\n        var positionsLength = positions.length;\n\n        // A width of a pixel or less is not a valid geometry, but in order to support external data\n        // that may have errors we treat this as an empty geometry.\n        if (positionsLength < 2 || width <= 0.0) {\n            return undefined;\n        }\n\n        if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n            var subdivisionSize;\n            var numberOfPointsFunction;\n            if (arcType === ArcType.GEODESIC) {\n                subdivisionSize = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n                numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n            } else {\n                subdivisionSize = granularity;\n                numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n            }\n\n            var heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n\n            if (defined(colors)) {\n                var colorLength = 1;\n                for (i = 0; i < positionsLength - 1; ++i) {\n                    colorLength += numberOfPointsFunction(positions[i], positions[i + 1], subdivisionSize);\n                }\n\n                var newColors = new Array(colorLength);\n                var newColorIndex = 0;\n\n                for (i = 0; i < positionsLength - 1; ++i) {\n                    var p0 = positions[i];\n                    var p1 = positions[i + 1];\n                    var c0 = colors[i];\n\n                    var numColors = numberOfPointsFunction(p0, p1, subdivisionSize);\n                    if (colorsPerVertex && i < colorLength) {\n                        var c1 = colors[i + 1];\n                        var interpolatedColors = interpolateColors(p0, p1, c0, c1, numColors);\n                        var interpolatedColorsLength = interpolatedColors.length;\n                        for (j = 0; j < interpolatedColorsLength; ++j) {\n                            newColors[newColorIndex++] = interpolatedColors[j];\n                        }\n                    } else {\n                        for (j = 0; j < numColors; ++j) {\n                            newColors[newColorIndex++] = Color.clone(c0);\n                        }\n                    }\n                }\n\n                newColors[newColorIndex] = Color.clone(colors[colors.length - 1]);\n                colors = newColors;\n\n                scratchInterpolateColorsArray.length = 0;\n            }\n\n            if (arcType === ArcType.GEODESIC) {\n                positions = PolylinePipeline.generateCartesianArc({\n                    positions: positions,\n                    minDistance: subdivisionSize,\n                    ellipsoid: ellipsoid,\n                    height: heights\n                });\n            } else {\n                positions = PolylinePipeline.generateCartesianRhumbArc({\n                    positions: positions,\n                    granularity: subdivisionSize,\n                    ellipsoid: ellipsoid,\n                    height: heights\n                });\n            }\n        }\n\n        positionsLength = positions.length;\n        var size = positionsLength * 4.0 - 4.0;\n\n        var finalPositions = new Float64Array(size * 3);\n        var prevPositions = new Float64Array(size * 3);\n        var nextPositions = new Float64Array(size * 3);\n        var expandAndWidth = new Float32Array(size * 2);\n        var st = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n        var finalColors = defined(colors) ? new Uint8Array(size * 4) : undefined;\n\n        var positionIndex = 0;\n        var expandAndWidthIndex = 0;\n        var stIndex = 0;\n        var colorIndex = 0;\n        var position;\n\n        for (j = 0; j < positionsLength; ++j) {\n            if (j === 0) {\n                position = scratchCartesian3;\n                Cartesian3.subtract(positions[0], positions[1], position);\n                Cartesian3.add(positions[0], position, position);\n            } else {\n                position = positions[j - 1];\n            }\n\n            Cartesian3.clone(position, scratchPrevPosition);\n            Cartesian3.clone(positions[j], scratchPosition);\n\n            if (j === positionsLength - 1) {\n                position = scratchCartesian3;\n                Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);\n                Cartesian3.add(positions[positionsLength - 1], position, position);\n            } else {\n                position = positions[j + 1];\n            }\n\n            Cartesian3.clone(position, scratchNextPosition);\n\n            var color0, color1;\n            if (defined(finalColors)) {\n                if (j !== 0 && !colorsPerVertex) {\n                    color0 = colors[j - 1];\n                } else {\n                    color0 = colors[j];\n                }\n\n                if (j !== positionsLength - 1) {\n                    color1 = colors[j];\n                }\n            }\n\n            var startK = j === 0 ? 2 : 0;\n            var endK = j === positionsLength - 1 ? 2 : 4;\n\n            for (k = startK; k < endK; ++k) {\n                Cartesian3.pack(scratchPosition, finalPositions, positionIndex);\n                Cartesian3.pack(scratchPrevPosition, prevPositions, positionIndex);\n                Cartesian3.pack(scratchNextPosition, nextPositions, positionIndex);\n                positionIndex += 3;\n\n                var direction = (k - 2 < 0) ? -1.0 : 1.0;\n                expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1;       // expand direction\n                expandAndWidth[expandAndWidthIndex++] = direction * width;\n\n                if (vertexFormat.st) {\n                    st[stIndex++] = j / (positionsLength - 1);\n                    st[stIndex++] = Math.max(expandAndWidth[expandAndWidthIndex - 2], 0.0);\n                }\n\n                if (defined(finalColors)) {\n                    var color = (k < 2) ? color0 : color1;\n\n                    finalColors[colorIndex++] = Color.floatToByte(color.red);\n                    finalColors[colorIndex++] = Color.floatToByte(color.green);\n                    finalColors[colorIndex++] = Color.floatToByte(color.blue);\n                    finalColors[colorIndex++] = Color.floatToByte(color.alpha);\n                }\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : finalPositions\n        });\n\n        attributes.prevPosition = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : prevPositions\n        });\n\n        attributes.nextPosition = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : nextPositions\n        });\n\n        attributes.expandAndWidth = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : 2,\n            values : expandAndWidth\n        });\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : st\n            });\n        }\n\n        if (defined(finalColors)) {\n            attributes.color = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 4,\n                values : finalColors,\n                normalize : true\n            });\n        }\n\n        var indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);\n        var index = 0;\n        var indicesIndex = 0;\n        var length = positionsLength - 1.0;\n        for (j = 0; j < length; ++j) {\n            indices[indicesIndex++] = index;\n            indices[indicesIndex++] = index + 2;\n            indices[indicesIndex++] = index + 1;\n\n            indices[indicesIndex++] = index + 1;\n            indices[indicesIndex++] = index + 2;\n            indices[indicesIndex++] = index + 3;\n\n            index += 4;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : BoundingSphere.fromPoints(positions),\n            geometryType : GeometryType.POLYLINES\n        });\n    };\nexport default PolylineGeometry;\n","import ArcType from '../Core/ArcType.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport Event from '../Core/Event.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport GroundPolylineGeometry from '../Core/GroundPolylineGeometry.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport oneTimeWarning from '../Core/oneTimeWarning.js';\nimport PolylineGeometry from '../Core/PolylineGeometry.js';\nimport PolylinePipeline from '../Core/PolylinePipeline.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport Entity from '../DataSources/Entity.js';\nimport ClassificationType from '../Scene/ClassificationType.js';\nimport GroundPolylinePrimitive from '../Scene/GroundPolylinePrimitive.js';\nimport PolylineCollection from '../Scene/PolylineCollection.js';\nimport PolylineColorAppearance from '../Scene/PolylineColorAppearance.js';\nimport PolylineMaterialAppearance from '../Scene/PolylineMaterialAppearance.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport ConstantProperty from './ConstantProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var defaultZIndex = new ConstantProperty(0);\n\n    //We use this object to create one polyline collection per-scene.\n    var polylineCollections = {};\n\n    var scratchColor = new Color();\n    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);\n    var defaultShow = new ConstantProperty(true);\n    var defaultShadows = new ConstantProperty(ShadowMode.DISABLED);\n    var defaultDistanceDisplayCondition = new ConstantProperty(new DistanceDisplayCondition());\n    var defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);\n\n    function GeometryOptions() {\n        this.vertexFormat = undefined;\n        this.positions = undefined;\n        this.width = undefined;\n        this.arcType = undefined;\n        this.granularity = undefined;\n    }\n\n    function GroundGeometryOptions() {\n        this.positions = undefined;\n        this.width = undefined;\n        this.arcType = undefined;\n        this.granularity = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for polylines.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PolylineGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PolylineGeometryUpdater(entity, scene) {\n        \n\n        this._entity = entity;\n        this._scene = scene;\n        this._entitySubscription = entity.definitionChanged.addEventListener(PolylineGeometryUpdater.prototype._onEntityPropertyChanged, this);\n        this._fillEnabled = false;\n        this._dynamic = false;\n        this._geometryChanged = new Event();\n        this._showProperty = undefined;\n        this._materialProperty = undefined;\n        this._shadowsProperty = undefined;\n        this._distanceDisplayConditionProperty = undefined;\n        this._classificationTypeProperty = undefined;\n        this._depthFailMaterialProperty = undefined;\n        this._geometryOptions = new GeometryOptions();\n        this._groundGeometryOptions = new GroundGeometryOptions();\n        this._id = 'polyline-' + entity.id;\n        this._clampToGround = false;\n        this._supportsPolylinesOnTerrain = Entity.supportsPolylinesOnTerrain(scene);\n\n        this._zIndex = 0;\n\n        this._onEntityPropertyChanged(entity, 'polyline', entity.polyline, undefined);\n    }\n\n    defineProperties(PolylineGeometryUpdater.prototype, {\n        /**\n         * Gets the unique ID associated with this updater\n         * @memberof PolylineGeometryUpdater.prototype\n         * @type {String}\n         * @readonly\n         */\n        id: {\n            get: function() {\n                return this._id;\n            }\n        },\n        /**\n         * Gets the entity associated with this geometry.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Entity}\n         * @readonly\n         */\n        entity : {\n            get : function() {\n                return this._entity;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has a fill component.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        fillEnabled : {\n            get : function() {\n                return this._fillEnabled;\n            }\n        },\n        /**\n         * Gets a value indicating if fill visibility varies with simulation time.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantFill : {\n            get : function() {\n                return !this._fillEnabled || (!defined(this._entity.availability) && Property.isConstant(this._showProperty));\n            }\n        },\n        /**\n         * Gets the material property used to fill the geometry.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {MaterialProperty}\n         * @readonly\n         */\n        fillMaterialProperty : {\n            get : function() {\n                return this._materialProperty;\n            }\n        },\n        /**\n         * Gets the material property used to fill the geometry when it fails the depth test.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {MaterialProperty}\n         * @readonly\n         */\n        depthFailMaterialProperty : {\n            get : function() {\n                return this._depthFailMaterialProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has an outline component.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        outlineEnabled : {\n            value : false\n        },\n        /**\n         * Gets a value indicating if outline visibility varies with simulation time.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantOutline : {\n            value : true\n        },\n        /**\n         * Gets the {@link Color} property for the geometry outline.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        outlineColorProperty : {\n            value : undefined\n        },\n        /**\n         * Gets the property specifying whether the geometry\n         * casts or receives shadows from each light source.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        shadowsProperty : {\n            get : function() {\n                return this._shadowsProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        distanceDisplayConditionProperty : {\n            get : function() {\n                return this._distanceDisplayConditionProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        classificationTypeProperty : {\n            get : function() {\n                return this._classificationTypeProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is time-varying.\n         * If true, all visualization is delegated to the {@link DynamicGeometryUpdater}\n         * returned by GeometryUpdater#createDynamicUpdater.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isDynamic : {\n            get : function() {\n                return this._dynamic;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is closed.\n         * This property is only valid for static geometry.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isClosed : {\n            value : false\n        },\n        /**\n         * Gets an event that is raised whenever the public properties\n         * of this updater change.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        geometryChanged : {\n            get : function() {\n                return this._geometryChanged;\n            }\n        },\n\n        /**\n         * Gets a value indicating if the path of the line.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {ArcType}\n         * @readonly\n         */\n        arcType : {\n            get : function() {\n                return this._arcType;\n            }\n        },\n\n        /**\n         * Gets a value indicating if the geometry is clamped to the ground.\n         * Returns false if polylines on terrain is not supported.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        clampToGround : {\n            get : function() {\n                return this._clampToGround && this._supportsPolylinesOnTerrain;\n            }\n        },\n\n        /**\n         * Gets the zindex\n         * @type {Number}\n         * @memberof PolylineGeometryUpdater.prototype\n         * @readonly\n         */\n        zIndex: {\n            get: function() {\n                return this._zIndex;\n            }\n        }\n    });\n\n    /**\n     * Checks if the geometry is outlined at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.\n     */\n    PolylineGeometryUpdater.prototype.isOutlineVisible = function(time) {\n        return false;\n    };\n\n    /**\n     * Checks if the geometry is filled at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.\n     */\n    PolylineGeometryUpdater.prototype.isFilled = function(time) {\n        var entity = this._entity;\n        var visible = this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time);\n        return defaultValue(visible, false);\n    };\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PolylineGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute\n        };\n\n        var currentColor;\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (this.clampToGround) {\n            return new GeometryInstance({\n                id : entity,\n                geometry : new GroundPolylineGeometry(this._groundGeometryOptions),\n                attributes : attributes\n            });\n        }\n\n        if (defined(this._depthFailMaterialProperty) && this._depthFailMaterialProperty instanceof ColorMaterialProperty) {\n            if (defined(this._depthFailMaterialProperty.color) && (this._depthFailMaterialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._depthFailMaterialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.depthFailColor = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PolylineGeometry(this._geometryOptions),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PolylineGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PolylineGeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    PolylineGeometryUpdater.prototype.destroy = function() {\n        this._entitySubscription();\n        destroyObject(this);\n    };\n\n    PolylineGeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        if (!(propertyName === 'availability' || propertyName === 'polyline')) {\n            return;\n        }\n\n        var polyline = this._entity.polyline;\n\n        if (!defined(polyline)) {\n            if (this._fillEnabled) {\n                this._fillEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var positionsProperty = polyline.positions;\n\n        var show = polyline.show;\n        if ((defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE)) || //\n            (!defined(positionsProperty))) {\n            if (this._fillEnabled) {\n                this._fillEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var zIndex = polyline.zIndex;\n        var material = defaultValue(polyline.material, defaultMaterial);\n        var isColorMaterial = material instanceof ColorMaterialProperty;\n        this._materialProperty = material;\n        this._depthFailMaterialProperty = polyline.depthFailMaterial;\n        this._showProperty = defaultValue(show, defaultShow);\n        this._shadowsProperty = defaultValue(polyline.shadows, defaultShadows);\n        this._distanceDisplayConditionProperty = defaultValue(polyline.distanceDisplayCondition, defaultDistanceDisplayCondition);\n        this._classificationTypeProperty = defaultValue(polyline.classificationType, defaultClassificationType);\n        this._fillEnabled = true;\n        this._zIndex = defaultValue(zIndex, defaultZIndex);\n\n        var width = polyline.width;\n        var arcType = polyline.arcType;\n        var clampToGround = polyline.clampToGround;\n        var granularity = polyline.granularity;\n\n        if (!positionsProperty.isConstant || !Property.isConstant(width) ||\n            !Property.isConstant(arcType) || !Property.isConstant(granularity) ||\n            !Property.isConstant(clampToGround) || !Property.isConstant(zIndex)) {\n            if (!this._dynamic) {\n                this._dynamic = true;\n                this._geometryChanged.raiseEvent(this);\n            }\n        } else {\n            var geometryOptions = this._geometryOptions;\n            var positions = positionsProperty.getValue(Iso8601.MINIMUM_VALUE, geometryOptions.positions);\n\n            //Because of the way we currently handle reference properties,\n            //we can't automatically assume the positions are always valid.\n            if (!defined(positions) || positions.length < 2) {\n                if (this._fillEnabled) {\n                    this._fillEnabled = false;\n                    this._geometryChanged.raiseEvent(this);\n                }\n                return;\n            }\n\n            var vertexFormat;\n            if (isColorMaterial && (!defined(this._depthFailMaterialProperty) || this._depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n                vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;\n            } else {\n                vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;\n            }\n\n            geometryOptions.vertexFormat = vertexFormat;\n            geometryOptions.positions = positions;\n            geometryOptions.width = defined(width) ? width.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n            geometryOptions.arcType = defined(arcType) ? arcType.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n            geometryOptions.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n\n            var groundGeometryOptions = this._groundGeometryOptions;\n            groundGeometryOptions.positions = positions;\n            groundGeometryOptions.width = geometryOptions.width;\n            groundGeometryOptions.arcType = geometryOptions.arcType;\n            groundGeometryOptions.granularity = geometryOptions.granularity;\n\n            this._clampToGround = defined(clampToGround) ? clampToGround.getValue(Iso8601.MINIMUM_VALUE) : false;\n\n            if (!this._clampToGround && defined(zIndex)) {\n                oneTimeWarning('Entity polylines must have clampToGround: true when using zIndex.  zIndex will be ignored.');\n            }\n\n            this._dynamic = false;\n            this._geometryChanged.raiseEvent(this);\n        }\n    };\n\n    /**\n     * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.\n     *\n     * @param {PrimitiveCollection} primitives The primitive collection to use.\n     * @param {PrimitiveCollection|OrderedGroundPrimitiveCollection} groundPrimitives The primitive collection to use for ordered ground primitives.\n     * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.\n     *\n     * @exception {DeveloperError} This instance does not represent dynamic geometry.\n     */\n    PolylineGeometryUpdater.prototype.createDynamicUpdater = function(primitives, groundPrimitives) {\n        \n\n        return new DynamicGeometryUpdater(primitives, groundPrimitives, this);\n    };\n\n    /**\n     * @private\n     */\n    var generateCartesianArcOptions = {\n        positions : undefined,\n        granularity : undefined,\n        height : undefined,\n        ellipsoid : undefined\n    };\n\n    function DynamicGeometryUpdater(primitives, groundPrimitives, geometryUpdater) {\n        this._line = undefined;\n        this._primitives = primitives;\n        this._groundPrimitives = groundPrimitives;\n        this._groundPolylinePrimitive = undefined;\n        this._material = undefined;\n        this._geometryUpdater = geometryUpdater;\n        this._positions = [];\n    }\n\n    function getLine(dynamicGeometryUpdater) {\n        if (defined(dynamicGeometryUpdater._line)) {\n            return dynamicGeometryUpdater._line;\n        }\n\n        var sceneId = dynamicGeometryUpdater._geometryUpdater._scene.id;\n        var polylineCollection = polylineCollections[sceneId];\n        var primitives = dynamicGeometryUpdater._primitives;\n        if (!defined(polylineCollection) || polylineCollection.isDestroyed()) {\n            polylineCollection = new PolylineCollection();\n            polylineCollections[sceneId] = polylineCollection;\n            primitives.add(polylineCollection);\n        } else if (!primitives.contains(polylineCollection)) {\n            primitives.add(polylineCollection);\n        }\n\n        var line = polylineCollection.add();\n        line.id = dynamicGeometryUpdater._geometryUpdater._entity;\n        dynamicGeometryUpdater._line = line;\n        return line;\n    }\n\n    DynamicGeometryUpdater.prototype.update = function(time) {\n        var geometryUpdater = this._geometryUpdater;\n        var entity = geometryUpdater._entity;\n        var polyline = entity.polyline;\n\n        var positionsProperty = polyline.positions;\n        var positions = Property.getValueOrUndefined(positionsProperty, time, this._positions);\n\n        // Synchronize with geometryUpdater for GroundPolylinePrimitive\n        geometryUpdater._clampToGround = Property.getValueOrDefault(polyline._clampToGround, time, false);\n        geometryUpdater._groundGeometryOptions.positions = positions;\n        geometryUpdater._groundGeometryOptions.width = Property.getValueOrDefault(polyline._width, time, 1);\n        geometryUpdater._groundGeometryOptions.arcType = Property.getValueOrDefault(polyline._arcType, time, ArcType.GEODESIC);\n        geometryUpdater._groundGeometryOptions.granularity = Property.getValueOrDefault(polyline._granularity, time, 9999);\n\n        var groundPrimitives = this._groundPrimitives;\n\n        if (defined(this._groundPolylinePrimitive)) {\n            groundPrimitives.remove(this._groundPolylinePrimitive); // destroys by default\n            this._groundPolylinePrimitive = undefined;\n        }\n\n        if (geometryUpdater.clampToGround) {\n            if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {\n                return;\n            }\n\n            if (!defined(positions) || positions.length < 2) {\n                return;\n            }\n\n            var fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n            var appearance;\n            if (fillMaterialProperty instanceof ColorMaterialProperty) {\n                appearance = new PolylineColorAppearance();\n            } else {\n                var material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);\n                appearance = new PolylineMaterialAppearance({\n                    material : material,\n                    translucent : material.isTranslucent()\n                });\n                this._material = material;\n            }\n\n            this._groundPolylinePrimitive = groundPrimitives.add(new GroundPolylinePrimitive({\n                geometryInstances : geometryUpdater.createFillGeometryInstance(time),\n                appearance : appearance,\n                classificationType : geometryUpdater.classificationTypeProperty.getValue(time),\n                asynchronous : false\n            }), Property.getValueOrUndefined(geometryUpdater.zIndex, time));\n\n            // Hide the polyline in the collection, if any\n            if (defined(this._line)) {\n                this._line.show = false;\n            }\n            return;\n        }\n\n        var line = getLine(this);\n\n        if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {\n            line.show = false;\n            return;\n        }\n\n        if (!defined(positions) || positions.length < 2) {\n            line.show = false;\n            return;\n        }\n\n        var arcType = ArcType.GEODESIC;\n        arcType = Property.getValueOrDefault(polyline._arcType, time, arcType);\n\n        var globe = geometryUpdater._scene.globe;\n        if (arcType !== ArcType.NONE && defined(globe)) {\n            generateCartesianArcOptions.ellipsoid = globe.ellipsoid;\n            generateCartesianArcOptions.positions = positions;\n            generateCartesianArcOptions.granularity = Property.getValueOrUndefined(polyline._granularity, time);\n            generateCartesianArcOptions.height = PolylinePipeline.extractHeights(positions, globe.ellipsoid);\n            if (arcType === ArcType.GEODESIC) {\n                positions = PolylinePipeline.generateCartesianArc(generateCartesianArcOptions);\n            } else {\n                positions = PolylinePipeline.generateCartesianRhumbArc(generateCartesianArcOptions);\n            }\n        }\n\n        line.show = true;\n        line.positions = positions.slice();\n        line.material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, line.material);\n        line.width = Property.getValueOrDefault(polyline._width, time, 1);\n        line.distanceDisplayCondition = Property.getValueOrUndefined(polyline._distanceDisplayCondition, time, line.distanceDisplayCondition);\n    };\n\n    DynamicGeometryUpdater.prototype.getBoundingSphere = function(result) {\n        \n\n        if (!this._geometryUpdater.clampToGround) {\n            var line = getLine(this);\n            if (line.show && line.positions.length > 0) {\n                BoundingSphere.fromPoints(line.positions, result);\n                return BoundingSphereState.DONE;\n            }\n        } else {\n            var groundPolylinePrimitive = this._groundPolylinePrimitive;\n            if (defined(groundPolylinePrimitive) && groundPolylinePrimitive.show && groundPolylinePrimitive.ready) {\n                var attributes = groundPolylinePrimitive.getGeometryInstanceAttributes(this._geometryUpdater._entity);\n                if (defined(attributes) && defined(attributes.boundingSphere)) {\n                    BoundingSphere.clone(attributes.boundingSphere, result);\n                    return BoundingSphereState.DONE;\n                }\n            }\n\n            if ((defined(groundPolylinePrimitive) && !groundPolylinePrimitive.ready)) {\n                return BoundingSphereState.PENDING;\n            }\n\n            return BoundingSphereState.DONE;\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    DynamicGeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    DynamicGeometryUpdater.prototype.destroy = function() {\n        var geometryUpdater = this._geometryUpdater;\n        var sceneId = geometryUpdater._scene.id;\n        var polylineCollection = polylineCollections[sceneId];\n        if (defined(polylineCollection)) {\n            polylineCollection.remove(this._line);\n            if (polylineCollection.length === 0) {\n                this._primitives.removeAndDestroy(polylineCollection);\n                delete polylineCollections[sceneId];\n            }\n        }\n        if (defined(this._groundPolylinePrimitive)) {\n            this._groundPrimitives.remove(this._groundPolylinePrimitive);\n        }\n        destroyObject(this);\n    };\nexport default PolylineGeometryUpdater;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport GroundPolylinePrimitive from '../Scene/GroundPolylinePrimitive.js';\nimport PolylineColorAppearance from '../Scene/PolylineColorAppearance.js';\nimport PolylineMaterialAppearance from '../Scene/PolylineMaterialAppearance.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n    // Encapsulates a Primitive and all the entities that it represents.\n    function Batch(orderedGroundPrimitives, classificationType, materialProperty, zIndex, asynchronous) {\n        var appearanceType;\n        if (materialProperty instanceof ColorMaterialProperty) {\n            appearanceType = PolylineColorAppearance;\n        } else {\n            appearanceType = PolylineMaterialAppearance;\n        }\n\n        this.orderedGroundPrimitives = orderedGroundPrimitives; // scene level primitive collection\n        this.classificationType = classificationType;\n        this.appearanceType = appearanceType;\n        this.materialProperty = materialProperty;\n        this.updaters = new AssociativeArray();\n        this.createPrimitive = true;\n        this.primitive = undefined; // a GroundPolylinePrimitive encapsulating all the entities\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.material = undefined;\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.invalidated = false;\n        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.zIndex = zIndex;\n\n        this._asynchronous = asynchronous;\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    // Check if the given updater's material is compatible with this batch\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.materialProperty;\n        var updaterMaterial = updater.fillMaterialProperty;\n\n        if (updaterMaterial === material ||\n            (updaterMaterial instanceof ColorMaterialProperty && material instanceof ColorMaterialProperty)) {\n            return true;\n        }\n        return defined(material) && material.equals(updaterMaterial);\n    };\n\n    Batch.prototype.add = function(time, updater, geometryInstance) {\n        var id = updater.id;\n        this.updaters.set(id, updater);\n        this.geometry.set(id, geometryInstance);\n        // Updaters with dynamic attributes must be tracked separately, may exit the batch\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            // Listen for show changes. These will be synchronized in updateShows.\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n        this.createPrimitive = true;\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var primitive = this.primitive;\n        var orderedGroundPrimitives = this.orderedGroundPrimitives;\n        var geometries = this.geometry.values;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        // For if the new primitive changes again before it is ready.\n                        orderedGroundPrimitives.remove(primitive);\n                    }\n                }\n\n                primitive = new GroundPolylinePrimitive({\n                    show : false,\n                    asynchronous : this._asynchronous,\n                    geometryInstances : geometries,\n                    appearance : new this.appearanceType(),\n                    classificationType : this.classificationType\n                });\n\n                if (this.appearanceType === PolylineMaterialAppearance) {\n                    this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n                    primitive.appearance.material = this.material;\n                }\n\n                orderedGroundPrimitives.add(primitive, this.zIndex);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    orderedGroundPrimitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    orderedGroundPrimitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                orderedGroundPrimitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            if (this.appearanceType === PolylineMaterialAppearance) {\n                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n                this.primitive.appearance.material = this.material;\n            }\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var entity = updater.entity;\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.fillMaterialProperty.isConstant) {\n                    var colorProperty = updater.fillMaterialProperty.color;\n                    var resultColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, scratchColor);\n                    if (!Color.equals(attributes._lastColor, resultColor)) {\n                        attributes._lastColor = Color.clone(resultColor, attributes._lastColor);\n                        attributes.color = ColorGeometryInstanceAttribute.toValue(resultColor, attributes.color);\n                    }\n                }\n\n                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var entity = updater.entity;\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var orderedGroundPrimitives = this.orderedGroundPrimitives;\n        if (defined(primitive)) {\n            orderedGroundPrimitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            orderedGroundPrimitives.remove(oldPrimitive);\n        }\n        this.removeMaterialSubscription();\n    };\n\n    /**\n     * @private\n     */\n    function StaticGroundPolylinePerMaterialBatch(orderedGroundPrimitives, classificationType, asynchronous) {\n        this._items = [];\n        this._orderedGroundPrimitives = orderedGroundPrimitives;\n        this._classificationType = classificationType;\n        this._asynchronous = defaultValue(asynchronous, true);\n    }\n\n    StaticGroundPolylinePerMaterialBatch.prototype.add = function(time, updater) {\n        var items = this._items;\n        var length = items.length;\n        var geometryInstance = updater.createFillGeometryInstance(time);\n        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n        // Check if the Entity represented by the updater has the same material or a material representable with per-instance color.\n        for (var i = 0; i < length; ++i) {\n            var item = items[i];\n            if (item.isMaterial(updater) &&\n                item.zIndex === zIndex) {\n                item.add(time, updater, geometryInstance);\n                return;\n            }\n        }\n        // If a compatible batch wasn't found, create a new batch.\n        var batch = new Batch(this._orderedGroundPrimitives, this._classificationType, updater.fillMaterialProperty, zIndex, this._asynchronous);\n        batch.add(time, updater, geometryInstance);\n        items.push(batch);\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.remove = function(updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                break;\n            }\n        }\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.update = function(time) {\n        var i;\n        var items = this._items;\n        var length = items.length;\n\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    this.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        var isUpdated = true;\n        for (i = 0; i < items.length; i++) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.removeAllPrimitives = function() {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        this._items.length = 0;\n    };\nexport default StaticGroundPolylinePerMaterialBatch;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport ClassificationType from '../Scene/ClassificationType.js';\nimport PolylineColorAppearance from '../Scene/PolylineColorAppearance.js';\nimport PolylineMaterialAppearance from '../Scene/PolylineMaterialAppearance.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryBatch from './DynamicGeometryBatch.js';\nimport PolylineGeometryUpdater from './PolylineGeometryUpdater.js';\nimport StaticGeometryColorBatch from './StaticGeometryColorBatch.js';\nimport StaticGeometryPerMaterialBatch from './StaticGeometryPerMaterialBatch.js';\nimport StaticGroundPolylinePerMaterialBatch from './StaticGroundPolylinePerMaterialBatch.js';\n\n    var emptyArray = [];\n\n    function removeUpdater(that, updater) {\n        //We don't keep track of which batch an updater is in, so just remove it from all of them.\n        var batches = that._batches;\n        var length = batches.length;\n        for (var i = 0; i < length; i++) {\n            batches[i].remove(updater);\n        }\n    }\n\n    function insertUpdaterIntoBatch(that, time, updater) {\n        if (updater.isDynamic) {\n            that._dynamicBatch.add(time, updater);\n            return;\n        }\n\n        if (updater.clampToGround && updater.fillEnabled) { // Also checks for support\n            var classificationType = updater.classificationTypeProperty.getValue(time);\n            that._groundBatches[classificationType].add(time, updater);\n            return;\n        }\n\n        var shadows;\n        if (updater.fillEnabled) {\n            shadows = updater.shadowsProperty.getValue(time);\n        }\n\n        var multiplier = 0;\n        if (defined(updater.depthFailMaterialProperty)) {\n            multiplier = updater.depthFailMaterialProperty instanceof ColorMaterialProperty ? 1 : 2;\n        }\n\n        var index;\n        if (defined(shadows)) {\n            index = shadows + multiplier * ShadowMode.NUMBER_OF_SHADOW_MODES;\n        }\n\n        if (updater.fillEnabled) {\n            if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                that._colorBatches[index].add(time, updater);\n            } else {\n                that._materialBatches[index].add(time, updater);\n            }\n        }\n    }\n\n    /**\n     * A visualizer for polylines represented by {@link Primitive} instances.\n     * @alias PolylineVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n     * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n     */\n    function PolylineVisualizer(scene, entityCollection, primitives, groundPrimitives) {\n        \n\n        groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);\n        primitives = defaultValue(primitives, scene.primitives);\n\n        this._scene = scene;\n        this._primitives = primitives;\n        this._entityCollection = undefined;\n        this._addedObjects = new AssociativeArray();\n        this._removedObjects = new AssociativeArray();\n        this._changedObjects = new AssociativeArray();\n\n        var i;\n        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n        this._colorBatches = new Array(numberOfShadowModes * 3);\n        this._materialBatches = new Array(numberOfShadowModes * 3);\n\n        for (i = 0; i < numberOfShadowModes; ++i) {\n            this._colorBatches[i] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, undefined, false, i); // no depth fail appearance\n            this._materialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, undefined, false, i);\n\n            this._colorBatches[i + numberOfShadowModes] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineColorAppearance, false, i); //depth fail appearance variations\n            this._materialBatches[i + numberOfShadowModes] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineColorAppearance, false, i);\n\n            this._colorBatches[i + numberOfShadowModes * 2] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineMaterialAppearance, false, i);\n            this._materialBatches[i + numberOfShadowModes * 2] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineMaterialAppearance, false, i);\n        }\n\n        this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n\n        var numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n        this._groundBatches = new Array(numberOfClassificationTypes);\n\n        for (i = 0; i < numberOfClassificationTypes; ++i) {\n            this._groundBatches[i] = new StaticGroundPolylinePerMaterialBatch(groundPrimitives, i);\n        }\n\n        this._batches = this._colorBatches.concat(this._materialBatches, this._dynamicBatch, this._groundBatches);\n\n        this._subscriptions = new AssociativeArray();\n        this._updaters = new AssociativeArray();\n\n        this._entityCollection = entityCollection;\n        entityCollection.collectionChanged.addEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);\n        this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);\n    }\n\n    /**\n     * Updates all of the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} True if the visualizer successfully updated to the provided time,\n     * false if the visualizer is waiting for asynchronous primitives to be created.\n     */\n    PolylineVisualizer.prototype.update = function(time) {\n        \n\n        var addedObjects = this._addedObjects;\n        var added = addedObjects.values;\n        var removedObjects = this._removedObjects;\n        var removed = removedObjects.values;\n        var changedObjects = this._changedObjects;\n        var changed = changedObjects.values;\n\n        var i;\n        var entity;\n        var id;\n        var updater;\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            id = entity.id;\n            updater = this._updaters.get(id);\n\n            //If in a single update, an entity gets removed and a new instance\n            //re-added with the same id, the updater no longer tracks the\n            //correct entity, we need to both remove the old one and\n            //add the new one, which is done by pushing the entity\n            //onto the removed/added lists.\n            if (updater.entity === entity) {\n                removeUpdater(this, updater);\n                insertUpdaterIntoBatch(this, time, updater);\n            } else {\n                removed.push(entity);\n                added.push(entity);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            updater = this._updaters.get(id);\n            removeUpdater(this, updater);\n            updater.destroy();\n            this._updaters.remove(id);\n            this._subscriptions.get(id)();\n            this._subscriptions.remove(id);\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            updater = new PolylineGeometryUpdater(entity, this._scene);\n            this._updaters.set(id, updater);\n            insertUpdaterIntoBatch(this, time, updater);\n            this._subscriptions.set(id, updater.geometryChanged.addEventListener(PolylineVisualizer._onGeometryChanged, this));\n        }\n\n        addedObjects.removeAll();\n        removedObjects.removeAll();\n        changedObjects.removeAll();\n\n        var isUpdated = true;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            isUpdated = batches[i].update(time) && isUpdated;\n        }\n\n        return isUpdated;\n    };\n\n    var getBoundingSphereArrayScratch = [];\n    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    PolylineVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var boundingSpheres = getBoundingSphereArrayScratch;\n        var tmp = getBoundingSphereBoundingSphereScratch;\n\n        var count = 0;\n        var state = BoundingSphereState.DONE;\n        var batches = this._batches;\n        var batchesLength = batches.length;\n        var updater = this._updaters.get(entity.id);\n        for (var i = 0; i < batchesLength; i++) {\n            state = batches[i].getBoundingSphere(updater, tmp);\n            if (state === BoundingSphereState.PENDING) {\n                return BoundingSphereState.PENDING;\n            } else if (state === BoundingSphereState.DONE) {\n                boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n                count++;\n            }\n        }\n\n        if (count === 0) {\n            return BoundingSphereState.FAILED;\n        }\n\n        boundingSpheres.length = count;\n        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PolylineVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    PolylineVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);\n        this._addedObjects.removeAll();\n        this._removedObjects.removeAll();\n\n        var i;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            batches[i].removeAllPrimitives();\n        }\n\n        var subscriptions = this._subscriptions.values;\n        length = subscriptions.length;\n        for (i = 0; i < length; i++) {\n            subscriptions[i]();\n        }\n        this._subscriptions.removeAll();\n        return destroyObject(this);\n    };\n\n    /**\n     * @private\n     */\n    PolylineVisualizer._onGeometryChanged = function(updater) {\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var entity = updater.entity;\n        var id = entity.id;\n\n        if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n            changedObjects.set(id, entity);\n        }\n    };\n\n    /**\n     * @private\n     */\n    PolylineVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed) {\n        var addedObjects = this._addedObjects;\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var i;\n        var id;\n        var entity;\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            if (!addedObjects.remove(id)) {\n                removedObjects.set(id, entity);\n                changedObjects.remove(id);\n            }\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            if (removedObjects.remove(id)) {\n                changedObjects.set(id, entity);\n            } else {\n                addedObjects.set(id, entity);\n            }\n        }\n    };\nexport default PolylineVisualizer;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport createGuid from '../Core/createGuid.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport EventHelper from '../Core/EventHelper.js';\nimport GroundPolylinePrimitive from '../Scene/GroundPolylinePrimitive.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport OrderedGroundPrimitiveCollection from '../Scene/OrderedGroundPrimitiveCollection.js';\nimport PrimitiveCollection from '../Scene/PrimitiveCollection.js';\nimport BillboardVisualizer from './BillboardVisualizer.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport CustomDataSource from './CustomDataSource.js';\nimport GeometryVisualizer from './GeometryVisualizer.js';\nimport LabelVisualizer from './LabelVisualizer.js';\nimport ModelVisualizer from './ModelVisualizer.js';\nimport PathVisualizer from './PathVisualizer.js';\nimport PointVisualizer from './PointVisualizer.js';\nimport PolylineVisualizer from './PolylineVisualizer.js';\n\n    /**\n     * Visualizes a collection of {@link DataSource} instances.\n     * @alias DataSourceDisplay\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Scene} options.scene The scene in which to display the data.\n     * @param {DataSourceCollection} options.dataSourceCollection The data sources to display.\n     * @param {DataSourceDisplay~VisualizersCallback} [options.visualizersCallback=DataSourceDisplay.defaultVisualizersCallback]\n     *        A function which creates an array of visualizers used for visualization.\n     *        If undefined, all standard visualizers are used.\n     */\n    function DataSourceDisplay(options) {\n        \n\n        this._displayID = createGuid();\n\n        GroundPrimitive.initializeTerrainHeights();\n        GroundPolylinePrimitive.initializeTerrainHeights();\n\n        var scene = options.scene;\n        var dataSourceCollection = options.dataSourceCollection;\n\n        this._eventHelper = new EventHelper();\n        this._eventHelper.add(dataSourceCollection.dataSourceAdded, this._onDataSourceAdded, this);\n        this._eventHelper.add(dataSourceCollection.dataSourceRemoved, this._onDataSourceRemoved, this);\n        this._eventHelper.add(dataSourceCollection.dataSourceMoved, this._onDataSourceMoved, this);\n        this._eventHelper.add(scene.postRender, this._postRender, this);\n\n        this._dataSourceCollection = dataSourceCollection;\n        this._scene = scene;\n        this._visualizersCallback = defaultValue(options.visualizersCallback, DataSourceDisplay.defaultVisualizersCallback);\n\n        var primitivesAdded = false;\n        var primitives = new PrimitiveCollection();\n        var groundPrimitives = new PrimitiveCollection();\n\n        if (dataSourceCollection.length > 0) {\n            scene.primitives.add(primitives);\n            scene.groundPrimitives.add(groundPrimitives);\n            primitivesAdded = true;\n        }\n\n        this._primitives = primitives;\n        this._groundPrimitives = groundPrimitives;\n\n        for (var i = 0, len = dataSourceCollection.length; i < len; i++) {\n            this._onDataSourceAdded(dataSourceCollection, dataSourceCollection.get(i));\n        }\n\n        var defaultDataSource = new CustomDataSource();\n        this._onDataSourceAdded(undefined, defaultDataSource);\n        this._defaultDataSource = defaultDataSource;\n\n        var removeDefaultDataSourceListener;\n        var removeDataSourceCollectionListener;\n        if (!primitivesAdded) {\n            var that = this;\n            var addPrimitives = function() {\n                scene.primitives.add(primitives);\n                scene.groundPrimitives.add(groundPrimitives);\n                removeDefaultDataSourceListener();\n                removeDataSourceCollectionListener();\n                that._removeDefaultDataSourceListener = undefined;\n                that._removeDataSourceCollectionListener = undefined;\n            };\n            removeDefaultDataSourceListener = defaultDataSource.entities.collectionChanged.addEventListener(addPrimitives);\n            removeDataSourceCollectionListener = dataSourceCollection.dataSourceAdded.addEventListener(addPrimitives);\n        }\n\n        this._removeDefaultDataSourceListener = removeDefaultDataSourceListener;\n        this._removeDataSourceCollectionListener = removeDataSourceCollectionListener;\n\n        this._ready = false;\n    }\n\n    /**\n     * Gets or sets the default function which creates an array of visualizers used for visualization.\n     * By default, this function uses all standard visualizers.\n     *\n     * @type {DataSourceDisplay~VisualizersCallback}\n     */\n    DataSourceDisplay.defaultVisualizersCallback = function(scene, entityCluster, dataSource) {\n        var entities = dataSource.entities;\n        return [new BillboardVisualizer(entityCluster, entities),\n                new GeometryVisualizer(scene, entities, dataSource._primitives, dataSource._groundPrimitives),\n                new LabelVisualizer(entityCluster, entities),\n                new ModelVisualizer(scene, entities),\n                new PointVisualizer(entityCluster, entities),\n                new PathVisualizer(scene, entities),\n                new PolylineVisualizer(scene, entities, dataSource._primitives, dataSource._groundPrimitives)];\n    };\n\n    defineProperties(DataSourceDisplay.prototype, {\n        /**\n         * Gets the scene associated with this display.\n         * @memberof DataSourceDisplay.prototype\n         * @type {Scene}\n         */\n        scene : {\n            get : function() {\n                return this._scene;\n            }\n        },\n        /**\n         * Gets the collection of data sources to display.\n         * @memberof DataSourceDisplay.prototype\n         * @type {DataSourceCollection}\n         */\n        dataSources : {\n            get : function() {\n                return this._dataSourceCollection;\n            }\n        },\n        /**\n         * Gets the default data source instance which can be used to\n         * manually create and visualize entities not tied to\n         * a specific data source. This instance is always available\n         * and does not appear in the list dataSources collection.\n         * @memberof DataSourceDisplay.prototype\n         * @type {CustomDataSource}\n         */\n        defaultDataSource : {\n            get : function() {\n                return this._defaultDataSource;\n            }\n        },\n\n        /**\n         * Gets a value indicating whether or not all entities in the data source are ready\n         * @memberof DataSourceDisplay.prototype\n         * @type {Boolean}\n         * @readonly\n         */\n        ready : {\n            get : function() {\n                return this._ready;\n            }\n        }\n    });\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * <br /><br />\n     * If this object was destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     *\n     * @see DataSourceDisplay#destroy\n     */\n    DataSourceDisplay.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n     * <br /><br />\n     * Once an object is destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n     * assign the return value (<code>undefined</code>) to the object as done in the example.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * dataSourceDisplay = dataSourceDisplay.destroy();\n     *\n     * @see DataSourceDisplay#isDestroyed\n     */\n    DataSourceDisplay.prototype.destroy = function() {\n        this._eventHelper.removeAll();\n\n        var dataSourceCollection = this._dataSourceCollection;\n        for (var i = 0, length = dataSourceCollection.length; i < length; ++i) {\n            this._onDataSourceRemoved(this._dataSourceCollection, dataSourceCollection.get(i));\n        }\n        this._onDataSourceRemoved(undefined, this._defaultDataSource);\n\n        if (defined(this._removeDefaultDataSourceListener)) {\n            this._removeDefaultDataSourceListener();\n            this._removeDataSourceCollectionListener();\n        } else {\n            this._scene.primitives.remove(this._primitives);\n            this._scene.groundPrimitives.remove(this._groundPrimitives);\n        }\n\n        return destroyObject(this);\n    };\n\n    /**\n     * Updates the display to the provided time.\n     *\n     * @param {JulianDate} time The simulation time.\n     * @returns {Boolean} True if all data sources are ready to be displayed, false otherwise.\n     */\n    DataSourceDisplay.prototype.update = function(time) {\n        \n\n        if (!ApproximateTerrainHeights.initialized) {\n            this._ready = false;\n            return false;\n        }\n\n        var result = true;\n\n        var i;\n        var x;\n        var visualizers;\n        var vLength;\n        var dataSources = this._dataSourceCollection;\n        var length = dataSources.length;\n        for (i = 0; i < length; i++) {\n            var dataSource = dataSources.get(i);\n            if (defined(dataSource.update)) {\n                result = dataSource.update(time) && result;\n            }\n\n            visualizers = dataSource._visualizersByDisplayID[this._displayID];\n            vLength = visualizers.length;\n            for (x = 0; x < vLength; x++) {\n                result = visualizers[x].update(time) && result;\n            }\n        }\n\n        visualizers = this._defaultDataSource._visualizersByDisplayID[this._displayID];\n        vLength = visualizers.length;\n        for (x = 0; x < vLength; x++) {\n            result = visualizers[x].update(time) && result;\n        }\n\n        this._ready = result;\n\n        return result;\n    };\n\n    DataSourceDisplay.prototype._postRender = function() {\n        // Adds credits for all datasources\n        var frameState = this._scene.frameState;\n        var dataSources = this._dataSourceCollection;\n        var length = dataSources.length;\n        for (var i = 0; i < length; i++) {\n            var dataSource = dataSources.get(i);\n\n            var credit = dataSource.credit;\n            if (defined(credit)) {\n                frameState.creditDisplay.addCredit(credit);\n            }\n\n            // Credits from the resource that the user can't remove\n            var credits = dataSource._resourceCredits;\n            if (defined(credits)) {\n                var creditCount = credits.length;\n                for (var c = 0; c < creditCount; c++) {\n                    frameState.creditDisplay.addCredit(credits[c]);\n                }\n            }\n        }\n    };\n\n    var getBoundingSphereArrayScratch = [];\n    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {Boolean} allowPartial If true, pending bounding spheres are ignored and an answer will be returned from the currently available data.\n     *                               If false, the the function will halt and return pending if any of the bounding spheres are pending.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    DataSourceDisplay.prototype.getBoundingSphere = function(entity, allowPartial, result) {\n        \n\n        if (!this._ready) {\n            return BoundingSphereState.PENDING;\n        }\n\n        var i;\n        var length;\n        var dataSource = this._defaultDataSource;\n        if (!dataSource.entities.contains(entity)) {\n            dataSource = undefined;\n\n            var dataSources = this._dataSourceCollection;\n            length = dataSources.length;\n            for (i = 0; i < length; i++) {\n                var d = dataSources.get(i);\n                if (d.entities.contains(entity)) {\n                    dataSource = d;\n                    break;\n                }\n            }\n        }\n\n        if (!defined(dataSource)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var boundingSpheres = getBoundingSphereArrayScratch;\n        var tmp = getBoundingSphereBoundingSphereScratch;\n\n        var count = 0;\n        var state = BoundingSphereState.DONE;\n        var visualizers = dataSource._visualizers;\n        var visualizersLength = visualizers.length;\n\n        for (i = 0; i < visualizersLength; i++) {\n            var visualizer = visualizers[i];\n            if (defined(visualizer.getBoundingSphere)) {\n                state = visualizers[i].getBoundingSphere(entity, tmp);\n                if (!allowPartial && state === BoundingSphereState.PENDING) {\n                    return BoundingSphereState.PENDING;\n                } else if (state === BoundingSphereState.DONE) {\n                    boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n                    count++;\n                }\n            }\n        }\n\n        if (count === 0) {\n            return BoundingSphereState.FAILED;\n        }\n\n        boundingSpheres.length = count;\n        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n        return BoundingSphereState.DONE;\n    };\n\n    DataSourceDisplay.prototype._onDataSourceAdded = function(dataSourceCollection, dataSource) {\n        var scene = this._scene;\n\n        var displayPrimitives = this._primitives;\n        var displayGroundPrimitives = this._groundPrimitives;\n\n        var primitives = displayPrimitives.add(new PrimitiveCollection());\n        var groundPrimitives = displayGroundPrimitives.add(new OrderedGroundPrimitiveCollection());\n\n        dataSource._primitives = primitives;\n        dataSource._groundPrimitives = groundPrimitives;\n\n        var entityCluster = dataSource.clustering;\n        entityCluster._initialize(scene);\n\n        primitives.add(entityCluster);\n\n        var visualizers = this._visualizersCallback(scene, entityCluster, dataSource);\n\n        dataSource._visualizersByDisplayID = dataSource._visualizersByDisplayID || {};\n        dataSource._visualizersByDisplayID[this._displayID] = visualizers;\n\n        dataSource._visualizers = dataSource._visualizers || [];\n        dataSource._visualizers = dataSource._visualizers.concat(visualizers);\n    };\n\n    DataSourceDisplay.prototype._onDataSourceRemoved = function(dataSourceCollection, dataSource) {\n        var displayPrimitives = this._primitives;\n        var displayGroundPrimitives = this._groundPrimitives;\n\n        var primitives = dataSource._primitives;\n        var groundPrimitives = dataSource._groundPrimitives;\n\n        var entityCluster = dataSource.clustering;\n        primitives.remove(entityCluster);\n\n        var visualizers = dataSource._visualizersByDisplayID[this._displayID];\n        if (!defined(visualizers)) {\n            return;\n        }\n\n        var length = visualizers.length;\n        for (var i = 0; i < length; i++) {\n            var visualizer = visualizers[i];\n            visualizer.destroy();\n\n            var index = dataSource._visualizers.indexOf(visualizer);\n            dataSource._visualizers.splice(index, 1);\n        }\n\n        delete dataSource._visualizersByDisplayID[this._displayID];\n\n        displayPrimitives.remove(primitives);\n        displayGroundPrimitives.remove(groundPrimitives);\n    };\n\n    DataSourceDisplay.prototype._onDataSourceMoved = function(dataSource, newIndex, oldIndex) {\n        var displayPrimitives = this._primitives;\n        var displayGroundPrimitives = this._groundPrimitives;\n\n        var primitives = dataSource._primitives;\n        var groundPrimitives = dataSource._groundPrimitives;\n\n        if (newIndex === oldIndex + 1) {\n            displayPrimitives.raise(primitives);\n            displayGroundPrimitives.raise(groundPrimitives);\n        } else if (newIndex === oldIndex - 1) {\n            displayPrimitives.lower(primitives);\n            displayGroundPrimitives.lower(groundPrimitives);\n        } else if (newIndex === 0) {\n            displayPrimitives.lowerToBottom(primitives);\n            displayGroundPrimitives.lowerToBottom(groundPrimitives);\n            displayPrimitives.raise(primitives); // keep defaultDataSource primitives at index 0 since it's not in the collection\n            displayGroundPrimitives.raise(groundPrimitives);\n        } else {\n            displayPrimitives.raiseToTop(primitives);\n            displayGroundPrimitives.raiseToTop(groundPrimitives);\n        }\n    };\n\n    /**\n     * A function which creates an array of visualizers used for visualization.\n     * @callback DataSourceDisplay~VisualizersCallback\n     *\n     * @param {Scene} scene The scene to create visualizers for.\n     * @param {DataSource} dataSource The data source to create visualizers for.\n     * @returns {Visualizer[]} An array of visualizers used for visualization.\n     *\n     * @example\n     * function createVisualizers(scene, dataSource) {\n     *     return [new Cesium.BillboardVisualizer(scene, dataSource.entities)];\n     * }\n     */\nexport default DataSourceDisplay;\n"],"sourceRoot":""}